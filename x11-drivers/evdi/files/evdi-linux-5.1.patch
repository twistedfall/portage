Only in evdi-1.6.0: .idea
diff -ur evdi-1.6.0.orig/module/evdi_connector.c evdi-1.6.0/module/evdi_connector.c
--- evdi-1.6.0.orig/module/evdi_connector.c	2019-02-18 09:16:54.000000000 +0100
+++ evdi-1.6.0/module/evdi_connector.c	2019-05-07 12:47:44.046975420 +0200
@@ -110,6 +110,11 @@
 				connector->encoder_ids[0]);
 }
 
+#if KERNEL_VERSION(5, 1, 0) <= LINUX_VERSION_CODE
+/* Add header constants missing after 5.1-rc1 */
+int drm_helper_probe_single_connector_modes(struct drm_connector *connector, uint32_t maxX, uint32_t maxY);
+#endif
+
 static struct drm_connector_helper_funcs evdi_connector_helper_funcs = {
 	.get_modes = evdi_get_modes,
 	.mode_valid = evdi_mode_valid,
diff -ur evdi-1.6.0.orig/module/evdi_drv.h evdi-1.6.0/module/evdi_drv.h
--- evdi-1.6.0.orig/module/evdi_drv.h	2019-02-18 09:16:54.000000000 +0100
+++ evdi-1.6.0/module/evdi_drv.h	2019-05-07 12:43:01.391109148 +0200
@@ -121,8 +121,10 @@
 
 #if KERNEL_VERSION(4, 11, 0) > LINUX_VERSION_CODE
 int evdi_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
+#elif KERNEL_VERSION(5, 1, 0) > LINUX_VERSION_CODE
+int evdi_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
 #else
-int evdi_gem_fault(struct vm_fault *vmf);
+vm_fault_t evdi_gem_fault(struct vm_fault *vmf);
 #endif
 
 bool evdi_painter_is_connected(struct evdi_device *evdi);
diff -ur evdi-1.6.0.orig/module/evdi_gem.c evdi-1.6.0/module/evdi_gem.c
--- evdi-1.6.0.orig/module/evdi_gem.c	2019-02-18 09:16:54.000000000 +0100
+++ evdi-1.6.0/module/evdi_gem.c	2019-05-07 12:54:00.496196203 +0200
@@ -115,13 +115,17 @@
 	return ret;
 }
 
-#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
+#if KERNEL_VERSION(4, 11, 0) > LINUX_VERSION_CODE
+int evdi_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+#elif KERNEL_VERSION(5, 1, 0) > LINUX_VERSION_CODE
 int evdi_gem_fault(struct vm_fault *vmf)
 {
 	struct vm_area_struct *vma = vmf->vma;
 #else
-int evdi_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+vm_fault_t evdi_gem_fault(struct vm_fault *vmf)
 {
+    struct vm_area_struct *vma = vmf->vma;
 #endif
 	struct evdi_gem_object *obj = to_evdi_bo(vma->vm_private_data);
 	struct page *page;
diff -ur evdi-1.6.0.orig/module/evdi_main.c evdi-1.6.0/module/evdi_main.c
--- evdi-1.6.0.orig/module/evdi_main.c	2019-02-18 09:16:54.000000000 +0100
+++ evdi-1.6.0/module/evdi_main.c	2019-05-07 12:48:58.934559830 +0200
@@ -16,6 +16,12 @@
 #include "evdi_drv.h"
 #include "evdi_cursor.h"
 
+#if KERNEL_VERSION(5, 1, 0) <= LINUX_VERSION_CODE
+/* Add header constants missing after 5.1-rc1 */
+void drm_kms_helper_poll_init(struct drm_device *dev);
+void drm_kms_helper_poll_fini(struct drm_device *dev);
+#endif
+
 int evdi_driver_setup(struct drm_device *dev)
 {
 	struct platform_device *platdev = NULL;
diff -ur evdi-1.6.0.orig/module/evdi_painter.c evdi-1.6.0/module/evdi_painter.c
--- evdi-1.6.0.orig/module/evdi_painter.c	2019-02-18 09:16:54.000000000 +0100
+++ evdi-1.6.0/module/evdi_painter.c	2019-05-07 12:55:03.145020411 +0200
@@ -27,6 +27,9 @@
 {
 	drm_framebuffer_reference(fb);
 }
+#elif KERNEL_VERSION(5, 1, 0) <= LINUX_VERSION_CODE
+/* Add header constants missing after 5.1-rc1 */
+bool drm_helper_hpd_irq_event(struct drm_device *dev);
 #endif
 
 struct evdi_event_cursor_set_pending {
