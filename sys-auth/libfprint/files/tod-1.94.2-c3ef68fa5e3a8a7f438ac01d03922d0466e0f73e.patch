diff --git a/NEWS.tod.md b/NEWS.tod.md
new file mode 100644
index 0000000..66e764f
--- /dev/null
+++ b/NEWS.tod.md
@@ -0,0 +1,25 @@
+### libfprint-TOD v1
+
+- First public release
+- Based on [libfprint 1.90.1](https://gitlab.freedesktop.org/libfprint/libfprint/-/releases#v1.90.1)
+- Bumped TOD version to 1
+
+### Highlights of the Drivers API changes
+
+Both the driver and external APIs have changed, as both the verify and the identify functions now have early reporting mechanisms.
+
+- Added API for early report of matching results or retry errors
+- Verify and identification completion functions have been simplified
+- Support variadic arguments in error functions
+- Various re-definitions of ownership handling
+- Add convenience API to change state after a timeout
+- Add unit tests for all the drivers API
+
+### Drivers required changes
+As per the early report mechanism, drivers need to adapt, in particular:
+ - New pkg-config dependency name is `libfprint-2-tod-1`
+ - Verification and Identification API for non-image drivers has changed and drivers need to both `report` the result of the action and complete it:
+   - `fpi_device_{verify,identify}_report` must inform whether a match/no-match or identification happened or report a *retry error*.
+   - `fpi_device_{verify,identify}_complete` must be called once the device has completed the verification / identification process,  in case reporting device errors (not retry ones!)
+
+You can see examples of changes needed in the [reference example driver](https://gitlab.freedesktop.org/3v1n0/libfprint-tod-example-driver/-/commit/8308f84f7d1cfd1b9ed0936c13c73b43a4a46772) or the [upstream synaptics driver](https://gitlab.freedesktop.org/libfprint/libfprint/-/merge_requests/112/diffs)
diff --git a/README b/README
index fbf7670..2984659 100644
--- a/README
+++ b/README
@@ -39,6 +39,10 @@ We include bozorth3 from the US export controlled distribution. We have
 determined that it is fine to ship bozorth3 in an open source project,
 see https://fprint.freedesktop.org/us-export-control.html
 
+## TOD Informations
+
+See https://gitlab.freedesktop.org/3v1n0/libfprint/-/blob/tod/README.tod.md
+
 ## Historical links
 
 Older versions of libfprint are available at:
diff --git a/README.tod.md b/README.tod.md
new file mode 100644
index 0000000..34d71a8
--- /dev/null
+++ b/README.tod.md
@@ -0,0 +1,9 @@
+### libfprint-TOD - libfprint for Touch OEM Drivers
+
+This is a light fork of libfprint to expose internal Drivers API in order to
+create drivers as shared libraries.
+
+Fork is hosted at: https://gitlab.freedesktop.org/3v1n0/libfprint/tree/tod
+
+An example driver implementation is available:
+ - https://gitlab.freedesktop.org/3v1n0/libfprint-tod-example-driver
diff --git a/examples/meson.build b/examples/meson.build
index 0661546..3f21347 100644
--- a/examples/meson.build
+++ b/examples/meson.build
@@ -21,3 +21,13 @@ executable('cpp-test',
     'cpp-test.cpp',
     dependencies: libfprint_dep,
 )
+
+if get_option('tod')
+    executable('tod-inspector',
+        sources: 'tod-inspector.c',
+        dependencies: [
+            libfprint_dep,
+            tod_dep,
+        ],
+    )
+endif
diff --git a/examples/tod-inspector.c b/examples/tod-inspector.c
new file mode 100644
index 0000000..b121422
--- /dev/null
+++ b/examples/tod-inspector.c
@@ -0,0 +1,161 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <libfprint/fprint.h>
+
+#include "libfprint/tod/tod-shared-loader.h"
+#include "libfprint/fpi-device.h"
+
+static char *
+id_table_to_string (FpDeviceType     device_type,
+                    const FpIdEntry *id_table)
+{
+  const FpIdEntry *entry;
+  char *str = NULL;
+
+  if (!id_table)
+    return g_strdup ("INVALID: Empty ID table");
+
+  entry = id_table;
+  while (TRUE)
+    {
+      g_autofree char *value = NULL;
+
+      if (device_type == FP_DEVICE_TYPE_VIRTUAL)
+        {
+          if (entry->virtual_envvar)
+            value = g_strdup (entry->virtual_envvar);
+        }
+      else if (device_type == FP_DEVICE_TYPE_USB)
+        {
+          if (entry->vid)
+            value = g_strdup_printf ("%04x:%04x", entry->vid, entry->pid);
+        }
+      else if (device_type == FP_DEVICE_TYPE_UDEV)
+        {
+          if (entry->hid_id.vid)
+            {
+              g_autofree gchar *udev_flags = NULL;
+
+              udev_flags = g_flags_to_string (fpi_device_udev_subtype_flags_get_type (),
+                                              entry->udev_types);
+              value = g_strdup_printf ("%s (%04x:%04x) [%s]",
+                                       entry->spi_acpi_id,
+                                       entry->hid_id.vid, entry->hid_id.pid,
+                                       udev_flags);
+            }
+          else
+            {
+              value = g_strdup (entry->spi_acpi_id);
+            }
+        }
+      else
+        {
+          return g_strdup ("Unsupported device type");
+        }
+
+      if (!value)
+        return str;
+
+      if (!str)
+        {
+          str = g_steal_pointer (&value);
+        }
+      else
+        {
+          g_autofree char *tmp = g_steal_pointer (&str);
+          str = g_strconcat (tmp, ", ", value, NULL);
+        }
+
+      entry++;
+    }
+
+  return str;
+}
+
+static const char *
+device_type_to_string (FpDeviceType device_type)
+{
+  g_autoptr(GEnumClass) device_types = g_type_class_ref (fp_device_type_get_type ());
+  GEnumValue *value = g_enum_get_value (device_types, device_type);
+
+  return value->value_nick;
+}
+
+static const char *
+scan_type_to_string (FpScanType scan_type)
+{
+  g_autoptr(GEnumClass) scan_types = g_type_class_ref (fp_scan_type_get_type ());
+  GEnumValue *value = g_enum_get_value (scan_types, scan_type);
+
+  return value->value_nick;
+}
+
+int
+main (void)
+{
+  g_autoptr(GArray) shared_drivers = NULL;
+  guint i;
+
+  fpi_tod_shared_drivers_register ();
+
+  shared_drivers = fpi_tod_shared_drivers_get ();
+  g_print ("Found %u drivers\n", shared_drivers->len);
+
+  for (i = 0; i < shared_drivers->len; i++)
+    {
+      GType driver = g_array_index (shared_drivers, GType, i);
+      g_autoptr(FpDeviceClass) cls = g_type_class_ref (driver);
+      g_autofree char *id_table = NULL;
+      g_autofree char *features = NULL;
+
+      id_table = id_table_to_string (cls->type, cls->id_table);
+      features = g_flags_to_string (fp_device_feature_get_type (), cls->features);
+
+      g_print ("ID: %s\n", cls->id);
+      g_print ("Full Name: %s\n", cls->full_name);
+      g_print ("Type: %s\n", device_type_to_string (cls->type));
+      g_print ("Enroll stages: %d\n", cls->nr_enroll_stages);
+      g_print ("Scan type: %s\n", scan_type_to_string (cls->scan_type));
+      g_print ("Seconds to get Hot: %d\n", cls->temp_hot_seconds);
+      g_print ("Seconds to get Cold: %d\n", cls->temp_cold_seconds);
+      g_print ("Supported Devices: %s\n", id_table);
+      g_print ("Supported features: %s\n", features);
+      g_print ("Implemented VFuncs:\n");
+      g_print ("  usb_discover: %s\n", cls->usb_discover ? "true" : "false");
+      g_print ("  probe: %s\n", cls->probe ? "true" : "false");
+      g_print ("  open: %s\n", cls->open ? "true" : "false");
+      g_print ("  close: %s\n", cls->close ? "true" : "false");
+      g_print ("  suspend: %s\n", cls->suspend ? "true" : "false");
+      g_print ("  resume: %s\n", cls->resume ? "true" : "false");
+      g_print ("  enroll: %s\n", cls->enroll ? "true" : "false");
+      g_print ("  verify: %s\n", cls->verify ? "true" : "false");
+      g_print ("  identify: %s\n", cls->identify ? "true" : "false");
+      g_print ("  capture: %s\n", cls->capture ? "true" : "false");
+      g_print ("  list: %s\n", cls->list ? "true" : "false");
+      g_print ("  delete: %s\n", cls->delete ? "true" : "false");
+      g_print ("  clear_storage: %s\n", cls->clear_storage ? "true" : "false");
+      g_print ("  cancel: %s\n", cls->cancel ? "true" : "false");
+
+      if (i < shared_drivers->len - 1)
+        g_print ("------------\n");
+    }
+
+  fpi_tod_shared_drivers_unregister ();
+}
diff --git a/libfprint/fp-context.c b/libfprint/fp-context.c
index d4bd000..65c57b2 100644
--- a/libfprint/fp-context.c
+++ b/libfprint/fp-context.c
@@ -27,6 +27,10 @@
 
 #include <config.h>
 
+#ifdef HAVE_LIBFPRINT_TOD
+#include "tod/tod-shared-loader.h"
+#endif
+
 #ifdef HAVE_UDEV
 #include <gudev/gudev.h>
 #endif
@@ -303,6 +307,8 @@ fp_context_finalize (GObject *object)
     g_object_run_dispose (G_OBJECT (priv->usb_ctx));
   g_clear_object (&priv->usb_ctx);
 
+  fpi_tod_shared_drivers_unregister ();
+
   G_OBJECT_CLASS (fp_context_parent_class)->finalize (object);
 }
 
@@ -358,11 +364,16 @@ static void
 fp_context_init (FpContext *self)
 {
   g_autoptr(GError) error = NULL;
+  g_autoptr(GArray) shared_drivers = NULL;
   FpContextPrivate *priv = fp_context_get_instance_private (self);
   guint i;
 
   priv->drivers = fpi_get_driver_types ();
 
+  fpi_tod_shared_drivers_register ();
+  shared_drivers = fpi_tod_shared_drivers_get ();
+  g_array_prepend_vals (priv->drivers, shared_drivers->data, shared_drivers->len);
+
   if (get_drivers_whitelist_env ())
     {
       for (i = 0; i < priv->drivers->len;)
@@ -426,6 +437,7 @@ void
 fp_context_enumerate (FpContext *context)
 {
   FpContextPrivate *priv = fp_context_get_instance_private (context);
+  gboolean dispatched;
   gint i;
 
   g_return_if_fail (FP_IS_CONTEXT (context));
@@ -564,8 +576,19 @@ fp_context_enumerate (FpContext *context)
   }
 #endif
 
-  while (priv->pending_devices)
-    g_main_context_iteration (NULL, TRUE);
+  /* Iterate until 1. we have no pending devices, and 2. the mainloop is idle
+   * This takes care of processing hotplug events that happened during
+   * enumeration.
+   * This is important due to USB `persist` being turned off. At resume time,
+   * devices will disappear and immediately re-appear. In this situation,
+   * enumerate could first see the old state with a removed device resulting
+   * in it to not be discovered.
+   * As a hotplug event is seemingly emitted by the kernel immediately, we can
+   * simply make sure to process all events before returning from enumerate.
+   */
+  dispatched = TRUE;
+  while (priv->pending_devices || dispatched)
+    dispatched = g_main_context_iteration (NULL, !!priv->pending_devices);
 }
 
 /**
diff --git a/libfprint/fp-device.h b/libfprint/fp-device.h
index 85be34c..5a9dda0 100644
--- a/libfprint/fp-device.h
+++ b/libfprint/fp-device.h
@@ -43,8 +43,8 @@ G_DECLARE_DERIVABLE_TYPE (FpDevice, fp_device, FP, DEVICE, GObject)
  */
 typedef enum {
   FP_DEVICE_TYPE_VIRTUAL,
-  FP_DEVICE_TYPE_UDEV,
   FP_DEVICE_TYPE_USB,
+  FP_DEVICE_TYPE_UDEV,
 } FpDeviceType;
 
 /**
diff --git a/libfprint/fp-image.c b/libfprint/fp-image.c
index 51732c1..fa3a5b4 100644
--- a/libfprint/fp-image.c
+++ b/libfprint/fp-image.c
@@ -23,6 +23,7 @@
 #include "fpi-image.h"
 #include "fpi-log.h"
 
+#include <config.h>
 #include <nbis.h>
 
 /**
diff --git a/libfprint/fpi-assembling.h b/libfprint/fpi-assembling.h
index af7c4ac..808b66b 100644
--- a/libfprint/fpi-assembling.h
+++ b/libfprint/fpi-assembling.h
@@ -20,6 +20,7 @@
 #pragma once
 
 #include "fp-image.h"
+#include "tod/tod-macros.h"
 
 /**
  * fpi_frame:
@@ -110,6 +111,9 @@ struct fpi_line_asmbl_ctx
   unsigned char (*get_pixel)(struct fpi_line_asmbl_ctx *ctx,
                              GSList                    *line,
                              unsigned int               x);
+
+  /*< private >*/
+  TOD_PADDING (32, 0);
 };
 
 FpImage *fpi_assemble_lines (struct fpi_line_asmbl_ctx *ctx,
diff --git a/libfprint/fpi-device.h b/libfprint/fpi-device.h
index 25e79c9..1738652 100644
--- a/libfprint/fpi-device.h
+++ b/libfprint/fpi-device.h
@@ -23,11 +23,14 @@
 #include "fp-device.h"
 #include "fp-image.h"
 #include "fpi-print.h"
+#include "tod/tod-macros.h"
 
 /**
- * FpiDeviceUdevSubtype:
+ * FpiDeviceUdevSubtypeFlags:
  * @FPI_DEVICE_UDEV_SUBTYPE_SPIDEV: The device requires an spidev node
  * @FPI_DEVICE_UDEV_SUBTYPE_HIDRAW: The device requires a hidraw node
+ *
+ * Bitfield of required hardware resources for a udev-backed device.
  */
 typedef enum {
   FPI_DEVICE_UDEV_SUBTYPE_SPIDEV = 1 << 0,
@@ -53,6 +56,12 @@ struct _FpIdEntry
       guint vid;
     };
     const gchar *virtual_envvar;
+  };
+  guint64 driver_data;
+
+  /* Elements added after TODv1 */
+  union
+  {
     struct
     {
       FpiDeviceUdevSubtypeFlags udev_types;
@@ -64,7 +73,13 @@ struct _FpIdEntry
       } hid_id;
     };
   };
-  guint64 driver_data;
+
+  /*< private >*/
+  /* padding for future expansion */
+  TOD_PADDING_ALIGNED (16,
+                       sizeof (guint) * 2 +
+                       sizeof (FpiDeviceUdevSubtypeFlags) +
+                       sizeof (gpointer));
 };
 
 /**
@@ -145,16 +160,11 @@ struct _FpDeviceClass
   const gchar     *full_name;
   FpDeviceType     type;
   const FpIdEntry *id_table;
-  FpDeviceFeature  features;
 
   /* Defaults for device properties */
   gint       nr_enroll_stages;
   FpScanType scan_type;
 
-  /* Simple device temperature model constants */
-  gint32 temp_hot_seconds;
-  gint32 temp_cold_seconds;
-
   /* Callbacks */
   gint (*usb_discover) (GUsbDevice *usb_device);
   void (*probe)    (FpDevice *device);
@@ -166,11 +176,26 @@ struct _FpDeviceClass
   void (*capture)  (FpDevice *device);
   void (*list)     (FpDevice *device);
   void (*delete)   (FpDevice * device);
-  void (*clear_storage)  (FpDevice * device);
 
   void (*cancel)   (FpDevice *device);
-  void (*suspend)  (FpDevice *device);
-  void (*resume)   (FpDevice *device);
+
+  /* Class elements added after tod-v1 */
+  FpDeviceFeature features;
+
+  /* Simple device temperature model constants */
+  gint32 temp_hot_seconds;
+  gint32 temp_cold_seconds;
+
+  void   (*clear_storage)  (FpDevice * device);
+  void   (*suspend)  (FpDevice *device);
+  void   (*resume)   (FpDevice *device);
+
+  /*< private >*/
+  /* padding for future expansion */
+  TOD_PADDING_ALIGNED8 (32,
+                        sizeof (FpDeviceFeature) +
+                        sizeof (gint32) * 2 +
+                        sizeof (gpointer) * 3);
 };
 
 void fpi_device_class_auto_initialize_features (FpDeviceClass *device_class);
diff --git a/libfprint/fpi-image-device.h b/libfprint/fpi-image-device.h
index 71472db..63e70b1 100644
--- a/libfprint/fpi-image-device.h
+++ b/libfprint/fpi-image-device.h
@@ -62,12 +62,12 @@
  */
 typedef enum {
   FPI_IMAGE_DEVICE_STATE_INACTIVE,
-  FPI_IMAGE_DEVICE_STATE_ACTIVATING,
-  FPI_IMAGE_DEVICE_STATE_DEACTIVATING,
-  FPI_IMAGE_DEVICE_STATE_IDLE,
   FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_ON,
   FPI_IMAGE_DEVICE_STATE_CAPTURE,
   FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_OFF,
+  FPI_IMAGE_DEVICE_STATE_ACTIVATING,
+  FPI_IMAGE_DEVICE_STATE_DEACTIVATING,
+  FPI_IMAGE_DEVICE_STATE_IDLE,
 } FpiImageDeviceState;
 
 /**
@@ -114,6 +114,10 @@ struct _FpImageDeviceClass
   void          (*change_state) (FpImageDevice      *dev,
                                  FpiImageDeviceState state);
   void          (*deactivate)   (FpImageDevice *dev);
+
+  /*< private >*/
+  /* padding for future expansion */
+  TOD_PADDING (32, 0);
 };
 
 void fpi_image_device_set_bz3_threshold (FpImageDevice *self,
diff --git a/libfprint/fpi-image.c b/libfprint/fpi-image.c
index 47aac8d..95465ad 100644
--- a/libfprint/fpi-image.c
+++ b/libfprint/fpi-image.c
@@ -24,6 +24,7 @@
 #include "fpi-log.h"
 
 #include <nbis.h>
+#include <config.h>
 
 #if HAVE_PIXMAN
 #include <pixman.h>
@@ -107,12 +108,12 @@ fpi_mean_sq_diff_norm (const guint8 *buf1,
   return res / size;
 }
 
-#if HAVE_PIXMAN
 FpImage *
 fpi_image_resize (FpImage *orig_img,
                   guint    w_factor,
                   guint    h_factor)
 {
+#if HAVE_PIXMAN
   int new_width = orig_img->width * w_factor;
   int new_height = orig_img->height * h_factor;
   pixman_image_t *orig, *resized;
@@ -145,5 +146,9 @@ fpi_image_resize (FpImage *orig_img,
   pixman_image_unref (resized);
 
   return newimg;
-}
+#else
+  fp_err ("Libfprint compiled without pixman support, impossible to resize");
+
+  return NULL;
 #endif
+}
diff --git a/libfprint/fpi-image.h b/libfprint/fpi-image.h
index fcd62b8..7c54a71 100644
--- a/libfprint/fpi-image.h
+++ b/libfprint/fpi-image.h
@@ -20,8 +20,8 @@
 
 #pragma once
 
-#include <config.h>
 #include "fp-image.h"
+#include "tod/tod-macros.h"
 
 /**
  * FpiImageFlags:
@@ -69,6 +69,8 @@ struct _FpImage
 
   GPtrArray *minutiae;
   guint      ref_count;
+
+  TOD_PADDING (32, 0);
 };
 
 gint fpi_std_sq_dev (const guint8 *buf,
@@ -77,8 +79,6 @@ gint fpi_mean_sq_diff_norm (const guint8 *buf1,
                             const guint8 *buf2,
                             gint          size);
 
-#if HAVE_PIXMAN
 FpImage *fpi_image_resize (FpImage *orig,
                            guint    w_factor,
                            guint    h_factor);
-#endif
diff --git a/libfprint/fpi-spi-transfer.h b/libfprint/fpi-spi-transfer.h
index 755b405..e545e6a 100644
--- a/libfprint/fpi-spi-transfer.h
+++ b/libfprint/fpi-spi-transfer.h
@@ -73,6 +73,9 @@ struct _FpiSpiTransfer
   /* Data free function */
   GDestroyNotify free_buffer_wr;
   GDestroyNotify free_buffer_rd;
+
+  /* padding for future expansion */
+  TOD_PADDING (32, 0);
 };
 
 GType              fpi_spi_transfer_get_type (void) G_GNUC_CONST;
diff --git a/libfprint/fpi-ssm.c b/libfprint/fpi-ssm.c
index 8ceab67..8080f55 100644
--- a/libfprint/fpi-ssm.c
+++ b/libfprint/fpi-ssm.c
@@ -747,3 +747,7 @@ fpi_ssm_spi_transfer_with_weak_pointer_cb (FpiSpiTransfer *transfer,
 
   fpi_ssm_spi_transfer_cb (transfer, device, weak_ptr, error);
 }
+
+#ifdef TOD_LIBRARY
+#include "tod/tod-fpi-ssm.c"
+#endif
diff --git a/libfprint/fpi-usb-transfer.h b/libfprint/fpi-usb-transfer.h
index 3770003..8b862b4 100644
--- a/libfprint/fpi-usb-transfer.h
+++ b/libfprint/fpi-usb-transfer.h
@@ -102,6 +102,9 @@ struct _FpiUsbTransfer
 
   /* Data free function */
   GDestroyNotify free_buffer;
+
+  /* padding for future expansion */
+  TOD_PADDING (32, 0);
 };
 
 GType              fpi_usb_transfer_get_type (void) G_GNUC_CONST;
diff --git a/libfprint/meson.build b/libfprint/meson.build
index 25ed10f..3db7dd4 100644
--- a/libfprint/meson.build
+++ b/libfprint/meson.build
@@ -253,6 +253,10 @@ libfprint_private = static_library('fprint-private',
     link_with: libnbis,
     install: false)
 
+if get_option('tod')
+    subdir('tod')
+endif
+
 libfprint_drivers = static_library('fprint-drivers',
     sources: drivers_sources,
     c_args: drivers_cflags,
diff --git a/libfprint/tod/libfprint-tod.ver.in b/libfprint/tod/libfprint-tod.ver.in
new file mode 100644
index 0000000..8166f16
--- /dev/null
+++ b/libfprint/tod/libfprint-tod.ver.in
@@ -0,0 +1,33 @@
+LIBFPRINT_TOD_@tod_soversion@.0.0 {
+global:
+	fpi_*;
+    fpi_ssm_new_full;
+    fpi_ssm_jump_to_state_delayed;
+    fpi_ssm_mark_completed_delayed;
+    fpi_ssm_next_state_delayed;
+local:
+    *;
+};
+
+LIBFPRINT_TOD_@tod_soversion@_1.92 {
+global:
+    fpi_device_class_auto_initialize_features;
+    fpi_device_clear_storage_complete;
+    fpi_device_get_udev_data;
+    fpi_device_update_features;
+    fpi_spi_*;
+    fpi_ssm_get_device;
+    fpi_ssm_jump_to_state_delayed;
+    fpi_ssm_mark_completed_delayed;
+    fpi_ssm_new_full;
+    fpi_ssm_next_state_delayed;
+    fpi_ssm_spi_*;
+} LIBFPRINT_TOD_@tod_soversion@.0.0;
+
+LIBFPRINT_TOD_@tod_soversion@_1.94 {
+global:
+    fpi_device_critical_enter;
+    fpi_device_critical_leave;
+    fpi_device_resume_complete;
+    fpi_device_suspend_complete;
+} LIBFPRINT_TOD_@tod_soversion@_1.92;
diff --git a/libfprint/tod/meson.build b/libfprint/tod/meson.build
new file mode 100644
index 0000000..ba395c1
--- /dev/null
+++ b/libfprint/tod/meson.build
@@ -0,0 +1,97 @@
+tod_soversion = 1
+tod_subpath = versioned_libname / 'tod-@0@'.format(tod_soversion)
+tod_modules_prefix = get_option('libdir') / tod_subpath
+
+tod_conf = configuration_data()
+tod_conf.set_quoted('TOD_DRIVERS_DIR',
+    get_option('prefix') / get_option('libdir') / tod_subpath)
+configure_file(output: 'tod-config.h', configuration: tod_conf)
+
+gmodule_dep = dependency('gmodule-2.0', version: '>=' + glib_min_version)
+deps += gmodule_dep
+
+mapfile = configure_file(input: 'libfprint-tod.ver.in',
+    output: 'libfprint-tod.ver',
+    configuration: {
+    'tod_soversion' : tod_soversion,
+})
+
+libfprint_tod_private = static_library('fprint-tod-private',
+    sources: [
+        'tod-shared-loader.c',
+    ],
+    include_directories: include_directories('..'),
+    link_with: libfprint_private,
+    dependencies: deps,
+    install: false,
+)
+
+tod_sources = [
+    'tod-wrappers.c',
+    'tod-symbols.h',
+]
+foreach source: libfprint_private_sources
+    tod_sources += '..' / source
+endforeach
+
+libfprint_tod = library(versioned_libname.split('lib')[1] + '-tod',
+    c_args: [
+        '-DTOD_LIBRARY=1',
+        '-include', '@0@'.format(files('tod-symbols.h')[0]),
+    ],
+    sources: [
+        tod_sources,
+    ],
+    soversion: tod_soversion,
+    include_directories: include_directories('..'),
+    link_args: [
+        '-Wl,--version-script,@0@'.format(mapfile),
+        '-Wl,--unresolved-symbols=ignore-in-object-files'
+    ],
+    link_depends: mapfile,
+    link_with: [libfprint_private],
+    dependencies: deps,
+    install: true)
+
+tod_dep = declare_dependency(
+    link_with: [
+        libfprint_tod,
+        libfprint_tod_private,
+    ])
+deps += tod_dep
+
+pkgconfig = import('pkgconfig')
+pkgconfig.generate(libfprint_tod,
+    name: versioned_libname + '-tod',
+    filebase: '@0@-tod-@1@'.format(versioned_libname, tod_soversion),
+    description: 'Private Libfprint Touch Drivers API',
+    version: meson.project_version() + '+tod@0@'.format(tod_soversion),
+    subdirs: tod_subpath,
+    requires_private: [
+        versioned_libname,
+    ],
+    variables: [
+        'tod_driversdir=${libdir}/@0@'.format(tod_subpath)
+    ]
+)
+
+tod_headers = []
+extra_libfprint_headers = [
+    'drivers_api.h',
+]
+
+foreach header: libfprint_private_headers + extra_libfprint_headers
+    tod_headers += '..' / header
+endforeach
+
+custom_target('tod_fpi_enums_headers',
+  depends: fpi_enums,
+  input: fpi_enums_h,
+  output: 'fpi-enums.h',
+  command: ['cp', '@INPUT@', '-v', '@OUTPUT@'],
+  install: true,
+  install_dir: get_option('includedir') / tod_subpath)
+
+install_headers(tod_headers,
+    subdir: tod_subpath
+)
diff --git a/libfprint/tod/tod-fpi-ssm.c b/libfprint/tod/tod-fpi-ssm.c
new file mode 100644
index 0000000..32e282f
--- /dev/null
+++ b/libfprint/tod/tod-fpi-ssm.c
@@ -0,0 +1,67 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "tod-wrappers.h"
+#include "fpi-ssm.h"
+
+static gboolean
+check_delayed_cancellable (FpiSsm       *machine,
+                           GCancellable *cancellable)
+{
+  if (g_cancellable_is_cancelled (cancellable))
+    {
+      fpi_ssm_mark_failed (machine, g_error_new (G_IO_ERROR,
+                                                 G_IO_ERROR_CANCELLED,
+                                                 "Action cancelled"));
+      return FALSE;
+    }
+
+  if (cancellable)
+    fp_err ("GCancellable in SSM Delayed actions is ignored as per libfprint 1.92");
+
+  return TRUE;
+}
+
+void
+fpi_ssm_next_state_delayed_1_90 (FpiSsm       *machine,
+                                 int           delay,
+                                 GCancellable *cancellable)
+{
+  if (check_delayed_cancellable (machine, cancellable))
+    fpi_ssm_next_state_delayed (machine, delay);
+}
+
+void
+fpi_ssm_jump_to_state_delayed_1_90 (FpiSsm       *machine,
+                                    int           state,
+                                    int           delay,
+                                    GCancellable *cancellable)
+{
+  if (check_delayed_cancellable (machine, cancellable))
+    fpi_ssm_jump_to_state_delayed (machine, state, delay);
+}
+
+void
+fpi_ssm_mark_completed_delayed_1_90 (FpiSsm       *machine,
+                                     int           delay,
+                                     GCancellable *cancellable)
+{
+  if (check_delayed_cancellable (machine, cancellable))
+    fpi_ssm_mark_completed_delayed (machine, delay);
+}
diff --git a/libfprint/tod/tod-macros.h b/libfprint/tod/tod-macros.h
new file mode 100644
index 0000000..4adfd94
--- /dev/null
+++ b/libfprint/tod/tod-macros.h
@@ -0,0 +1,32 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#define TOD_PADDING(original, wasted) \
+  char _tod_expansion_padding[(GLIB_SIZEOF_VOID_P * (original)) - (wasted)];
+
+#define TOD_PADDING_ALIGNED(original, wasted) \
+  TOD_PADDING (original, (wasted) + GLIB_SIZEOF_VOID_P)
+
+#define TOD_PADDING_ALIGNED4(original, wasted) \
+  TOD_PADDING (original, (wasted) + (GLIB_SIZEOF_VOID_P == 4 ? GLIB_SIZEOF_VOID_P : 0))
+
+#define TOD_PADDING_ALIGNED8(original, wasted) \
+  TOD_PADDING (original, (wasted) + (GLIB_SIZEOF_VOID_P == 8 ? GLIB_SIZEOF_VOID_P : 0))
diff --git a/libfprint/tod/tod-shared-loader.c b/libfprint/tod/tod-shared-loader.c
new file mode 100644
index 0000000..d214aeb
--- /dev/null
+++ b/libfprint/tod/tod-shared-loader.c
@@ -0,0 +1,157 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#define FP_COMPONENT "tod"
+
+#include <gmodule.h>
+
+#include "tod-shared-loader.h"
+#include "fpi-device.h"
+#include "fpi-log.h"
+#include "tod-config.h"
+
+#define FPI_TOD_ENTRY_GTYPE_GETTER "fpi_tod_shared_driver_get_type"
+
+static GArray *shared_drivers = NULL;
+static GList *shared_modules = NULL;
+
+typedef GModule FpiTodModule;
+typedef GType (*FpiTodShardDriverTypeGetter) (void);
+
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (FpiTodModule, g_module_close);
+
+static const char *
+get_tod_drivers_dir (void)
+{
+  const char *tod_env_path = g_getenv ("FP_TOD_DRIVERS_DIR");
+
+  if (!tod_env_path || *tod_env_path == '\0')
+    return TOD_DRIVERS_DIR;
+
+  return tod_env_path;
+}
+
+void
+fpi_tod_shared_drivers_register (void)
+{
+  const char *dirname;
+  const char *basename;
+
+  g_autoptr(GError) error = NULL;
+  g_autoptr(GDir) dir = NULL;
+  gpointer symbol;
+
+  g_assert_null (shared_drivers);
+
+  dirname = get_tod_drivers_dir ();
+  dir = g_dir_open (dirname, 0, &error);
+
+  shared_drivers = g_array_new (TRUE, FALSE, sizeof (GType));
+
+  if (error)
+    {
+      fp_dbg ("Impossible to load the shared drivers dir %s", error->message);
+      return;
+    }
+
+  while ((basename = g_dir_read_name (dir)) != NULL)
+    {
+      g_autoptr(FpiTodModule) module = NULL;
+      g_autoptr(GTypeClass) type_class = NULL;
+      g_autofree char *module_path = NULL;
+      FpiTodShardDriverTypeGetter type_getter;
+      FpDeviceClass *cls;
+      GType driver;
+
+      if (!g_str_has_prefix (basename, "lib"))
+        continue;
+
+      if (!g_str_has_suffix (basename, ".so"))
+        continue;
+
+      module_path = g_build_filename (dirname, basename, NULL);
+
+      if (!g_file_test (module_path, G_FILE_TEST_IS_REGULAR))
+        continue;
+
+      fp_dbg ("Opening driver %s", module_path);
+
+      module = g_module_open (module_path, G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);
+
+      if (!module)
+        {
+          fp_err ("Impossible to load module %s: %s", module_path,
+                  g_module_error ());
+          continue;
+        }
+
+      if (!g_module_symbol (module, FPI_TOD_ENTRY_GTYPE_GETTER, &symbol))
+        {
+          fp_err ("Library %s doesn't expose the required entry point symbol",
+                  module_path);
+          continue;
+        }
+
+      type_getter = symbol;
+      driver = type_getter ();
+      fp_dbg ("Found TOD entry point symbol %p, GType is %lu", symbol, driver);
+
+      if (!G_TYPE_IS_OBJECT (driver) || !g_type_is_a (driver, FP_TYPE_DEVICE))
+        {
+          fp_err ("Library %s returned GType (%lu) doesn't represent a device",
+                  module_path, driver);
+          continue;
+        }
+
+      type_class = g_type_class_ref (driver);
+      g_assert_true (g_type_check_class_is_a (type_class, FP_TYPE_DEVICE));
+
+      cls = FP_DEVICE_CLASS (type_class);
+
+      fp_dbg ("Loading driver %s (%s)", cls->id, cls->full_name);
+      g_array_append_val (shared_drivers, driver);
+
+      if (cls->features == FP_DEVICE_FEATURE_NONE)
+        {
+          g_debug ("Initializing features for driver %s", cls->id);
+          fpi_device_class_auto_initialize_features (cls);
+        }
+
+      shared_modules = g_list_prepend (shared_modules,
+                                       g_steal_pointer (&module));
+    }
+}
+
+void
+fpi_tod_shared_drivers_unregister (void)
+{
+  g_clear_pointer (&shared_drivers, g_array_unref);
+
+  if (g_strcmp0 (g_getenv ("FP_TOD_KEEP_MODULES_OPEN"), "TRUE") != 0)
+    {
+      g_list_free_full (shared_modules, (GDestroyNotify) g_module_close);
+      shared_modules = NULL;
+    }
+}
+
+GArray *
+fpi_tod_shared_drivers_get (void)
+{
+  return g_array_ref (shared_drivers);
+}
diff --git a/libfprint/tod/tod-shared-loader.h b/libfprint/tod/tod-shared-loader.h
new file mode 100644
index 0000000..8ed2e81
--- /dev/null
+++ b/libfprint/tod/tod-shared-loader.h
@@ -0,0 +1,28 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include <glib.h>
+
+
+void fpi_tod_shared_drivers_register (void);
+void fpi_tod_shared_drivers_unregister (void);
+
+GArray *fpi_tod_shared_drivers_get (void);
diff --git a/libfprint/tod/tod-symbols.h b/libfprint/tod/tod-symbols.h
new file mode 100644
index 0000000..d4f497b
--- /dev/null
+++ b/libfprint/tod/tod-symbols.h
@@ -0,0 +1,45 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#define TOD_1_SYMBOL_VERSION_1_90 "LIBFPRINT_TOD_1.0.0"
+#define TOD_1_SYMBOL_VERSION_1_92 "LIBFPRINT_TOD_1_1.92"
+#define TOD_1_SYMBOL_VERSION_1_94 "LIBFPRINT_TOD_1_1.94"
+#define TOD_1_SYMBOL_VERSION(major, minor) \
+  TOD_1_SYMBOL_VERSION_ ## major ## _ ## minor
+
+#define TOD_DEFAULT_VERSION_SYMBOL(symbol, major, minor) \
+  __asm__ (".symver " # symbol "," # symbol "@@@" \
+           TOD_1_SYMBOL_VERSION (major, minor));
+#define TOD_VERSIONED_SYMBOL(symbol, major, minor) \
+  __asm__ (".symver " # symbol "_" # major "_" #minor "," # symbol "@" \
+           TOD_1_SYMBOL_VERSION (major, minor));
+
+TOD_DEFAULT_VERSION_SYMBOL (fpi_ssm_new_full, 1, 92)
+TOD_VERSIONED_SYMBOL (fpi_ssm_new_full, 1, 90)
+
+TOD_DEFAULT_VERSION_SYMBOL (fpi_ssm_next_state_delayed, 1, 92)
+TOD_VERSIONED_SYMBOL (fpi_ssm_next_state_delayed, 1, 90)
+
+TOD_DEFAULT_VERSION_SYMBOL (fpi_ssm_jump_to_state_delayed, 1, 92)
+TOD_VERSIONED_SYMBOL (fpi_ssm_jump_to_state_delayed, 1, 90)
+
+TOD_DEFAULT_VERSION_SYMBOL (fpi_ssm_mark_completed_delayed, 1, 92)
+TOD_VERSIONED_SYMBOL (fpi_ssm_mark_completed_delayed, 1, 90)
diff --git a/libfprint/tod/tod-wrappers.c b/libfprint/tod/tod-wrappers.c
new file mode 100644
index 0000000..181dbb1
--- /dev/null
+++ b/libfprint/tod/tod-wrappers.c
@@ -0,0 +1,31 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#define FP_COMPONENT "tod"
+
+#include "tod-wrappers.h"
+
+FpiSsm *
+fpi_ssm_new_full_1_90 (FpDevice             *dev,
+                       FpiSsmHandlerCallback handler,
+                       int                   nr_states,
+                       const char           *machine_name)
+{
+  return fpi_ssm_new_full (dev, handler, nr_states, nr_states, machine_name);
+}
diff --git a/libfprint/tod/tod-wrappers.h b/libfprint/tod/tod-wrappers.h
new file mode 100644
index 0000000..b01aad4
--- /dev/null
+++ b/libfprint/tod/tod-wrappers.h
@@ -0,0 +1,39 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include "drivers_api.h"
+#include "tod-symbols.h"
+
+extern FpiSsm *fpi_ssm_new_full_1_90 (FpDevice             *dev,
+                                      FpiSsmHandlerCallback handler,
+                                      int                   nr_states,
+                                      const char           *machine_name);
+
+extern void fpi_ssm_next_state_delayed_1_90 (FpiSsm       *machine,
+                                             int           delay,
+                                             GCancellable *cancellable);
+extern void fpi_ssm_jump_to_state_delayed_1_90 (FpiSsm       *machine,
+                                                int           state,
+                                                int           delay,
+                                                GCancellable *cancellable);
+extern void fpi_ssm_mark_completed_delayed_1_90 (FpiSsm       *machine,
+                                                 int           delay,
+                                                 GCancellable *cancellable);
diff --git a/meson.build b/meson.build
index f275051..ad105f1 100644
--- a/meson.build
+++ b/meson.build
@@ -1,5 +1,5 @@
 project('libfprint', [ 'c', 'cpp' ],
-    version: '1.94.2',
+    version: '1.94.2+tod1',
     license: 'LGPLv2.1+',
     default_options: [
         'buildtype=debugoptimized',
@@ -295,6 +295,7 @@ endif
 # Some dependency resolving happens inside here
 subdir('libfprint')
 
+libfprint_conf.set10('HAVE_LIBFPRINT_TOD', get_option('tod'))
 configure_file(output: 'config.h', configuration: libfprint_conf)
 
 subdir('examples')
diff --git a/meson_options.txt b/meson_options.txt
index f9b801f..f57beb1 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -30,3 +30,8 @@ option('doc',
        description: 'Whether to build the API documentation',
        type: 'boolean',
        value: true)
+
+option('tod',
+       description: 'Whether to build the TOD library',
+       type: 'boolean',
+       value: true)
diff --git a/tests/meson.build b/tests/meson.build
index 9b90a75..e1eaedc 100644
--- a/tests/meson.build
+++ b/tests/meson.build
@@ -246,3 +246,150 @@ if valgrind.found()
             'LIBFPRINT_TEST_WRAPPER=' + ' '.join(libfprint_wrapper),
         ])
 endif
+
+if get_option('tod')
+    tod_test_driver_name = 'fake_test_dev_tod'
+    tod_ssm_test_driver_name = 'ssm_test_dev_tod'
+    tod_envs = envs
+    tod_envs.set('FP_TOD_KEEP_MODULES_OPEN', 'TRUE')
+    tod_envs.set('FP_VIRTUAL_FAKE_DEVICE', 'yes')
+    tod_envs.set('FP_TOD_TEST_DRIVER_NAME', tod_test_driver_name)
+    tod_envs.prepend('LD_LIBRARY_PATH',
+        meson.build_root() / 'libfprint',
+        meson.build_root() / 'libfprint' / 'tod')
+    tod_subversion = meson.project_version().split('+tod')[0]
+    tod_c_args = [
+        '-DTEST_TOD_DRIVER=1',
+        '-DTOD_CURRENT_VERSION=@0@'.format(tod_soversion),
+        '-DTOD_CURRENT_SUBVERSION="@0@"'.format(tod_subversion),
+    ]
+
+    fake_driver = shared_module('device-fake-tod-driver',
+        sources: [
+            'test-device-fake.c',
+            'test-device-fake-tod.c',
+        ],
+        c_args: tod_c_args,
+        link_with: [
+            libfprint_tod,
+        ],
+        include_directories: include_directories('../libfprint'),
+        dependencies: deps,
+        install: false
+    )
+
+    fp_todv1_enums = gnome.mkenums_simple('fp-todv1-enums',
+        source_dir: 'tod-drivers',
+        sources: [
+            'tod-drivers/base-fp-device.h',
+            'tod-drivers/base-fp-print.h',
+            'tod-drivers/base-fpi-device.h',
+            'tod-drivers/base-fpi-image.h',
+            'tod-drivers/base-fpi-image-device.h',
+            'tod-drivers/base-fpi-spi.h',
+            'tod-drivers/base-fpi-usb.h',
+        ],
+        install_header: false)
+
+    test_utils_tod = static_library('fprint-test-utils-tod',
+        sources: [
+            'test-utils.c',
+            'test-utils-tod.c',
+            fp_todv1_enums,
+        ],
+        include_directories: 'tod-drivers',
+        dependencies: libfprint_private_dep,
+        install: false)
+
+    tod_standalone_tests = [
+        'fp-todv1-types',
+    ]
+
+    tod_drivers_tests = [
+        'fp-context-tod',
+        'fp-device-tod',
+        'fpi-device',
+    ]
+
+    tod_driver_infos = {
+        tod_test_driver_name + '_current': {
+            'tod-driver': tod_test_driver_name,
+            'tod-dir': meson.current_build_dir(),
+            'supported-tests': tod_drivers_tests,
+        }
+    }
+
+    if host_machine.cpu_family() == 'x86_64'
+        tod_test_versions = [
+            'v1+1.90.1',
+            'v1+1.90.2',
+            'v1+1.90.3',
+            'v1+1.90.5',
+            'v1+1.94.0',
+        ]
+
+        foreach tod_version: tod_test_versions
+            tod_dir = meson.current_source_dir() / 'tod-drivers' / '-'.join([
+                'tod', host_machine.cpu_family(), tod_version
+            ])
+            tod_driver_infos += {
+                tod_test_driver_name + '_' + tod_version: {
+                    'tod-driver': tod_test_driver_name,
+                    'tod-dir': tod_dir,
+                    'supported-tests': tod_drivers_tests,
+                }
+            }
+
+            tod_driver_infos += {
+                tod_ssm_test_driver_name + '_' + tod_version: {
+                    'tod-driver': tod_ssm_test_driver_name,
+                    'tod-dir': tod_dir,
+                    'supported-tests': [
+                        'fp-context-tod',
+                    ],
+                }
+            }
+        endforeach
+    endif
+
+    foreach test_name: tod_drivers_tests + tod_standalone_tests
+        basename = 'test-' + test_name
+        sufix = test_name.endswith('-tod') ? '' : '-tod'
+        tod_test_name = test_name + sufix
+        tod_suites = ['unit-tests', 'tod']
+        test_exe = executable(basename + sufix,
+            sources: basename + '.c',
+            dependencies: libfprint_private_dep,
+            c_args: [
+                common_cflags,
+                tod_c_args,
+            ],
+            link_with: test_utils_tod,
+        )
+
+        foreach tod_driver, tod_driver_info : tod_driver_infos
+            if test_name not in tod_driver_info.get('supported-tests')
+                continue
+            endif
+            tod_test_envs = tod_envs
+            tod_test_envs.prepend('FP_DRIVERS_WHITELIST', tod_driver)
+            tod_test_envs.set('FP_TOD_DRIVERS_DIR', tod_driver_info.get('tod-dir'))
+            tod_test_envs.set('FP_TOD_TEST_DRIVER_NAME', tod_driver)
+
+            test(tod_test_name + '-' + tod_driver,
+                test_exe,
+                suite: tod_suites + [tod_driver],
+                env: tod_test_envs,
+                depends: fake_driver,
+            )
+        endforeach
+
+        if test_name in tod_standalone_tests
+            test(tod_test_name,
+                test_exe,
+                suite: tod_suites,
+                env: tod_envs,
+            )
+        endif
+    endforeach
+endif
diff --git a/tests/test-device-fake-tod.c b/tests/test-device-fake-tod.c
new file mode 100644
index 0000000..aea7387
--- /dev/null
+++ b/tests/test-device-fake-tod.c
@@ -0,0 +1,28 @@
+/*
+ * Virtual driver for device debugging
+ *
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "test-device-fake-tod.h"
+#include "test-device-fake.h"
+
+GType
+fpi_tod_shared_driver_get_type (void)
+{
+  return fpi_device_fake_get_type ();
+}
diff --git a/tests/test-device-fake-tod.h b/tests/test-device-fake-tod.h
new file mode 100644
index 0000000..3660212
--- /dev/null
+++ b/tests/test-device-fake-tod.h
@@ -0,0 +1,25 @@
+/*
+ * Virtual driver for device debugging
+ *
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include <glib-object.h>
+
+GType fpi_tod_shared_driver_get_type (void);
diff --git a/tests/test-device-fake.c b/tests/test-device-fake.c
index 4c61ed3..b07f830 100644
--- a/tests/test-device-fake.c
+++ b/tests/test-device-fake.c
@@ -18,7 +18,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#ifdef TEST_TOD_DRIVER
+#define FP_COMPONENT "fake_test_dev_tod_current"
+#else
 #define FP_COMPONENT "fake_test_dev"
+#endif
 
 #include "test-device-fake.h"
 
diff --git a/tests/test-fp-context-tod.c b/tests/test-fp-context-tod.c
new file mode 100644
index 0000000..7137e3d
--- /dev/null
+++ b/tests/test-fp-context-tod.c
@@ -0,0 +1,110 @@
+/*
+ * FpContext Unit tests
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#define FP_COMPONENT "tod"
+
+#include "fpi-log.h"
+#include <libfprint/fprint.h>
+
+static void
+test_context_new (void)
+{
+  g_autoptr(FpContext) context = fp_context_new ();
+  g_assert_true (FP_CONTEXT (context));
+}
+
+static void
+test_context_has_no_devices (void)
+{
+  g_autoptr(FpContext) context = NULL;
+  GPtrArray *devices;
+  const char *old_drivers_dir = g_getenv ("FP_TOD_DRIVERS_DIR");
+
+  g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,
+                         "*Impossible to load the shared drivers dir Error "
+                         "opening directory*__HOPEFULLY_AN_INVALID_PATH*");
+  g_setenv ("FP_TOD_DRIVERS_DIR", "__HOPEFULLY_AN_INVALID_PATH", TRUE);
+  context = fp_context_new ();
+  g_test_assert_expected_messages ();
+  devices = fp_context_get_devices (context);
+  g_setenv ("FP_TOD_DRIVERS_DIR", old_drivers_dir, TRUE);
+
+  g_assert_nonnull (devices);
+  g_assert_cmpuint (devices->len, ==, 0);
+}
+
+static void
+test_context_has_fake_device (void)
+{
+  g_autoptr(FpContext) context = NULL;
+  FpDevice *fake_device = NULL;
+  GPtrArray *devices;
+  const char *tod_name;
+  unsigned int i;
+
+  context = fp_context_new ();
+  devices = fp_context_get_devices (context);
+  tod_name = g_getenv ("FP_TOD_TEST_DRIVER_NAME");
+
+  g_assert_nonnull (devices);
+  g_assert_cmpuint (devices->len, ==, 1);
+
+  for (i = 0; i < devices->len; ++i)
+    {
+      FpDevice *device = devices->pdata[i];
+
+      if (g_strcmp0 (fp_device_get_driver (device), tod_name) == 0)
+        {
+          fake_device = device;
+          break;
+        }
+    }
+
+  g_assert_true (FP_IS_DEVICE (fake_device));
+}
+
+static void
+test_context_enumerates_new_devices (void)
+{
+  g_autoptr(FpContext) context = NULL;
+  GPtrArray *devices;
+
+  context = fp_context_new ();
+
+  fp_context_enumerate (context);
+  devices = fp_context_get_devices (context);
+
+  g_assert_nonnull (devices);
+  g_assert_cmpuint (devices->len, ==, 1);
+}
+
+int
+main (int argc, char *argv[])
+{
+  g_test_init (&argc, &argv, NULL);
+
+  g_assert_nonnull (g_getenv ("FP_TOD_DRIVERS_DIR"));
+
+  g_test_add_func ("/context/new", test_context_new);
+  g_test_add_func ("/context/no-devices", test_context_has_no_devices);
+  g_test_add_func ("/context/has-virtual-device", test_context_has_fake_device);
+  g_test_add_func ("/context/enumerates-new-devices", test_context_enumerates_new_devices);
+
+  return g_test_run ();
+}
diff --git a/tests/test-fp-device-tod.c b/tests/test-fp-device-tod.c
new file mode 100644
index 0000000..f3d45cb
--- /dev/null
+++ b/tests/test-fp-device-tod.c
@@ -0,0 +1,249 @@
+/*
+ * FpDevice Unit tests
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <libfprint/fprint.h>
+
+#include "test-utils-tod.h"
+
+static void
+on_device_opened (FpDevice *dev, GAsyncResult *res, FptContext *tctx)
+{
+  g_autoptr(GError) error = NULL;
+
+  g_assert_true (fp_device_open_finish (dev, res, &error));
+  g_assert_no_error (error);
+  g_assert_true (fp_device_is_open (tctx->device));
+
+  tctx->user_data = GUINT_TO_POINTER (TRUE);
+}
+
+static void
+test_device_open_async (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open (tctx->device, NULL, (GAsyncReadyCallback) on_device_opened, tctx);
+
+  while (!GPOINTER_TO_UINT (tctx->user_data))
+    g_main_context_iteration (NULL, TRUE);
+}
+
+static void
+on_device_closed (FpDevice *dev, GAsyncResult *res, FptContext *tctx)
+{
+  g_autoptr(GError) error = NULL;
+
+  g_assert_true (fp_device_close_finish (dev, res, &error));
+  g_assert_no_error (error);
+  g_assert_false (fp_device_is_open (tctx->device));
+
+  tctx->user_data = GUINT_TO_POINTER (TRUE);
+}
+
+static void
+test_device_close_async (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open (tctx->device, NULL, (GAsyncReadyCallback) on_device_opened, tctx);
+  while (!tctx->user_data)
+    g_main_context_iteration (NULL, TRUE);
+
+  tctx->user_data = GUINT_TO_POINTER (FALSE);
+  fp_device_close (tctx->device, NULL, (GAsyncReadyCallback) on_device_closed, tctx);
+
+  while (!GPOINTER_TO_UINT (tctx->user_data))
+    g_main_context_iteration (NULL, TRUE);
+}
+
+static void
+test_device_open_sync (void)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, &error);
+  g_assert_no_error (error);
+  g_assert_true (fp_device_is_open (tctx->device));
+
+  fp_device_open_sync (tctx->device, NULL, &error);
+  g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_ALREADY_OPEN);
+}
+
+static void
+on_open_notify (FpDevice *rdev, GParamSpec *spec, FptContext *tctx)
+{
+  g_assert_cmpstr (spec->name, ==, "open");
+  tctx->user_data = GUINT_TO_POINTER (TRUE);
+}
+
+static void
+test_device_open_sync_notify (void)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  g_signal_connect (tctx->device, "notify::open", G_CALLBACK (on_open_notify), tctx);
+  g_assert_true (fp_device_open_sync (tctx->device, NULL, &error));
+  g_assert_no_error (error);
+  g_assert_true (GPOINTER_TO_INT (tctx->user_data));
+}
+
+static void
+test_device_close_sync (void)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  fp_device_close_sync (tctx->device, NULL, &error);
+  g_assert_no_error (error);
+  g_assert_false (fp_device_is_open (tctx->device));
+
+  fp_device_close_sync (tctx->device, NULL, &error);
+  g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_NOT_OPEN);
+}
+
+static void
+on_close_notify (FpDevice *rdev, GParamSpec *spec, FptContext *tctx)
+{
+  g_assert_cmpstr (spec->name, ==, "open");
+  tctx->user_data = GUINT_TO_POINTER (TRUE);
+}
+
+static void
+test_device_close_sync_notify (void)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+
+  g_signal_connect (tctx->device, "notify::open", G_CALLBACK (on_close_notify), tctx);
+  fp_device_close_sync (tctx->device, NULL, &error);
+  g_assert_no_error (error);
+  g_assert_true (GPOINTER_TO_INT (tctx->user_data));
+}
+
+static void
+test_device_get_driver (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpstr (fp_device_get_driver (tctx->device), ==, g_getenv ("FP_TOD_TEST_DRIVER_NAME"));
+}
+
+static void
+test_device_get_device_id (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpstr (fp_device_get_device_id (tctx->device), ==, g_getenv ("FP_TOD_TEST_DRIVER_NAME"));
+}
+
+static void
+test_device_get_name (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpstr (fp_device_get_name (tctx->device), ==,
+                   "Virtual device for debugging");
+}
+
+static void
+test_device_get_scan_type (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpint (fp_device_get_scan_type (tctx->device), ==, FP_SCAN_TYPE_PRESS);
+}
+
+static void
+test_device_get_nr_enroll_stages (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpuint (fp_device_get_nr_enroll_stages (tctx->device), ==, 5);
+}
+
+static void
+test_device_supports_identify (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_true (fp_device_has_feature (tctx->device, FP_DEVICE_FEATURE_IDENTIFY));
+  G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+    g_assert_true (fp_device_supports_identify (tctx->device));
+  G_GNUC_END_IGNORE_DEPRECATIONS
+}
+
+static void
+test_device_supports_capture (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_true (fp_device_has_feature (tctx->device, FP_DEVICE_FEATURE_CAPTURE));
+  G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+    g_assert_true (fp_device_supports_capture (tctx->device));
+  G_GNUC_END_IGNORE_DEPRECATIONS
+}
+
+static void
+test_device_has_storage (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_true (fp_device_has_feature (tctx->device, FP_DEVICE_FEATURE_STORAGE));
+  G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+    g_assert_true (fp_device_has_storage (tctx->device));
+  G_GNUC_END_IGNORE_DEPRECATIONS
+}
+
+int
+main (int argc, char *argv[])
+{
+  g_test_init (&argc, &argv, NULL);
+
+  g_assert_nonnull (g_getenv ("FP_TOD_DRIVERS_DIR"));
+
+  g_test_add_func ("/device/async/open", test_device_open_async);
+  g_test_add_func ("/device/async/close", test_device_close_async);
+  g_test_add_func ("/device/sync/open", test_device_open_sync);
+  g_test_add_func ("/device/sync/open/notify", test_device_open_sync_notify);
+  g_test_add_func ("/device/sync/close", test_device_close_sync);
+  g_test_add_func ("/device/sync/close/notify", test_device_close_sync_notify);
+  g_test_add_func ("/device/sync/get_driver", test_device_get_driver);
+  g_test_add_func ("/device/sync/get_device_id", test_device_get_device_id);
+  g_test_add_func ("/device/sync/get_name", test_device_get_name);
+  g_test_add_func ("/device/sync/get_scan_type", test_device_get_scan_type);
+  g_test_add_func ("/device/sync/get_nr_enroll_stages", test_device_get_nr_enroll_stages);
+  g_test_add_func ("/device/sync/supports_identify", test_device_supports_identify);
+  g_test_add_func ("/device/sync/supports_capture", test_device_supports_capture);
+  g_test_add_func ("/device/sync/has_storage", test_device_has_storage);
+
+  return g_test_run ();
+}
diff --git a/tests/test-fp-todv1-types.c b/tests/test-fp-todv1-types.c
new file mode 100644
index 0000000..830cee7
--- /dev/null
+++ b/tests/test-fp-todv1-types.c
@@ -0,0 +1,343 @@
+/*
+ * FpDevice Unit tests
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <libfprint/fprint.h>
+
+#include "drivers_api.h"
+#include "fp-todv1-enums.h"
+
+#include "tod-drivers/base-fp-device.h"
+#include "tod-drivers/base-fp-print.h"
+#include "tod-drivers/base-fpi-device.h"
+#include "tod-drivers/base-fpi-image.h"
+#include "tod-drivers/base-fpi-image-device.h"
+#include "tod-drivers/base-fpi-spi.h"
+#include "tod-drivers/base-fpi-usb.h"
+
+static void
+check_enum_compatibility (GType old_type, GType current_type)
+{
+  g_autoptr(GEnumClass) old_class = g_type_class_ref (old_type);
+  g_autoptr(GEnumClass) current_class = g_type_class_ref (current_type);
+  int i;
+
+  g_debug ("Checking Enum %s vs %s",
+           g_type_name (current_type),
+           g_type_name (old_type));
+
+  g_assert_true (G_TYPE_IS_ENUM (old_type));
+  g_assert_true (G_TYPE_IS_ENUM (current_type));
+  g_assert_cmpuint (old_class->n_values, <=, current_class->n_values);
+
+  for (i = old_class->minimum; i <= old_class->maximum; i++)
+    {
+      GEnumValue *old_value = g_enum_get_value (old_class, i);
+      GEnumValue *current_value;
+
+      if (!old_value)
+        continue;
+
+      current_value = g_enum_get_value_by_nick (current_class,
+                                                old_value->value_nick);
+
+      g_debug (" .. %s (%d)", old_value->value_nick, old_value->value);
+      g_assert_nonnull (current_value);
+      g_assert_cmpuint (old_value->value, ==, current_value->value);
+    }
+}
+
+static void
+check_flags_compatibility (GType old_type, GType current_type)
+{
+  g_autoptr(GFlagsClass) old_class = g_type_class_ref (old_type);
+  g_autoptr(GFlagsClass) current_class = g_type_class_ref (current_type);
+  int i;
+
+  g_debug ("Checking Flags %s vs %s",
+           g_type_name (current_type),
+           g_type_name (old_type));
+
+  g_assert_true (G_TYPE_IS_FLAGS (old_type));
+  g_assert_true (G_TYPE_IS_FLAGS (current_type));
+  g_assert_cmpuint (old_class->n_values, <=, current_class->n_values);
+
+  for (i = 0; i < old_class->n_values; ++i)
+    {
+      GFlagsValue *old_value = &old_class->values[i];
+      GFlagsValue *current_value = g_flags_get_value_by_nick (current_class,
+                                                              old_value->value_nick);
+
+      g_debug (" .. %s (%d)", old_value->value_nick, old_value->value);
+      g_assert_nonnull (current_value);
+      g_assert_cmpuint (old_value->value, ==, current_value->value);
+    }
+}
+
+static void
+check_compatiblity_auto (GType old_type, GType current_type)
+{
+  if (G_TYPE_IS_ENUM (old_type))
+    return check_enum_compatibility (old_type, current_type);
+
+  if (G_TYPE_IS_FLAGS (old_type))
+    return check_flags_compatibility (old_type, current_type);
+
+  g_assert_not_reached ();
+}
+
+#define check_type_compatibility(type, major, minor, micro) \
+  g_debug ("Checking " # type " @ " G_STRLOC); \
+  check_compatiblity_auto (type ## _TOD_V ## major ## _ ## minor ## _ ## micro, type);
+
+#define tod_versioned_type(type, major, minor, micro) \
+  type ## TODV ## major ## _ ## minor ## _ ## micro
+
+#define check_struct_size(type, major, minor, micro) \
+  g_debug ("Checking " # type " v" #major "." #minor "." #micro " size  @ " G_STRLOC); \
+  g_assert_cmpuint (sizeof (tod_versioned_type (type, major, minor, micro)), \
+                    ==, \
+                    sizeof (type))
+
+#define check_struct_member(type, major, minor, micro, member) \
+  g_debug ("Checking " # type " v" #major "." #minor "." #micro "'s " # member " offset @ " G_STRLOC); \
+  g_assert_cmpuint (G_STRUCT_OFFSET (tod_versioned_type (type, major, minor, micro), member), \
+                    ==, \
+                    G_STRUCT_OFFSET (type, member))
+
+static void
+test_device_type (void)
+{
+  check_struct_size (FpIdEntry, 1, 90, 1);
+  check_struct_size (FpIdEntry, 1, 92, 0);
+  check_struct_size (FpDeviceClass, 1, 90, 1);
+  check_struct_size (FpDeviceClass, 1, 92, 0);
+  check_struct_size (FpDeviceClass, 1, 94, 0);
+
+  check_struct_member (FpIdEntry, 1, 90, 1, virtual_envvar);
+  check_struct_member (FpIdEntry, 1, 90, 1, driver_data);
+
+  check_struct_member (FpDeviceClass, 1, 90, 1, id);
+  check_struct_member (FpDeviceClass, 1, 90, 1, full_name);
+  check_struct_member (FpDeviceClass, 1, 90, 1, type);
+  check_struct_member (FpDeviceClass, 1, 90, 1, id_table);
+
+  check_struct_member (FpDeviceClass, 1, 90, 1, nr_enroll_stages);
+  check_struct_member (FpDeviceClass, 1, 90, 1, scan_type);
+
+  check_struct_member (FpDeviceClass, 1, 90, 1, usb_discover);
+  check_struct_member (FpDeviceClass, 1, 90, 1, probe);
+  check_struct_member (FpDeviceClass, 1, 90, 1, open);
+  check_struct_member (FpDeviceClass, 1, 90, 1, close);
+  check_struct_member (FpDeviceClass, 1, 90, 1, enroll);
+  check_struct_member (FpDeviceClass, 1, 90, 1, verify);
+  check_struct_member (FpDeviceClass, 1, 90, 1, identify);
+  check_struct_member (FpDeviceClass, 1, 90, 1, capture);
+  check_struct_member (FpDeviceClass, 1, 90, 1, list);
+  check_struct_member (FpDeviceClass, 1, 90, 1, delete);
+  check_struct_member (FpDeviceClass, 1, 90, 1, cancel);
+
+  /* Version 1.92 */
+  check_struct_member (FpIdEntry, 1, 92, 0, virtual_envvar);
+  check_struct_member (FpIdEntry, 1, 92, 0, driver_data);
+  check_struct_member (FpIdEntry, 1, 92, 0, udev_types);
+  check_struct_member (FpIdEntry, 1, 92, 0, spi_acpi_id);
+  check_struct_member (FpIdEntry, 1, 92, 0, hid_id);
+
+  check_struct_member (FpDeviceClass, 1, 92, 0, usb_discover);
+  check_struct_member (FpDeviceClass, 1, 92, 0, probe);
+  check_struct_member (FpDeviceClass, 1, 92, 0, open);
+  check_struct_member (FpDeviceClass, 1, 92, 0, close);
+  check_struct_member (FpDeviceClass, 1, 92, 0, enroll);
+  check_struct_member (FpDeviceClass, 1, 92, 0, verify);
+  check_struct_member (FpDeviceClass, 1, 92, 0, identify);
+  check_struct_member (FpDeviceClass, 1, 92, 0, capture);
+  check_struct_member (FpDeviceClass, 1, 92, 0, list);
+  check_struct_member (FpDeviceClass, 1, 92, 0, delete);
+  check_struct_member (FpDeviceClass, 1, 92, 0, cancel);
+
+  check_struct_member (FpDeviceClass, 1, 92, 0, id);
+  check_struct_member (FpDeviceClass, 1, 92, 0, full_name);
+  check_struct_member (FpDeviceClass, 1, 92, 0, type);
+  check_struct_member (FpDeviceClass, 1, 92, 0, id_table);
+
+  check_struct_member (FpDeviceClass, 1, 92, 0, nr_enroll_stages);
+  check_struct_member (FpDeviceClass, 1, 92, 0, scan_type);
+
+  check_struct_member (FpDeviceClass, 1, 92, 0, features);
+
+  /* Version 1.94 */
+  check_struct_member (FpDeviceClass, 1, 94, 0, usb_discover);
+  check_struct_member (FpDeviceClass, 1, 94, 0, probe);
+  check_struct_member (FpDeviceClass, 1, 94, 0, open);
+  check_struct_member (FpDeviceClass, 1, 94, 0, close);
+  check_struct_member (FpDeviceClass, 1, 94, 0, enroll);
+  check_struct_member (FpDeviceClass, 1, 94, 0, verify);
+  check_struct_member (FpDeviceClass, 1, 94, 0, identify);
+  check_struct_member (FpDeviceClass, 1, 94, 0, capture);
+  check_struct_member (FpDeviceClass, 1, 94, 0, list);
+  check_struct_member (FpDeviceClass, 1, 94, 0, delete);
+  check_struct_member (FpDeviceClass, 1, 94, 0, cancel);
+  check_struct_member (FpDeviceClass, 1, 94, 0, clear_storage);
+  check_struct_member (FpDeviceClass, 1, 94, 0, suspend);
+  check_struct_member (FpDeviceClass, 1, 94, 0, resume);
+
+  check_struct_member (FpDeviceClass, 1, 94, 0, id);
+  check_struct_member (FpDeviceClass, 1, 94, 0, full_name);
+  check_struct_member (FpDeviceClass, 1, 94, 0, type);
+  check_struct_member (FpDeviceClass, 1, 94, 0, id_table);
+
+  check_struct_member (FpDeviceClass, 1, 94, 0, nr_enroll_stages);
+  check_struct_member (FpDeviceClass, 1, 94, 0, scan_type);
+
+  check_struct_member (FpDeviceClass, 1, 94, 0, features);
+
+  check_struct_member (FpDeviceClass, 1, 94, 0, temp_hot_seconds);
+  check_struct_member (FpDeviceClass, 1, 94, 0, temp_cold_seconds);
+}
+
+static void
+test_image_device_private (void)
+{
+  check_struct_size (FpImage, 1, 90, 1);
+  check_struct_size (FpImageDeviceClass, 1, 90, 1);
+
+  check_struct_member (FpImageDeviceClass, 1, 90, 1, bz3_threshold);
+  check_struct_member (FpImageDeviceClass, 1, 90, 1, img_width);
+  check_struct_member (FpImageDeviceClass, 1, 90, 1, img_height);
+  check_struct_member (FpImageDeviceClass, 1, 90, 1, img_open);
+  check_struct_member (FpImageDeviceClass, 1, 90, 1, img_close);
+  check_struct_member (FpImageDeviceClass, 1, 90, 1, activate);
+  check_struct_member (FpImageDeviceClass, 1, 90, 1, change_state);
+  check_struct_member (FpImageDeviceClass, 1, 90, 1, deactivate);
+}
+
+static void
+test_usb_private (void)
+{
+  check_struct_size (FpiUsbTransfer, 1, 90, 1);
+
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, device);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, ssm);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, length);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, actual_length);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, buffer);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, ref_count);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, type);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, endpoint);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, direction);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, request_type);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, recipient);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, request);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, value);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, idx);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, short_is_error);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, user_data);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, callback);
+  check_struct_member (FpiUsbTransfer, 1, 90, 1, free_buffer);
+}
+
+static void
+test_spi_private (void)
+{
+  check_struct_size (FpiSpiTransfer, 1, 92, 0);
+
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, device);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, ssm);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, length_wr);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, length_rd);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, buffer_wr);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, buffer_rd);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, ref_count);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, spidev_fd);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, user_data);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, callback);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, free_buffer_wr);
+  check_struct_member (FpiSpiTransfer, 1, 92, 0, free_buffer_rd);
+}
+
+static void
+test_device_public_enums (void)
+{
+  check_type_compatibility (FP_TYPE_DEVICE_TYPE, 1, 90, 1);
+  check_type_compatibility (FP_TYPE_SCAN_TYPE, 1, 90, 1);
+  check_type_compatibility (FP_TYPE_DEVICE_RETRY, 1, 90, 1);
+  check_type_compatibility (FP_TYPE_DEVICE_ERROR, 1, 90, 1);
+  check_type_compatibility (FP_TYPE_DEVICE_ERROR, 1, 90, 3);
+  check_type_compatibility (FP_TYPE_DEVICE_ERROR, 1, 90, 4);
+  check_type_compatibility (FP_TYPE_DEVICE_ERROR, 1, 94, 0);
+  check_type_compatibility (FP_TYPE_DEVICE_FEATURE, 1, 92, 0);
+  check_type_compatibility (FP_TYPE_DEVICE_FEATURE, 1, 94, 0);
+  check_type_compatibility (FP_TYPE_TEMPERATURE, 1, 94, 0);
+  check_type_compatibility (FPI_TYPE_DEVICE_UDEV_SUBTYPE_FLAGS, 1, 92, 0);
+}
+
+static void
+test_device_private_enums (void)
+{
+  check_type_compatibility (FPI_TYPE_DEVICE_ACTION, 1, 90, 1);
+  check_type_compatibility (FPI_TYPE_DEVICE_ACTION, 1, 92, 0);
+}
+
+static void
+test_print_public_enums (void)
+{
+  check_type_compatibility (FP_TYPE_FINGER, 1, 90, 1);
+  check_type_compatibility (FP_TYPE_FINGER_STATUS_FLAGS, 1, 90, 4);
+}
+
+static void
+test_print_private_enums (void)
+{
+  check_type_compatibility (FPI_TYPE_PRINT_TYPE, 1, 90, 1);
+  check_type_compatibility (FPI_TYPE_MATCH_RESULT, 1, 90, 1);
+}
+
+static void
+test_image_device_enums (void)
+{
+  check_type_compatibility (FPI_TYPE_IMAGE_FLAGS, 1, 90, 1);
+  check_type_compatibility (FPI_TYPE_IMAGE_FLAGS, 1, 90, 2);
+  check_type_compatibility (FPI_TYPE_IMAGE_DEVICE_STATE, 1, 90, 1);
+  check_type_compatibility (FPI_TYPE_IMAGE_DEVICE_STATE, 1, 90, 4);
+}
+
+static void
+test_usb_enums (void)
+{
+  check_type_compatibility (FPI_TYPE_TRANSFER_TYPE, 1, 90, 3);
+}
+
+int
+main (int argc, char *argv[])
+{
+  g_test_init (&argc, &argv, NULL);
+
+  g_test_add_func ("/type/device/private", test_device_type);
+  g_test_add_func ("/type/device/enums", test_device_public_enums);
+  g_test_add_func ("/type/device/private/enums", test_device_private_enums);
+  g_test_add_func ("/type/print/enums", test_print_public_enums);
+  g_test_add_func ("/type/print/private/enums", test_print_private_enums);
+  g_test_add_func ("/type/image-device/private", test_image_device_private);
+  g_test_add_func ("/type/image-device/enums", test_image_device_enums);
+  g_test_add_func ("/type/usb/private", test_usb_private);
+  g_test_add_func ("/type/usb/enums", test_usb_enums);
+  g_test_add_func ("/type/spi/private", test_spi_private);
+
+  return g_test_run ();
+}
diff --git a/tests/test-fpi-device.c b/tests/test-fpi-device.c
index 408e2f9..6e2021c 100644
--- a/tests/test-fpi-device.c
+++ b/tests/test-fpi-device.c
@@ -28,6 +28,120 @@
 #include "fpi-log.h"
 #include "test-device-fake.h"
 
+#ifdef TEST_TOD_DRIVER
+
+#include "test-utils-tod.h"
+
+#undef FPI_TYPE_DEVICE_FAKE
+#define FPI_TYPE_DEVICE_FAKE (fpt_context_device_driver_get_type ())
+
+#undef FPI_DEVICE_FAKE
+#define FPI_DEVICE_FAKE(dev) (G_TYPE_CHECK_INSTANCE_CAST ((dev), FPI_TYPE_DEVICE_FAKE, FpiDeviceFake))
+
+static GType
+fpt_context_device_driver_get_type (void)
+{
+  FptContext *tctx = fpt_context_fake_dev_default ();
+
+  return G_TYPE_FROM_CLASS (FP_DEVICE_GET_CLASS (tctx->device));
+}
+
+static int
+tod_get_version (FpDeviceClass *device_class,
+                 const char   **sub_version)
+{
+  g_autofree char *tod_version = NULL;
+  const char *tod_version_info;
+  const char *tod_subversion_info;
+
+  g_debug ("Getting TOD version for driver '%s'", device_class->id);
+  g_assert_true (g_str_has_prefix (device_class->id, "fake_test_dev_tod"));
+
+  tod_version_info = device_class->id + sizeof ("fake_test_dev_tod");
+  g_debug ("Tod version info is '%s'", tod_version_info);
+  g_assert (*tod_version_info != '\0');
+
+  if (sub_version)
+    *sub_version = NULL;
+
+  if (g_str_equal (tod_version_info, "current"))
+    {
+      *sub_version = TOD_CURRENT_SUBVERSION;
+      return TOD_CURRENT_VERSION;
+    }
+
+  g_assert_true (g_str_has_prefix (device_class->id, "fake_test_dev_tod_v"));
+
+  tod_version_info = device_class->id + sizeof ("fake_test_dev_tod_v") - 1;
+  tod_subversion_info = strchr (tod_version_info, '+');
+  g_assert_nonnull (tod_subversion_info);
+  g_assert (*tod_subversion_info != '\0');
+
+  tod_version = g_strndup (tod_version_info,
+                           tod_subversion_info - tod_version_info);
+  tod_subversion_info += 1;
+
+  g_debug ("Tod version is '%s', subversion '%s'",
+           tod_version, tod_subversion_info);
+
+  g_assert_nonnull (tod_version);
+  g_assert (*tod_version != '\0');
+  g_assert (*tod_subversion_info != '\0');
+
+  if (sub_version)
+    *sub_version = tod_subversion_info;
+
+  return atoi (tod_version);
+}
+
+#endif
+
+static gboolean
+tod_check_version (FpDeviceClass *device_class,
+                   int            tod_version,
+                   const char    *tod_subversion)
+{
+#ifdef TEST_TOD_DRIVER
+  g_auto(GStrv) versions = NULL;
+  g_auto(GStrv) wanted_versions = NULL;
+  int version;
+  const char *sub_version;
+
+  version = tod_get_version (device_class, &sub_version);
+
+  if (version != tod_version)
+    return FALSE;
+
+  if (!tod_subversion)
+    return TRUE;
+
+  versions = g_strsplit (sub_version, ".", -1);
+  g_assert_cmpuint (g_strv_length (versions), ==, 3);
+
+  wanted_versions = g_strsplit (tod_subversion, ".", -1);
+  g_assert_cmpuint (g_strv_length (wanted_versions), ==, 3);
+
+  if (atoi (versions[0]) >= atoi (wanted_versions[0]) &&
+      atoi (versions[1]) > atoi (wanted_versions[1]))
+    return TRUE;
+
+  return atoi (versions[0]) == atoi (wanted_versions[0]) &&
+         atoi (versions[1]) == atoi (wanted_versions[1]) &&
+         atoi (versions[2]) >= atoi (wanted_versions[2]);
+#endif
+  return TRUE;
+}
+
+static gboolean
+tod_check_device_version (FpDevice   *device_class,
+                          int         tod_version,
+                          const char *tod_subversion)
+{
+  return tod_check_version (FP_DEVICE_GET_CLASS (device_class),
+                            tod_version,
+                            tod_subversion);
+}
+
 /* Utility functions */
 
 typedef FpDevice FpAutoCloseDevice;
@@ -519,6 +633,12 @@ test_driver_features_probe_updates (void)
   FpDeviceClass *dev_class = FP_DEVICE_GET_CLASS (device);
   FpiDeviceFake *fake_dev;
 
+  if (!tod_check_device_version (device, 1, "1.92.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.92.0");
+      return;
+    }
+
   g_assert_cmpuint (dev_class->features, !=, FP_DEVICE_FEATURE_NONE);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_CAPTURE);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_IDENTIFY);
@@ -572,7 +692,10 @@ test_driver_initial_features (void)
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_LIST);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_DELETE);
-  g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  if (tod_check_device_version (device, 1, "1.92.0"))
+    g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  else
+    g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
 
   g_async_initable_init_async (G_ASYNC_INITABLE (device),
                                G_PRIORITY_DEFAULT, NULL, NULL, NULL);
@@ -586,7 +709,10 @@ test_driver_initial_features (void)
   g_assert_true (fp_device_has_feature (device, FP_DEVICE_FEATURE_STORAGE));
   g_assert_true (fp_device_has_feature (device, FP_DEVICE_FEATURE_STORAGE_LIST));
   g_assert_true (fp_device_has_feature (device, FP_DEVICE_FEATURE_STORAGE_DELETE));
-  g_assert_true (fp_device_has_feature (device, FP_DEVICE_FEATURE_STORAGE_CLEAR));
+  if (tod_check_device_version (device, 1, "1.92.0"))
+    g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  else
+    g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
 
   g_assert_cmpuint (fp_device_get_features (device),
                     ==,
@@ -596,7 +722,8 @@ test_driver_initial_features (void)
                     FP_DEVICE_FEATURE_STORAGE |
                     FP_DEVICE_FEATURE_STORAGE_LIST |
                     FP_DEVICE_FEATURE_STORAGE_DELETE |
-                    FP_DEVICE_FEATURE_STORAGE_CLEAR);
+                    (tod_check_device_version (device, 1, "1.92.0") ?
+                     FP_DEVICE_FEATURE_STORAGE_CLEAR : 0));
 }
 
 static void
@@ -643,7 +770,10 @@ test_driver_initial_features_no_capture (void)
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_LIST);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_DELETE);
-  g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  if (tod_check_version (dev_class, 1, "1.92.0"))
+    g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  else
+    g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
 }
 
 static void
@@ -664,7 +794,10 @@ test_driver_initial_features_no_verify (void)
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_LIST);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_DELETE);
-  g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  if (tod_check_version (dev_class, 1, "1.92.0"))
+    g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  else
+    g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
 }
 
 static void
@@ -685,7 +818,10 @@ test_driver_initial_features_no_identify (void)
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_LIST);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_DELETE);
-  g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  if (tod_check_version (dev_class, 1, "1.92.0"))
+    g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  else
+    g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
 }
 
 static void
@@ -706,7 +842,10 @@ test_driver_initial_features_no_storage (void)
   g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_LIST);
   g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_DELETE);
-  g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  if (tod_check_version (dev_class, 1, "1.92.0"))
+    g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  else
+    g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
 }
 
 static void
@@ -724,10 +863,16 @@ test_driver_initial_features_no_list (void)
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_IDENTIFY);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_VERIFY);
   g_assert_false (dev_class->features & FP_DEVICE_FEATURE_DUPLICATES_CHECK);
-  g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE);
+  if (tod_check_version (dev_class, 1, "1.92.0"))
+    g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE);
+  else
+    g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE);
   g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_LIST);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_DELETE);
-  g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  if (tod_check_version (dev_class, 1, "1.92.0"))
+    g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  else
+    g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
 }
 
 static void
@@ -748,7 +893,10 @@ test_driver_initial_features_no_delete (void)
   g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE);
   g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_LIST);
   g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_DELETE);
-  g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  if (tod_check_version (dev_class, 1, "1.92.0"))
+    g_assert_true (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
+  else
+    g_assert_false (dev_class->features & FP_DEVICE_FEATURE_STORAGE_CLEAR);
 }
 
 static void
@@ -1985,6 +2133,12 @@ test_driver_identify_suspend_continues (void)
   FpiDeviceFake *fake_dev;
   FpPrint *expected_matched;
 
+  if (!tod_check_version (dev_class, 1, "1.94.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.94.0");
+      return;
+    }
+
   device = g_object_new (FPI_TYPE_DEVICE_FAKE, NULL);
   fake_dev = FPI_DEVICE_FAKE (device);
   orig_identify = dev_class->identify;
@@ -2051,6 +2205,12 @@ test_driver_identify_suspend_succeeds (void)
   FpiDeviceFake *fake_dev;
   FpPrint *expected_matched;
 
+  if (!tod_check_version (dev_class, 1, "1.94.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.94.0");
+      return;
+    }
+
   device = g_object_new (FPI_TYPE_DEVICE_FAKE, NULL);
   fake_dev = FPI_DEVICE_FAKE (device);
   orig_identify = dev_class->identify;
@@ -2113,6 +2273,12 @@ test_driver_identify_suspend_busy_error (void)
   FpiDeviceFake *fake_dev;
   FpPrint *expected_matched;
 
+  if (!tod_check_version (dev_class, 1, "1.94.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.94.0");
+      return;
+    }
+
   device = g_object_new (FPI_TYPE_DEVICE_FAKE, NULL);
   fake_dev = FPI_DEVICE_FAKE (device);
   orig_identify = dev_class->identify;
@@ -2170,6 +2336,12 @@ test_driver_identify_suspend_while_idle (void)
   g_autoptr(GError) error = NULL;
   FpiDeviceFake *fake_dev;
 
+  if (!tod_check_version (dev_class, 1, "1.94.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.94.0");
+      return;
+    }
+
   device = g_object_new (FPI_TYPE_DEVICE_FAKE, NULL);
   fake_dev = FPI_DEVICE_FAKE (device);
 
@@ -2214,6 +2386,12 @@ test_driver_identify_warmup_cooldown (void)
   FpiDeviceFake *fake_dev;
   gint64 start_time;
 
+  if (!tod_check_version (dev_class, 1, "1.94.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.94.0");
+      return;
+    }
+
   dev_class->temp_hot_seconds = 2;
   dev_class->temp_cold_seconds = 5;
 
@@ -2512,6 +2690,12 @@ test_driver_clear_storage (void)
   FpiDeviceFake *fake_dev = FPI_DEVICE_FAKE (device);
   gboolean ret;
 
+  if (!tod_check_device_version (device, 1, "1.92.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.92.0");
+      return;
+    }
+
   ret = fp_device_clear_storage_sync (device, NULL, &error);
   g_assert (fake_dev->last_called_function == dev_class->clear_storage);
   g_assert_no_error (error);
@@ -2527,6 +2711,12 @@ test_driver_clear_storage_error (void)
   FpiDeviceFake *fake_dev = FPI_DEVICE_FAKE (device);
   gboolean ret;
 
+  if (!tod_check_device_version (device, 1, "1.92.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.92.0");
+      return;
+    }
+
   fake_dev->ret_error = fpi_device_error_new (FP_DEVICE_ERROR_GENERAL);
   ret = fp_device_clear_storage_sync (device, NULL, &error);
   g_assert (fake_dev->last_called_function == dev_class->clear_storage);
@@ -2633,6 +2823,12 @@ test_driver_critical (void)
   void (*orig_verify) (FpDevice *device) = dev_class->verify;
   FpiDeviceFake *fake_dev = FPI_DEVICE_FAKE (device);
 
+  if (!tod_check_device_version (device, 1, "1.94.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.94.0");
+      return;
+    }
+
   fake_dev->last_called_function = NULL;
 
   dev_class->verify = fake_device_stub_verify;
@@ -2841,6 +3037,12 @@ test_driver_action_is_cancelled_open (void)
   g_autoptr(GError) error = NULL;
   FpiDeviceFake *fake_dev;
 
+  if (!tod_check_version (dev_class, 1, "1.94.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.94.0");
+      return;
+    }
+
   dev_class->open = test_driver_action_is_cancelled_open_vfunc;
   device = g_object_new (FPI_TYPE_DEVICE_FAKE, NULL);
   fake_dev = FPI_DEVICE_FAKE (device);
@@ -2861,6 +3063,12 @@ test_driver_action_internally_cancelled_open (void)
   g_autoptr(GError) error = NULL;
   FpiDeviceFake *fake_dev;
 
+  if (!tod_check_version (dev_class, 1, "1.94.0"))
+    {
+      g_test_skip ("Feature not supported by TODv1 versions before 1.94.0");
+      return;
+    }
+
   dev_class->open = test_driver_action_is_cancelled_open_vfunc;
   device = g_object_new (FPI_TYPE_DEVICE_FAKE, NULL);
   fake_dev = FPI_DEVICE_FAKE (device);
@@ -3010,11 +3218,20 @@ test_driver_action_error_all (void)
   g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_DATA_INVALID);
   g_clear_error (&error);
 
-  fake_dev->ret_error = fpi_device_error_new (FP_DEVICE_ERROR_DATA_INVALID);
-  g_assert_false (fp_device_clear_storage_sync (device, NULL, &error));
-  g_assert_true (fake_dev->last_called_function == dev_class->clear_storage);
-  g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_DATA_INVALID);
-  g_clear_error (&error);
+  if (tod_check_device_version (device, 1, "1.92.0"))
+    {
+      fake_dev->ret_error = fpi_device_error_new (FP_DEVICE_ERROR_DATA_INVALID);
+      g_assert_false (fp_device_clear_storage_sync (device, NULL, &error));
+      g_assert_true (fake_dev->last_called_function == dev_class->clear_storage);
+      g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_DATA_INVALID);
+      g_clear_error (&error);
+    }
+  else
+    {
+      g_assert_false (fp_device_clear_storage_sync (device, NULL, &error));
+      g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_NOT_SUPPORTED);
+      g_clear_error (&error);
+    }
 
   /* Test close last, as we can't operate on a closed device. */
   fake_dev->ret_error = fpi_device_error_new (FP_DEVICE_ERROR_DATA_INVALID);
@@ -3115,15 +3332,18 @@ test_driver_action_error_fallback_all (void)
   g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_GENERAL);
   g_clear_error (&error);
 
-  g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
-                         "*Device failed to pass an error to generic action "
-                         "error function*");
-
-  g_assert_false (fp_device_clear_storage_sync (device, NULL, &error));
-  g_test_assert_expected_messages ();
-  g_assert_true (fake_dev->last_called_function == dev_class->clear_storage);
-  g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_GENERAL);
-  g_clear_error (&error);
+  if (tod_check_device_version (device, 1, "1.92.0"))
+    {
+      g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
+                             "*Device failed to pass an error to generic action "
+                             "error function*");
+
+      g_assert_false (fp_device_clear_storage_sync (device, NULL, &error));
+      g_test_assert_expected_messages ();
+      g_assert_true (fake_dev->last_called_function == dev_class->clear_storage);
+      g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_GENERAL);
+      g_clear_error (&error);
+    }
 
   /* Test close last, as we can't operate on a closed device. */
   g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
@@ -3258,6 +3478,10 @@ test_driver_retry_error_types (void)
 int
 main (int argc, char *argv[])
 {
+#ifdef TEST_TOD_DRIVER
+  g_autoptr(FptContext) tctx = fpt_context_fake_dev_default ();
+#endif
+
   g_test_init (&argc, &argv, NULL);
 
   g_test_add_func ("/driver/get_driver", test_driver_get_driver);
diff --git a/tests/test-utils-tod.c b/tests/test-utils-tod.c
new file mode 100644
index 0000000..cf606fc
--- /dev/null
+++ b/tests/test-utils-tod.c
@@ -0,0 +1,67 @@
+/*
+ * Unit tests for libfprint
+ * Copyright (C) 2020 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <libfprint/fprint.h>
+
+#include "test-utils-tod.h"
+
+static FptContext *fake_context = NULL;
+
+FptContext *
+fpt_context_new_with_fake_dev (void)
+{
+  FptContext *tctx;
+  GPtrArray *devices;
+  const char *tod_name;
+  unsigned int i;
+
+  tctx = fpt_context_new ();
+  devices = fp_context_get_devices (tctx->fp_context);
+  tod_name = g_getenv ("FP_TOD_TEST_DRIVER_NAME");
+
+  g_assert_nonnull (tod_name);
+  g_assert_nonnull (devices);
+  g_assert_cmpuint (devices->len, ==, 1);
+
+  for (i = 0; i < devices->len; ++i)
+    {
+      FpDevice *device = devices->pdata[i];
+
+      if (g_strcmp0 (fp_device_get_driver (device), tod_name) == 0)
+        {
+          tctx->device = device;
+          break;
+        }
+    }
+
+  g_assert_true (FP_IS_DEVICE (tctx->device));
+  g_object_add_weak_pointer (G_OBJECT (tctx->device), (gpointer) & tctx->device);
+
+  return tctx;
+}
+
+FptContext *
+fpt_context_fake_dev_default (void)
+{
+  if (fake_context)
+    return fake_context;
+
+  fake_context = fpt_context_new_with_fake_dev ();
+  return fake_context;
+}
diff --git a/tests/test-utils-tod.h b/tests/test-utils-tod.h
new file mode 100644
index 0000000..b3d95a0
--- /dev/null
+++ b/tests/test-utils-tod.h
@@ -0,0 +1,25 @@
+/*
+ * Unit tests for libfprint
+ * Copyright (C) 2020 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <glib.h>
+#include "test-utils.h"
+
+FptContext * fpt_context_new_with_fake_dev (void);
+
+FptContext * fpt_context_fake_dev_default (void);
diff --git a/tests/tod-drivers/README.md b/tests/tod-drivers/README.md
new file mode 100644
index 0000000..a1b27de
--- /dev/null
+++ b/tests/tod-drivers/README.md
@@ -0,0 +1,13 @@
+# TOD drivers to use for testing
+
+This directory is used by the test-suite to load and verify pre-built drivers.
+
+For main testing this directory should contain the "fake_test_dev" driver (AKA
+test-device-fake) built using the minimum libfprint TOD we want to support.
+
+In this way the library is loaded during tests and tested for all the upstream
+tests and particularly test-fpi-device.
+
+Such binaries are compiled (for each platform) using the [libfprint TOD test
+drivers](https://gitlab.freedesktop.org/3v1n0/libfprint-tod-test-drivers)
+project, per each supported version.
diff --git a/tests/tod-drivers/base-fp-device.h b/tests/tod-drivers/base-fp-device.h
new file mode 100644
index 0000000..5d3bbc2
--- /dev/null
+++ b/tests/tod-drivers/base-fp-device.h
@@ -0,0 +1,109 @@
+/*
+ * FpDevice - A fingerprint reader device
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include "tod/tod-macros.h"
+
+typedef struct _FpDevice FpDevice;
+
+typedef enum {
+  FP_DEVICE_TYPE_TODV1_90_1_VIRTUAL,
+  FP_DEVICE_TYPE_TODV1_90_1_USB,
+} FpDeviceTypeTODV1_90_1;
+
+typedef enum {
+  FP_DEVICE_TYPE_TODV1_92_0_VIRTUAL,
+  FP_DEVICE_TYPE_TODV1_92_0_USB,
+  FP_DEVICE_TYPE_TODV1_92_0_UDEV,
+} FpDeviceTypeTODV1_92_0;
+
+typedef enum {
+  FP_SCAN_TYPE_TODV1_90_1_SWIPE,
+  FP_SCAN_TYPE_TODV1_90_1_PRESS,
+} FpScanTypeTODV1_90_1;
+
+typedef enum {
+  FP_DEVICE_RETRY_TODV1_90_1_GENERAL,
+  FP_DEVICE_RETRY_TODV1_90_1_TOO_SHORT,
+  FP_DEVICE_RETRY_TODV1_90_1_CENTER_FINGER,
+  FP_DEVICE_RETRY_TODV1_90_1_REMOVE_FINGER,
+} FpDeviceRetryTODV1_90_1;
+
+typedef enum {
+  FP_DEVICE_ERROR_TODV1_90_1_GENERAL,
+  FP_DEVICE_ERROR_TODV1_90_1_NOT_SUPPORTED,
+  FP_DEVICE_ERROR_TODV1_90_1_NOT_OPEN,
+  FP_DEVICE_ERROR_TODV1_90_1_ALREADY_OPEN,
+  FP_DEVICE_ERROR_TODV1_90_1_BUSY,
+  FP_DEVICE_ERROR_TODV1_90_1_PROTO,
+  FP_DEVICE_ERROR_TODV1_90_1_DATA_INVALID,
+  FP_DEVICE_ERROR_TODV1_90_1_DATA_NOT_FOUND,
+  FP_DEVICE_ERROR_TODV1_90_1_DATA_FULL,
+} FpDeviceErrorTODV1_90_1;
+
+typedef enum {
+  FP_DEVICE_ERROR_TODV1_90_3_GENERAL,
+  FP_DEVICE_ERROR_TODV1_90_3_NOT_SUPPORTED,
+  FP_DEVICE_ERROR_TODV1_90_3_NOT_OPEN,
+  FP_DEVICE_ERROR_TODV1_90_3_ALREADY_OPEN,
+  FP_DEVICE_ERROR_TODV1_90_3_BUSY,
+  FP_DEVICE_ERROR_TODV1_90_3_PROTO,
+  FP_DEVICE_ERROR_TODV1_90_3_DATA_INVALID,
+  FP_DEVICE_ERROR_TODV1_90_3_DATA_NOT_FOUND,
+  FP_DEVICE_ERROR_TODV1_90_3_DATA_FULL,
+  FP_DEVICE_ERROR_TODV1_90_3_DATA_DUPLICATE,
+} FpDeviceErrorTODV1_90_3;
+
+typedef enum {
+  FP_DEVICE_ERROR_TODV1_90_4_GENERAL,
+  FP_DEVICE_ERROR_TODV1_90_4_NOT_SUPPORTED,
+  FP_DEVICE_ERROR_TODV1_90_4_NOT_OPEN,
+  FP_DEVICE_ERROR_TODV1_90_4_ALREADY_OPEN,
+  FP_DEVICE_ERROR_TODV1_90_4_BUSY,
+  FP_DEVICE_ERROR_TODV1_90_4_PROTO,
+  FP_DEVICE_ERROR_TODV1_90_4_DATA_INVALID,
+  FP_DEVICE_ERROR_TODV1_90_4_DATA_NOT_FOUND,
+  FP_DEVICE_ERROR_TODV1_90_4_DATA_FULL,
+  FP_DEVICE_ERROR_TODV1_90_4_DATA_DUPLICATE,
+  /* Leave some room to add more DATA related errors */
+  FP_DEVICE_ERROR_TODV1_90_4_REMOVED = 0x100,
+} FpDeviceErrorTODV1_90_4;
+
+typedef enum {
+  FP_DEVICE_ERROR_TODV1_94_0_GENERAL,
+  FP_DEVICE_ERROR_TODV1_94_0_NOT_SUPPORTED,
+  FP_DEVICE_ERROR_TODV1_94_0_NOT_OPEN,
+  FP_DEVICE_ERROR_TODV1_94_0_ALREADY_OPEN,
+  FP_DEVICE_ERROR_TODV1_94_0_BUSY,
+  FP_DEVICE_ERROR_TODV1_94_0_PROTO,
+  FP_DEVICE_ERROR_TODV1_94_0_DATA_INVALID,
+  FP_DEVICE_ERROR_TODV1_94_0_DATA_NOT_FOUND,
+  FP_DEVICE_ERROR_TODV1_94_0_DATA_FULL,
+  FP_DEVICE_ERROR_TODV1_94_0_DATA_DUPLICATE,
+  /* Leave some room to add more DATA related errors */
+  FP_DEVICE_ERROR_TODV1_94_0_REMOVED = 0x100,
+  FP_DEVICE_ERROR_TODV1_94_0_TOO_HOT,
+} FpDeviceErrorTODV1_94_0;
+
+typedef enum {
+  FP_TEMPERATURE_TODV1_94_0_COLD,
+  FP_TEMPERATURE_TODV1_94_0_WARM,
+  FP_TEMPERATURE_TODV1_94_0_HOT,
+} FpTemperatureTODV1_94_0;
diff --git a/tests/tod-drivers/base-fp-print.h b/tests/tod-drivers/base-fp-print.h
new file mode 100644
index 0000000..403631a
--- /dev/null
+++ b/tests/tod-drivers/base-fp-print.h
@@ -0,0 +1,57 @@
+/*
+ * FpDevice - A fingerprint reader device
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+typedef enum {
+  FP_FINGER_TODV1_90_1_UNKNOWN = 0,
+  FP_FINGER_TODV1_90_1_LEFT_THUMB,
+  FP_FINGER_TODV1_90_1_LEFT_INDEX,
+  FP_FINGER_TODV1_90_1_LEFT_MIDDLE,
+  FP_FINGER_TODV1_90_1_LEFT_RING,
+  FP_FINGER_TODV1_90_1_LEFT_LITTLE,
+  FP_FINGER_TODV1_90_1_RIGHT_THUMB,
+  FP_FINGER_TODV1_90_1_RIGHT_INDEX,
+  FP_FINGER_TODV1_90_1_RIGHT_MIDDLE,
+  FP_FINGER_TODV1_90_1_RIGHT_RING,
+  FP_FINGER_TODV1_90_1_RIGHT_LITTLE,
+
+  FP_FINGER_TODV1_90_1_FIRST = FP_FINGER_TODV1_90_1_LEFT_THUMB,
+  FP_FINGER_TODV1_90_1_LAST = FP_FINGER_TODV1_90_1_RIGHT_LITTLE,
+} FpFingerTODV1_90_1;
+
+typedef enum {
+  FP_FINGER_STATUS_TODV1_90_4_NONE    = 0,
+  FP_FINGER_STATUS_TODV1_90_4_NEEDED  = 1 << 0,
+  FP_FINGER_STATUS_TODV1_90_4_PRESENT = 1 << 1,
+} FpFingerStatusFlagsTODV1_90_4;
+
+/* Private flags */
+
+typedef enum {
+  FPI_PRINT_TODV1_90_1_UNDEFINED = 0,
+  FPI_PRINT_TODV1_90_1_RAW,
+  FPI_PRINT_TODV1_90_1_NBIS,
+} FpiPrintTypeTODV1_90_1;
+
+typedef enum {
+  FPI_MATCH_TODV1_90_1_ERROR = -1,
+  FPI_MATCH_TODV1_90_1_FAIL,
+  FPI_MATCH_TODV1_90_1_SUCCESS,
+} FpiMatchResultTODV1_90_1;
diff --git a/tests/tod-drivers/base-fpi-device.h b/tests/tod-drivers/base-fpi-device.h
new file mode 100644
index 0000000..0e84761
--- /dev/null
+++ b/tests/tod-drivers/base-fpi-device.h
@@ -0,0 +1,271 @@
+/*
+ * FpDevice - A fingerprint reader device
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "base-fp-device.h"
+
+typedef struct _GUsbDevice          GUsbDevice;
+
+typedef struct _FpIdEntryTODV1_90_1 FpIdEntryTODV1_90_1;
+
+struct _FpIdEntryTODV1_90_1
+{
+  union
+  {
+    struct
+    {
+      guint pid;
+      guint vid;
+    };
+    const gchar *virtual_envvar;
+  };
+  guint64 driver_data;
+
+  /*< private >*/
+  /* padding for future expansion */
+  TOD_PADDING (16, 0);
+};
+
+struct _FpDeviceClassTODV1_90_1
+{
+  /*< private >*/
+  GObjectClass parent_class;
+
+  /*< public >*/
+  /* Static information about the driver. */
+  const gchar               *id;
+  const gchar               *full_name;
+  FpDeviceTypeTODV1_90_1     type;
+  const FpIdEntryTODV1_90_1 *id_table;
+
+  /* Defaults for device properties */
+  gint                 nr_enroll_stages;
+  FpScanTypeTODV1_90_1 scan_type;
+
+  /* Callbacks */
+  gint (*usb_discover) (GUsbDevice *usb_device);
+  void (*probe)    (FpDevice *device);
+  void (*open)     (FpDevice *device);
+  void (*close)    (FpDevice *device);
+  void (*enroll)   (FpDevice *device);
+  void (*verify)   (FpDevice *device);
+  void (*identify) (FpDevice *device);
+  void (*capture)  (FpDevice *device);
+  void (*list)     (FpDevice *device);
+  void (*delete)   (FpDevice * device);
+
+  void (*cancel)   (FpDevice *device);
+
+  /*< private >*/
+  /* padding for future expansion */
+  TOD_PADDING (32, 0);
+};
+
+typedef struct _FpDeviceClassTODV1_90_1 FpDeviceClassTODV1_90_1;
+
+typedef enum {
+  FPI_DEVICE_ACTION_TODV1_90_1_NONE = 0,
+  FPI_DEVICE_ACTION_TODV1_90_1_PROBE,
+  FPI_DEVICE_ACTION_TODV1_90_1_OPEN,
+  FPI_DEVICE_ACTION_TODV1_90_1_CLOSE,
+  FPI_DEVICE_ACTION_TODV1_90_1_ENROLL,
+  FPI_DEVICE_ACTION_TODV1_90_1_VERIFY,
+  FPI_DEVICE_ACTION_TODV1_90_1_IDENTIFY,
+  FPI_DEVICE_ACTION_TODV1_90_1_CAPTURE,
+  FPI_DEVICE_ACTION_TODV1_90_1_LIST,
+  FPI_DEVICE_ACTION_TODV1_90_1_DELETE,
+} FpiDeviceActionTODV1_90_1;
+
+typedef enum {
+  FPI_DEVICE_ACTION_TODV1_92_0_NONE = 0,
+  FPI_DEVICE_ACTION_TODV1_92_0_PROBE,
+  FPI_DEVICE_ACTION_TODV1_92_0_OPEN,
+  FPI_DEVICE_ACTION_TODV1_92_0_CLOSE,
+  FPI_DEVICE_ACTION_TODV1_92_0_ENROLL,
+  FPI_DEVICE_ACTION_TODV1_92_0_VERIFY,
+  FPI_DEVICE_ACTION_TODV1_92_0_IDENTIFY,
+  FPI_DEVICE_ACTION_TODV1_92_0_CAPTURE,
+  FPI_DEVICE_ACTION_TODV1_92_0_LIST,
+  FPI_DEVICE_ACTION_TODV1_92_0_DELETE,
+  FPI_DEVICE_ACTION_TODV1_92_0_CLEAR_STORAGE
+} FpiDeviceActionTODV1_92_0;
+
+typedef enum /*< flags >*/ {
+  FP_DEVICE_FEATURE_TODV1_92_0_NONE = 0,
+  FP_DEVICE_FEATURE_TODV1_92_0_CAPTURE = 1 << 0,
+  FP_DEVICE_FEATURE_TODV1_92_0_IDENTIFY = 1 << 1,
+  FP_DEVICE_FEATURE_TODV1_92_0_VERIFY = 1 << 2,
+  FP_DEVICE_FEATURE_TODV1_92_0_STORAGE = 1 << 3,
+  FP_DEVICE_FEATURE_TODV1_92_0_STORAGE_LIST = 1 << 4,
+  FP_DEVICE_FEATURE_TODV1_92_0_STORAGE_DELETE = 1 << 5,
+  FP_DEVICE_FEATURE_TODV1_92_0_STORAGE_CLEAR = 1 << 6,
+  FP_DEVICE_FEATURE_TODV1_92_0_DUPLICATES_CHECK = 1 << 7,
+} FpDeviceFeatureTODV1_92_0;
+
+typedef enum /*< flags >*/ {
+  FP_DEVICE_FEATURE_TODV1_94_0_NONE = 0,
+  FP_DEVICE_FEATURE_TODV1_94_0_CAPTURE = 1 << 0,
+  FP_DEVICE_FEATURE_TODV1_94_0_IDENTIFY = 1 << 1,
+  FP_DEVICE_FEATURE_TODV1_94_0_VERIFY = 1 << 2,
+  FP_DEVICE_FEATURE_TODV1_94_0_STORAGE = 1 << 3,
+  FP_DEVICE_FEATURE_TODV1_94_0_STORAGE_LIST = 1 << 4,
+  FP_DEVICE_FEATURE_TODV1_94_0_STORAGE_DELETE = 1 << 5,
+  FP_DEVICE_FEATURE_TODV1_94_0_STORAGE_CLEAR = 1 << 6,
+  FP_DEVICE_FEATURE_TODV1_94_0_DUPLICATES_CHECK = 1 << 7,
+  FP_DEVICE_FEATURE_TODV1_94_0_ALWAYS_ON = 1 << 8,
+} FpDeviceFeatureTODV1_94_0;
+
+typedef enum {
+  FPI_DEVICE_UDEV_SUBTYPE_TODV1_92_0_SPIDEV = 1 << 0,
+  FPI_DEVICE_UDEV_SUBTYPE_TODV1_92_0_HIDRAW = 1 << 1,
+} FpiDeviceUdevSubtypeFlagsTODV1_92_0;
+
+typedef struct _FpIdEntryTODV1_92_0 FpIdEntryTODV1_92_0;
+
+struct _FpIdEntryTODV1_92_0
+{
+  union
+  {
+    struct
+    {
+      guint pid;
+      guint vid;
+    };
+    const gchar *virtual_envvar;
+  };
+  guint64 driver_data;
+
+  /* Elements added after TODv1 */
+  union
+  {
+    struct
+    {
+      FpiDeviceUdevSubtypeFlagsTODV1_92_0 udev_types;
+      const gchar                        *spi_acpi_id;
+      struct
+      {
+        guint pid;
+        guint vid;
+      } hid_id;
+    };
+  };
+
+  /*< private >*/
+  /* padding for future expansion */
+  TOD_PADDING_ALIGNED (16, sizeof (guint) * 2 +
+                       sizeof (FpiDeviceUdevSubtypeFlagsTODV1_92_0) +
+                       sizeof (gpointer));
+};
+
+typedef struct _FpIdEntryTODV1_92_0 FpIdEntryTODV1_92_0;
+
+struct _FpDeviceClassTODV1_92_0
+{
+  /*< private >*/
+  GObjectClass parent_class;
+
+  /*< public >*/
+  /* Static information about the driver. */
+  const gchar               *id;
+  const gchar               *full_name;
+  FpDeviceTypeTODV1_92_0     type;
+  const FpIdEntryTODV1_92_0 *id_table;
+
+  /* Defaults for device properties */
+  gint                 nr_enroll_stages;
+  FpScanTypeTODV1_90_1 scan_type;
+
+  /* Callbacks */
+  gint (*usb_discover) (GUsbDevice *usb_device);
+  void (*probe)    (FpDevice *device);
+  void (*open)     (FpDevice *device);
+  void (*close)    (FpDevice *device);
+  void (*enroll)   (FpDevice *device);
+  void (*verify)   (FpDevice *device);
+  void (*identify) (FpDevice *device);
+  void (*capture)  (FpDevice *device);
+  void (*list)     (FpDevice *device);
+  void (*delete)   (FpDevice * device);
+
+  void                      (*cancel)   (FpDevice *device);
+
+  FpDeviceFeatureTODV1_92_0 features;
+
+  /*< private >*/
+  /* padding for future expansion */
+  TOD_PADDING (32, sizeof (FpDeviceFeatureTODV1_92_0));
+};
+
+typedef struct _FpDeviceClassTODV1_92_0 FpDeviceClassTODV1_92_0;
+
+
+struct _FpDeviceClassTODV1_94_0
+{
+  /*< private >*/
+  GObjectClass parent_class;
+
+  /*< public >*/
+  /* Static information about the driver. */
+  const gchar               *id;
+  const gchar               *full_name;
+  FpDeviceTypeTODV1_92_0     type;
+  const FpIdEntryTODV1_92_0 *id_table;
+
+  /* Defaults for device properties */
+  gint                 nr_enroll_stages;
+  FpScanTypeTODV1_90_1 scan_type;
+
+  /* Callbacks */
+  gint (*usb_discover) (GUsbDevice *usb_device);
+  void (*probe)    (FpDevice *device);
+  void (*open)     (FpDevice *device);
+  void (*close)    (FpDevice *device);
+  void (*enroll)   (FpDevice *device);
+  void (*verify)   (FpDevice *device);
+  void (*identify) (FpDevice *device);
+  void (*capture)  (FpDevice *device);
+  void (*list)     (FpDevice *device);
+  void (*delete)   (FpDevice * device);
+
+  void (*cancel)   (FpDevice *device);
+
+  /* Class elements added after tod-v1 */
+  FpDeviceFeatureTODV1_94_0 features;
+
+  /* Simple device temperature model constants */
+  gint32 temp_hot_seconds;
+  gint32 temp_cold_seconds;
+
+  void   (*clear_storage)  (FpDevice * device);
+  void   (*suspend)  (FpDevice *device);
+  void   (*resume)   (FpDevice *device);
+
+  /*< private >*/
+  /* padding for future expansion */
+  TOD_PADDING_ALIGNED8 (32,
+                        sizeof (FpDeviceFeatureTODV1_94_0) +
+                        sizeof (gint32) * 2 +
+                        sizeof (gpointer) * 3)
+};
+
+typedef struct _FpDeviceClassTODV1_94_0 FpDeviceClassTODV1_94_0;
diff --git a/tests/tod-drivers/base-fpi-image-device.h b/tests/tod-drivers/base-fpi-image-device.h
new file mode 100644
index 0000000..4228e04
--- /dev/null
+++ b/tests/tod-drivers/base-fpi-image-device.h
@@ -0,0 +1,61 @@
+/*
+ * FpImageDevice - An image based fingerprint reader device
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include "base-fpi-device.h"
+
+typedef struct _FpImageDevice FpImageDevice;
+
+typedef enum {
+  FPI_IMAGE_DEVICE_STATE_TODV1_90_1_INACTIVE,
+  FPI_IMAGE_DEVICE_STATE_TODV1_90_1_AWAIT_FINGER_ON,
+  FPI_IMAGE_DEVICE_STATE_TODV1_90_1_CAPTURE,
+  FPI_IMAGE_DEVICE_STATE_TODV1_90_1_AWAIT_FINGER_OFF,
+} FpiImageDeviceStateTODV1_90_1;
+
+typedef enum {
+  FPI_IMAGE_DEVICE_STATE_TODV1_92_0_INACTIVE,
+  FPI_IMAGE_DEVICE_STATE_TODV1_92_0_AWAIT_FINGER_ON,
+  FPI_IMAGE_DEVICE_STATE_TODV1_92_0_CAPTURE,
+  FPI_IMAGE_DEVICE_STATE_TODV1_92_0_AWAIT_FINGER_OFF,
+  FPI_IMAGE_DEVICE_STATE_TODV1_92_0_ACTIVATING,
+  FPI_IMAGE_DEVICE_STATE_TODV1_92_0_DEACTIVATING,
+  FPI_IMAGE_DEVICE_STATE_TODV1_92_0_IDLE,
+} FpiImageDeviceStateTODV1_90_4;
+
+typedef struct _FpImageDeviceClassTODV1_90_1
+{
+  FpDeviceClassTODV1_90_1 parent_class;
+
+  gint                    bz3_threshold;
+  gint                    img_width;
+  gint                    img_height;
+
+  void (*img_open)(FpImageDevice *dev);
+  void (*img_close)(FpImageDevice *dev);
+  void (*activate)(FpImageDevice *dev);
+  void (*change_state)(FpImageDevice                *dev,
+                       FpiImageDeviceStateTODV1_90_1 state);
+  void (*deactivate)(FpImageDevice *dev);
+
+  /*< private >*/
+  /* padding for future expansion */
+  TOD_PADDING (32, 0);
+} FpImageDeviceClassTODV1_90_1;
diff --git a/tests/tod-drivers/base-fpi-image.h b/tests/tod-drivers/base-fpi-image.h
new file mode 100644
index 0000000..172fce8
--- /dev/null
+++ b/tests/tod-drivers/base-fpi-image.h
@@ -0,0 +1,64 @@
+/*
+ * FpImageDevice - An image based fingerprint reader device
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "tod/tod-macros.h"
+
+typedef struct _FpImage           FpImage;
+typedef struct _FpImageTODV1_90_1 FpImageTODV1_90_1;
+
+typedef enum {
+  FPI_IMAGE_TODV1_90_1_V_FLIPPED       = 1 << 0,
+  FPI_IMAGE_TODV1_90_1_H_FLIPPED       = 1 << 1,
+  FPI_IMAGE_TODV1_90_1_COLORS_INVERTED = 1 << 2,
+} FpiImageFlagsTODV1_90_1;
+
+typedef enum {
+  FPI_IMAGE_TODV1_90_2_V_FLIPPED       = 1 << 0,
+  FPI_IMAGE_TODV1_90_2_H_FLIPPED       = 1 << 1,
+  FPI_IMAGE_TODV1_90_2_COLORS_INVERTED = 1 << 2,
+  FPI_IMAGE_TODV1_90_2_PARTIAL         = 1 << 3,
+} FpiImageFlagsTODV1_90_2;
+
+struct _FpImageTODV1_90_1
+{
+  /*< private >*/
+  GObject parent;
+
+  /*< public >*/
+  guint                   width;
+  guint                   height;
+
+  gdouble                 ppmm;
+
+  FpiImageFlagsTODV1_90_1 flags;
+
+  /*< private >*/
+  guint8    *data;
+  guint8    *binarized;
+
+  GPtrArray *minutiae;
+  guint      ref_count;
+
+  TOD_PADDING (32, 0);
+};
diff --git a/tests/tod-drivers/base-fpi-spi.h b/tests/tod-drivers/base-fpi-spi.h
new file mode 100644
index 0000000..e2e9bf3
--- /dev/null
+++ b/tests/tod-drivers/base-fpi-spi.h
@@ -0,0 +1,60 @@
+/*
+ * FpDevice - A fingerprint reader device
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include "base-fpi-device.h"
+
+typedef struct _FpiSpiTransferTODV1_92_0 FpiSpiTransferTODV1_92_0;
+typedef struct _FpiSsm                   FpiSsm;
+
+typedef void (*FpiSpiTransferCallbackTODV1_92_0)(FpiSpiTransferTODV1_92_0 *transfer,
+                                                 FpDevice                 *dev,
+                                                 gpointer                  user_data,
+                                                 GError                   *error);
+
+struct _FpiSpiTransferTODV1_92_0
+{
+  /*< public >*/
+  FpDevice *device;
+
+  FpiSsm   *ssm;
+
+  gssize    length_wr;
+  gssize    length_rd;
+
+  guchar   *buffer_wr;
+  guchar   *buffer_rd;
+
+  /*< private >*/
+  guint ref_count;
+
+  int   spidev_fd;
+
+  /* Callbacks */
+  gpointer                         user_data;
+  FpiSpiTransferCallbackTODV1_92_0 callback;
+
+  /* Data free function */
+  GDestroyNotify free_buffer_wr;
+  GDestroyNotify free_buffer_rd;
+
+  /* padding for future expansion */
+  TOD_PADDING (32, 0);
+};
diff --git a/tests/tod-drivers/base-fpi-usb.h b/tests/tod-drivers/base-fpi-usb.h
new file mode 100644
index 0000000..3637e6f
--- /dev/null
+++ b/tests/tod-drivers/base-fpi-usb.h
@@ -0,0 +1,80 @@
+/*
+ * FpDevice - A fingerprint reader device
+ * Copyright (C) 2021 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include <gusb.h>
+
+#include "base-fpi-device.h"
+
+typedef struct _FpiUsbTransferTODV1_90_1 FpiUsbTransferTODV1_90_1;
+typedef struct _FpiSsm                   FpiSsm;
+
+typedef void (*FpiUsbTransferCallbackTODV1_90_1)(FpiUsbTransferTODV1_90_1 *transfer,
+                                                 FpDevice                 *dev,
+                                                 gpointer                  user_data,
+                                                 GError                   *error);
+
+typedef enum  {
+  FP_TRANSFER_TODV1_90_1_NONE = -1,
+  FP_TRANSFER_TODV1_90_1_CONTROL = 0,
+  FP_TRANSFER_TODV1_90_1_BULK = 2,
+  FP_TRANSFER_TODV1_90_1_INTERRUPT = 3,
+} FpiTransferTypeTODV1_90_3;
+
+struct _FpiUsbTransferTODV1_90_1
+{
+  /*< public >*/
+  FpDevice *device;
+
+  FpiSsm   *ssm;
+
+  gssize    length;
+  gssize    actual_length;
+
+  guchar   *buffer;
+
+  /*< private >*/
+  guint ref_count;
+
+  /* USB Transfer information */
+  FpiTransferTypeTODV1_90_3 type;
+  guint8                    endpoint;
+
+  /* Control Transfer options */
+  GUsbDeviceDirection   direction;
+  GUsbDeviceRequestType request_type;
+  GUsbDeviceRecipient   recipient;
+  guint8                request;
+  guint16               value;
+  guint16               idx;
+
+  /* Flags */
+  gboolean short_is_error;
+
+  /* Callbacks */
+  gpointer                         user_data;
+  FpiUsbTransferCallbackTODV1_90_1 callback;
+
+  /* Data free function */
+  GDestroyNotify free_buffer;
+
+  /* padding for future expansion */
+  TOD_PADDING (32, 0);
+};
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.90.1/libdevice-fake-tod-ssm-test-v1+1.90.1-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.90.1/libdevice-fake-tod-ssm-test-v1+1.90.1-x86_64.so
new file mode 100755
index 0000000..094bb56
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.90.1/libdevice-fake-tod-ssm-test-v1+1.90.1-x86_64.so differ
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.90.1/libdevice-fake-tod-test-driver-v1+1.90.1-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.90.1/libdevice-fake-tod-test-driver-v1+1.90.1-x86_64.so
new file mode 100755
index 0000000..05c265b
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.90.1/libdevice-fake-tod-test-driver-v1+1.90.1-x86_64.so differ
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.90.2/libdevice-fake-tod-ssm-test-v1+1.90.2-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.90.2/libdevice-fake-tod-ssm-test-v1+1.90.2-x86_64.so
new file mode 100755
index 0000000..79dd107
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.90.2/libdevice-fake-tod-ssm-test-v1+1.90.2-x86_64.so differ
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.90.2/libdevice-fake-tod-test-driver-v1+1.90.2-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.90.2/libdevice-fake-tod-test-driver-v1+1.90.2-x86_64.so
new file mode 100755
index 0000000..ead8c97
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.90.2/libdevice-fake-tod-test-driver-v1+1.90.2-x86_64.so differ
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.90.3/libdevice-fake-tod-ssm-test-v1+1.90.3-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.90.3/libdevice-fake-tod-ssm-test-v1+1.90.3-x86_64.so
new file mode 100755
index 0000000..336ced5
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.90.3/libdevice-fake-tod-ssm-test-v1+1.90.3-x86_64.so differ
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.90.3/libdevice-fake-tod-test-driver-v1+1.90.3-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.90.3/libdevice-fake-tod-test-driver-v1+1.90.3-x86_64.so
new file mode 100755
index 0000000..281bb09
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.90.3/libdevice-fake-tod-test-driver-v1+1.90.3-x86_64.so differ
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.90.5/libdevice-fake-tod-ssm-test-v1+1.90.5-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.90.5/libdevice-fake-tod-ssm-test-v1+1.90.5-x86_64.so
new file mode 100755
index 0000000..0001228
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.90.5/libdevice-fake-tod-ssm-test-v1+1.90.5-x86_64.so differ
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.90.5/libdevice-fake-tod-test-driver-v1+1.90.5-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.90.5/libdevice-fake-tod-test-driver-v1+1.90.5-x86_64.so
new file mode 100755
index 0000000..d8634c4
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.90.5/libdevice-fake-tod-test-driver-v1+1.90.5-x86_64.so differ
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.94.0/libdevice-fake-tod-ssm-test-v1+1.94.0-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.94.0/libdevice-fake-tod-ssm-test-v1+1.94.0-x86_64.so
new file mode 100755
index 0000000..49e3104
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.94.0/libdevice-fake-tod-ssm-test-v1+1.94.0-x86_64.so differ
diff --git a/tests/tod-drivers/tod-x86_64-v1+1.94.0/libdevice-fake-tod-test-driver-v1+1.94.0-x86_64.so b/tests/tod-drivers/tod-x86_64-v1+1.94.0/libdevice-fake-tod-test-driver-v1+1.94.0-x86_64.so
new file mode 100755
index 0000000..8c64885
Binary files /dev/null and b/tests/tod-drivers/tod-x86_64-v1+1.94.0/libdevice-fake-tod-test-driver-v1+1.94.0-x86_64.so differ
