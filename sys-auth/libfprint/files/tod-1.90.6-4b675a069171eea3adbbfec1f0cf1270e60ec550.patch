diff --git a/NEWS.tod.md b/NEWS.tod.md
new file mode 100644
index 0000000..66e764f
--- /dev/null
+++ b/NEWS.tod.md
@@ -0,0 +1,25 @@
+### libfprint-TOD v1
+
+- First public release
+- Based on [libfprint 1.90.1](https://gitlab.freedesktop.org/libfprint/libfprint/-/releases#v1.90.1)
+- Bumped TOD version to 1
+
+### Highlights of the Drivers API changes
+
+Both the driver and external APIs have changed, as both the verify and the identify functions now have early reporting mechanisms.
+
+- Added API for early report of matching results or retry errors
+- Verify and identification completion functions have been simplified
+- Support variadic arguments in error functions
+- Various re-definitions of ownership handling
+- Add convenience API to change state after a timeout
+- Add unit tests for all the drivers API
+
+### Drivers required changes
+As per the early report mechanism, drivers need to adapt, in particular:
+ - New pkg-config dependency name is `libfprint-2-tod-1`
+ - Verification and Identification API for non-image drivers has changed and drivers need to both `report` the result of the action and complete it:
+   - `fpi_device_{verify,identify}_report` must inform whether a match/no-match or identification happened or report a *retry error*.
+   - `fpi_device_{verify,identify}_complete` must be called once the device has completed the verification / identification process,  in case reporting device errors (not retry ones!)
+
+You can see examples of changes needed in the [reference example driver](https://gitlab.freedesktop.org/3v1n0/libfprint-tod-example-driver/-/commit/8308f84f7d1cfd1b9ed0936c13c73b43a4a46772) or the [upstream synaptics driver](https://gitlab.freedesktop.org/libfprint/libfprint/-/merge_requests/112/diffs)
diff --git a/README.tod.md b/README.tod.md
new file mode 100644
index 0000000..34d71a8
--- /dev/null
+++ b/README.tod.md
@@ -0,0 +1,9 @@
+### libfprint-TOD - libfprint for Touch OEM Drivers
+
+This is a light fork of libfprint to expose internal Drivers API in order to
+create drivers as shared libraries.
+
+Fork is hosted at: https://gitlab.freedesktop.org/3v1n0/libfprint/tree/tod
+
+An example driver implementation is available:
+ - https://gitlab.freedesktop.org/3v1n0/libfprint-tod-example-driver
diff --git a/libfprint/drivers/virtual-image.c b/libfprint/drivers/virtual-image.c
index d4c7cc5..b92a332 100644
--- a/libfprint/drivers/virtual-image.c
+++ b/libfprint/drivers/virtual-image.c
@@ -208,8 +208,12 @@ recv_image (FpDeviceVirtualImage *self, GInputStream *stream)
   g_debug ("Starting image receive (if active), state is: %i", state);
 
   /* Only register if the state is active. */
-  if (state >= FPI_IMAGE_DEVICE_STATE_IDLE)
+  switch (state)
     {
+    case FPI_IMAGE_DEVICE_STATE_IDLE:
+    case FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_ON:
+    case FPI_IMAGE_DEVICE_STATE_CAPTURE:
+    case FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_OFF:
       g_input_stream_read_all_async (stream,
                                      self->recv_img_hdr,
                                      sizeof (self->recv_img_hdr),
@@ -217,6 +221,10 @@ recv_image (FpDeviceVirtualImage *self, GInputStream *stream)
                                      self->cancellable,
                                      recv_image_hdr_recv_cb,
                                      self);
+    /* fallthrough */
+
+    default:
+      break;
     }
 }
 
diff --git a/libfprint/fp-context.c b/libfprint/fp-context.c
index 584b0b7..fd5d059 100644
--- a/libfprint/fp-context.c
+++ b/libfprint/fp-context.c
@@ -24,6 +24,11 @@
 #include "fpi-device.h"
 #include <gusb.h>
 
+#include <config.h>
+#ifdef HAVE_LIBFPRINT_TOD
+#include "tod/tod-shared-loader.h"
+#endif
+
 /**
  * SECTION: fp-context
  * @title: FpContext
@@ -266,6 +271,8 @@ fp_context_finalize (GObject *object)
     g_object_run_dispose (G_OBJECT (priv->usb_ctx));
   g_clear_object (&priv->usb_ctx);
 
+  fpi_tod_shared_drivers_unregister ();
+
   G_OBJECT_CLASS (fp_context_parent_class)->finalize (object);
 }
 
@@ -321,11 +328,16 @@ static void
 fp_context_init (FpContext *self)
 {
   g_autoptr(GError) error = NULL;
+  g_autoptr(GArray) shared_drivers = NULL;
   FpContextPrivate *priv = fp_context_get_instance_private (self);
   guint i;
 
   priv->drivers = fpi_get_driver_types ();
 
+  fpi_tod_shared_drivers_register ();
+  shared_drivers = fpi_tod_shared_drivers_get ();
+  g_array_prepend_vals (priv->drivers, shared_drivers->data, shared_drivers->len);
+
   if (get_drivers_whitelist_env ())
     {
       for (i = 0; i < priv->drivers->len;)
diff --git a/libfprint/fp-image.c b/libfprint/fp-image.c
index 51732c1..fa3a5b4 100644
--- a/libfprint/fp-image.c
+++ b/libfprint/fp-image.c
@@ -23,6 +23,7 @@
 #include "fpi-image.h"
 #include "fpi-log.h"
 
+#include <config.h>
 #include <nbis.h>
 
 /**
diff --git a/libfprint/fpi-assembling.h b/libfprint/fpi-assembling.h
index 295e315..6e1b707 100644
--- a/libfprint/fpi-assembling.h
+++ b/libfprint/fpi-assembling.h
@@ -110,6 +110,7 @@ struct fpi_line_asmbl_ctx
   unsigned char (*get_pixel)(struct fpi_line_asmbl_ctx *ctx,
                              GSList                    *line,
                              unsigned int               x);
+  gpointer _padding_dummy[32];
 };
 
 FpImage *fpi_assemble_lines (struct fpi_line_asmbl_ctx *ctx,
diff --git a/libfprint/fpi-device.h b/libfprint/fpi-device.h
index e0938ae..5ab50e5 100644
--- a/libfprint/fpi-device.h
+++ b/libfprint/fpi-device.h
@@ -45,6 +45,10 @@ struct _FpIdEntry
     const gchar *virtual_envvar;
   };
   guint64 driver_data;
+
+  /*< private >*/
+  /* padding for future expansion */
+  gpointer _padding_dummy[16];
 };
 
 /**
@@ -129,6 +133,10 @@ struct _FpDeviceClass
   void (*delete)   (FpDevice * device);
 
   void (*cancel)   (FpDevice *device);
+
+  /*< private >*/
+  /* padding for future expansion */
+  gpointer _padding_dummy[32];
 };
 
 /**
diff --git a/libfprint/fpi-image-device.h b/libfprint/fpi-image-device.h
index 71472db..f1a6efd 100644
--- a/libfprint/fpi-image-device.h
+++ b/libfprint/fpi-image-device.h
@@ -62,12 +62,12 @@
  */
 typedef enum {
   FPI_IMAGE_DEVICE_STATE_INACTIVE,
-  FPI_IMAGE_DEVICE_STATE_ACTIVATING,
-  FPI_IMAGE_DEVICE_STATE_DEACTIVATING,
-  FPI_IMAGE_DEVICE_STATE_IDLE,
   FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_ON,
   FPI_IMAGE_DEVICE_STATE_CAPTURE,
   FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_OFF,
+  FPI_IMAGE_DEVICE_STATE_ACTIVATING,
+  FPI_IMAGE_DEVICE_STATE_DEACTIVATING,
+  FPI_IMAGE_DEVICE_STATE_IDLE,
 } FpiImageDeviceState;
 
 /**
@@ -114,6 +114,10 @@ struct _FpImageDeviceClass
   void          (*change_state) (FpImageDevice      *dev,
                                  FpiImageDeviceState state);
   void          (*deactivate)   (FpImageDevice *dev);
+
+  /*< private >*/
+  /* padding for future expansion */
+  gpointer _padding_dummy[32];
 };
 
 void fpi_image_device_set_bz3_threshold (FpImageDevice *self,
diff --git a/libfprint/fpi-image.c b/libfprint/fpi-image.c
index 47aac8d..95465ad 100644
--- a/libfprint/fpi-image.c
+++ b/libfprint/fpi-image.c
@@ -24,6 +24,7 @@
 #include "fpi-log.h"
 
 #include <nbis.h>
+#include <config.h>
 
 #if HAVE_PIXMAN
 #include <pixman.h>
@@ -107,12 +108,12 @@ fpi_mean_sq_diff_norm (const guint8 *buf1,
   return res / size;
 }
 
-#if HAVE_PIXMAN
 FpImage *
 fpi_image_resize (FpImage *orig_img,
                   guint    w_factor,
                   guint    h_factor)
 {
+#if HAVE_PIXMAN
   int new_width = orig_img->width * w_factor;
   int new_height = orig_img->height * h_factor;
   pixman_image_t *orig, *resized;
@@ -145,5 +146,9 @@ fpi_image_resize (FpImage *orig_img,
   pixman_image_unref (resized);
 
   return newimg;
-}
+#else
+  fp_err ("Libfprint compiled without pixman support, impossible to resize");
+
+  return NULL;
 #endif
+}
diff --git a/libfprint/fpi-image.h b/libfprint/fpi-image.h
index fcd62b8..3554bb7 100644
--- a/libfprint/fpi-image.h
+++ b/libfprint/fpi-image.h
@@ -20,7 +20,6 @@
 
 #pragma once
 
-#include <config.h>
 #include "fp-image.h"
 
 /**
@@ -77,8 +76,6 @@ gint fpi_mean_sq_diff_norm (const guint8 *buf1,
                             const guint8 *buf2,
                             gint          size);
 
-#if HAVE_PIXMAN
 FpImage *fpi_image_resize (FpImage *orig,
                            guint    w_factor,
                            guint    h_factor);
-#endif
diff --git a/libfprint/fpi-usb-transfer.h b/libfprint/fpi-usb-transfer.h
index 3770003..7f0deac 100644
--- a/libfprint/fpi-usb-transfer.h
+++ b/libfprint/fpi-usb-transfer.h
@@ -102,6 +102,10 @@ struct _FpiUsbTransfer
 
   /* Data free function */
   GDestroyNotify free_buffer;
+
+  /*< private >*/
+  /* padding for future expansion */
+  gpointer _padding_dummy[32];
 };
 
 GType              fpi_usb_transfer_get_type (void) G_GNUC_CONST;
diff --git a/libfprint/meson.build b/libfprint/meson.build
index 96cfe9b..030e1e6 100644
--- a/libfprint/meson.build
+++ b/libfprint/meson.build
@@ -234,6 +234,8 @@ libnbis = static_library('nbis',
         '-Wno-error=redundant-decls',
         '-Wno-redundant-decls',
         '-Wno-discarded-qualifiers',
+        '-Wno-array-bounds',
+        '-Wno-array-parameter',
     ]),
     install: false)
 
@@ -246,6 +248,10 @@ libfprint_private = static_library('fprint-private',
     link_with: libnbis,
     install: false)
 
+if get_option('tod')
+    subdir('tod')
+endif
+
 libfprint_drivers = static_library('fprint-drivers',
     sources: drivers_sources,
     c_args: drivers_cflags,
diff --git a/libfprint/tod/libfprint-tod.ver b/libfprint/tod/libfprint-tod.ver
new file mode 100644
index 0000000..d18569f
--- /dev/null
+++ b/libfprint/tod/libfprint-tod.ver
@@ -0,0 +1,6 @@
+LIBFPRINT_TOD_1.0.0 {
+global:
+	fpi_*;
+local:
+    *;
+};
diff --git a/libfprint/tod/meson.build b/libfprint/tod/meson.build
new file mode 100644
index 0000000..58c4868
--- /dev/null
+++ b/libfprint/tod/meson.build
@@ -0,0 +1,86 @@
+tod_soversion = 1
+tod_subpath = versioned_libname / 'tod-@0@'.format(tod_soversion)
+tod_modules_prefix = get_option('libdir') / tod_subpath
+
+tod_conf = configuration_data()
+tod_conf.set_quoted('TOD_DRIVERS_DIR',
+    get_option('prefix') / get_option('libdir') / tod_subpath)
+configure_file(output: 'tod-config.h', configuration: tod_conf)
+
+gmodule_dep = dependency('gmodule-2.0', version: '>=' + glib_min_version)
+deps += gmodule_dep
+
+mapfile = files('libfprint-tod.ver')
+
+libfprint_tod_private = static_library('fprint-tod-private',
+    sources: [
+        'tod-shared-loader.c',
+    ],
+    include_directories: include_directories('..'),
+    link_with: libfprint_private,
+    dependencies: deps,
+    install: false,
+)
+
+tod_sources = []
+foreach source: libfprint_private_sources
+    tod_sources += '..' / source
+endforeach
+
+libfprint_tod = library(versioned_libname.split('lib')[1] + '-tod',
+    sources: [
+        tod_sources,
+    ],
+    soversion: tod_soversion,
+    include_directories: include_directories('..'),
+    link_args: [
+        '-Wl,--version-script,@0@/@1@'.format(meson.source_root(), mapfile[0]),
+        '-Wl,--unresolved-symbols=ignore-in-object-files'
+    ],
+    link_depends: mapfile,
+    link_with: [libfprint_private],
+    dependencies: deps,
+    install: true)
+
+deps += declare_dependency(
+    link_with: [
+        libfprint_tod,
+        libfprint_tod_private,
+    ]
+)
+
+pkgconfig = import('pkgconfig')
+pkgconfig.generate(libfprint_tod,
+    name: versioned_libname + '-tod',
+    filebase: '@0@-tod-@1@'.format(versioned_libname, tod_soversion),
+    description: 'Private Libfprint Touch Drivers API',
+    version: meson.project_version() + '+tod@0@'.format(tod_soversion),
+    subdirs: tod_subpath,
+    requires_private: [
+        versioned_libname,
+    ],
+    variables: [
+        'tod_driversdir=${libdir}/@0@'.format(tod_subpath)
+    ]
+)
+
+tod_headers = []
+extra_libfprint_headers = [
+    'drivers_api.h',
+]
+
+foreach header: libfprint_private_headers + extra_libfprint_headers
+    tod_headers += '..' / header
+endforeach
+
+custom_target('tod_fpi_enums_headers',
+  depends: fpi_enums,
+  input: fpi_enums_h,
+  output: 'fpi-enums.h',
+  command: ['cp', '@INPUT@', '-v', '@OUTPUT@'],
+  install: true,
+  install_dir: get_option('includedir') / tod_subpath)
+
+install_headers(tod_headers,
+    subdir: tod_subpath
+)
diff --git a/libfprint/tod/tod-shared-loader.c b/libfprint/tod/tod-shared-loader.c
new file mode 100644
index 0000000..3fb0420
--- /dev/null
+++ b/libfprint/tod/tod-shared-loader.c
@@ -0,0 +1,151 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#define FP_COMPONENT "tod"
+
+#include <gmodule.h>
+
+#include "tod-shared-loader.h"
+#include "fpi-device.h"
+#include "fpi-log.h"
+#include "tod-config.h"
+
+#define FPI_TOD_ENTRY_GTYPE_GETTER "fpi_tod_shared_driver_get_type"
+
+static GArray *shared_drivers = NULL;
+static GList *shared_modules = NULL;
+
+typedef GModule FpiTodModule;
+typedef GType (*FpiTodShardDriverTypeGetter) (void);
+
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (FpiTodModule, g_module_close);
+
+static const char *
+get_tod_drivers_dir (void)
+{
+  const char *tod_env_path = g_getenv ("FP_TOD_DRIVERS_DIR");
+
+  if (!tod_env_path || *tod_env_path == '\0')
+    return TOD_DRIVERS_DIR;
+
+  return tod_env_path;
+}
+
+void
+fpi_tod_shared_drivers_register (void)
+{
+  const char *dirname;
+  const char *basename;
+
+  g_autoptr(GError) error = NULL;
+  g_autoptr(GDir) dir = NULL;
+  gpointer symbol;
+
+  g_assert_null (shared_drivers);
+
+  dirname = get_tod_drivers_dir ();
+  dir = g_dir_open (dirname, 0, &error);
+
+  shared_drivers = g_array_new (TRUE, FALSE, sizeof (GType));
+
+  if (error)
+    {
+      fp_dbg ("Impossible to load the shared drivers dir %s", error->message);
+      return;
+    }
+
+  while ((basename = g_dir_read_name (dir)) != NULL)
+    {
+      g_autoptr(FpiTodModule) module = NULL;
+      g_autoptr(GTypeClass) type_class = NULL;
+      g_autofree char *module_path = NULL;
+      FpiTodShardDriverTypeGetter type_getter;
+      FpDeviceClass *cls;
+      GType driver;
+
+      if (!g_str_has_prefix (basename, "lib"))
+        continue;
+
+      if (!g_str_has_suffix (basename, ".so"))
+        continue;
+
+      module_path = g_build_filename (dirname, basename, NULL);
+
+      if (!g_file_test (module_path, G_FILE_TEST_IS_REGULAR))
+        continue;
+
+      fp_dbg ("Opening driver %s", module_path);
+
+      module = g_module_open (module_path, G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);
+
+      if (!module)
+        {
+          fp_err ("Impossible to load module %s: %s", module_path,
+                  g_module_error ());
+          continue;
+        }
+
+      if (!g_module_symbol (module, FPI_TOD_ENTRY_GTYPE_GETTER, &symbol))
+        {
+          fp_err ("Library %s doesn't expose the required entry point symbol",
+                  module_path);
+          continue;
+        }
+
+      type_getter = symbol;
+      driver = type_getter ();
+      fp_dbg ("Found TOD entry point symbol %p, GType is %lu", symbol, driver);
+
+      if (!G_TYPE_IS_OBJECT (driver) || !g_type_is_a (driver, FP_TYPE_DEVICE))
+        {
+          fp_err ("Library %s returned GType (%lu) doesn't represent a device",
+                  module_path, driver);
+          continue;
+        }
+
+      type_class = g_type_class_ref (driver);
+      g_assert_true (g_type_check_class_is_a (type_class, FP_TYPE_DEVICE));
+
+      cls = FP_DEVICE_CLASS (type_class);
+
+      fp_dbg ("Loading driver %s (%s)", cls->id, cls->full_name);
+      g_array_append_val (shared_drivers, driver);
+
+      shared_modules = g_list_prepend (shared_modules,
+                                       g_steal_pointer (&module));
+    }
+}
+
+void
+fpi_tod_shared_drivers_unregister (void)
+{
+  g_clear_pointer (&shared_drivers, g_array_unref);
+
+  if (g_strcmp0 (g_getenv ("FP_TOD_KEEP_MODULES_OPEN"), "TRUE") != 0)
+    {
+      g_list_free_full (shared_modules, (GDestroyNotify) g_module_close);
+      shared_modules = NULL;
+    }
+}
+
+GArray *
+fpi_tod_shared_drivers_get (void)
+{
+  return g_array_ref (shared_drivers);
+}
diff --git a/libfprint/tod/tod-shared-loader.h b/libfprint/tod/tod-shared-loader.h
new file mode 100644
index 0000000..8ed2e81
--- /dev/null
+++ b/libfprint/tod/tod-shared-loader.h
@@ -0,0 +1,28 @@
+/*
+ * Shared library loader for libfprint
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include <glib.h>
+
+
+void fpi_tod_shared_drivers_register (void);
+void fpi_tod_shared_drivers_unregister (void);
+
+GArray *fpi_tod_shared_drivers_get (void);
diff --git a/meson.build b/meson.build
index a2b849b..4c52e2e 100644
--- a/meson.build
+++ b/meson.build
@@ -1,5 +1,5 @@
 project('libfprint', [ 'c', 'cpp' ],
-    version: '1.90.6',
+    version: '1.90.6+tod1',
     license: 'LGPLv2.1+',
     default_options: [
         'buildtype=debugoptimized',
@@ -192,6 +192,8 @@ if get_option('gtk-examples')
     endif
 endif
 
+libfprint_conf.set10('HAVE_LIBFPRINT_TOD', get_option('tod'))
+
 configure_file(output: 'config.h', configuration: libfprint_conf)
 
 subdir('libfprint')
diff --git a/meson_options.txt b/meson_options.txt
index 746efdc..d059ae5 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -22,3 +22,8 @@ option('doc',
        description: 'Whether to build the API documentation',
        type: 'boolean',
        value: true)
+
+option('tod',
+       description: 'Whether to build the TOD library',
+       type: 'boolean',
+       value: true)
diff --git a/tests/meson.build b/tests/meson.build
index 12a1095..b8d1c8a 100644
--- a/tests/meson.build
+++ b/tests/meson.build
@@ -193,3 +193,85 @@ if valgrind.found()
                 valgrind.path(), glib_suppressions, python_suppressions)
         ])
 endif
+
+if get_option('tod')
+    tod_envs = envs
+    tod_envs.set('FP_TOD_KEEP_MODULES_OPEN', 'TRUE')
+    tod_envs.set('FP_VIRTUAL_FAKE_DEVICE', 'yes')
+    tod_envs.set('FP_TOD_TEST_DRIVER_NAME', 'fake_test_dev_tod')
+    tod_envs.prepend('LD_LIBRARY_PATH',
+        meson.build_root() / 'libfprint',
+        meson.build_root() / 'libfprint' / 'tod')
+    tod_c_args = [
+        '-DTEST_TOD_DRIVER=1',
+    ]
+
+    fake_driver = shared_module('device-fake-tod-driver',
+        sources: [
+            'test-device-fake.c',
+            'test-device-fake-tod.c',
+        ],
+        c_args: tod_c_args,
+        link_with: [
+            libfprint_tod,
+        ],
+        include_directories: include_directories('../libfprint'),
+        dependencies: deps,
+        install: false
+    )
+
+    test_utils_tod = static_library('fprint-test-utils-tod',
+        sources: [
+            'test-utils.c',
+            'test-utils-tod.c',
+        ],
+        dependencies: libfprint_private_dep,
+        install: false)
+
+    tod_unit_tests = [
+        'fp-context-tod',
+        'fp-device-tod',
+        'fpi-device',
+    ]
+
+    tod_dirs = {
+        'fake_test_dev_tod_current': meson.current_build_dir(),
+    }
+
+    machine = run_command(meson.get_compiler('c'), '-dumpmachine').stdout().strip()
+    if machine.startswith('x86_64-')
+        tod_dirs += {
+            'fake_test_dev_tod_v1': meson.current_source_dir() / 'tod-drivers',
+        }
+    endif
+
+    foreach test_name: tod_unit_tests
+        basename = 'test-' + test_name
+        sufix = test_name.endswith('-tod') ? '' : '-tod'
+        test_name = test_name + sufix
+        test_exe = executable(basename + sufix,
+            sources: basename + '.c',
+            dependencies: libfprint_private_dep,
+            c_args: [
+                common_cflags,
+                tod_c_args,
+            ],
+            link_with: test_utils_tod,
+        )
+
+        foreach tod_driver, tod_dir : tod_dirs
+            tod_test_envs = tod_envs
+            tod_test_envs.prepend('FP_DRIVERS_WHITELIST', tod_driver)
+            tod_test_envs.set('FP_TOD_DRIVERS_DIR', tod_dir)
+            tod_test_envs.set('FP_TOD_TEST_DRIVER_NAME', tod_driver)
+
+            test(test_name + '-' + tod_driver,
+                find_program('test-runner.sh'),
+                suite: ['unit-tests', 'tod', tod_driver],
+                args: [test_exe],
+                env: tod_test_envs,
+                depends: fake_driver,
+            )
+        endforeach
+    endforeach
+endif
diff --git a/tests/test-device-fake-tod.c b/tests/test-device-fake-tod.c
new file mode 100644
index 0000000..aea7387
--- /dev/null
+++ b/tests/test-device-fake-tod.c
@@ -0,0 +1,28 @@
+/*
+ * Virtual driver for device debugging
+ *
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "test-device-fake-tod.h"
+#include "test-device-fake.h"
+
+GType
+fpi_tod_shared_driver_get_type (void)
+{
+  return fpi_device_fake_get_type ();
+}
diff --git a/tests/test-device-fake-tod.h b/tests/test-device-fake-tod.h
new file mode 100644
index 0000000..3660212
--- /dev/null
+++ b/tests/test-device-fake-tod.h
@@ -0,0 +1,25 @@
+/*
+ * Virtual driver for device debugging
+ *
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#pragma once
+
+#include <glib-object.h>
+
+GType fpi_tod_shared_driver_get_type (void);
diff --git a/tests/test-device-fake.c b/tests/test-device-fake.c
index 2341581..52b0835 100644
--- a/tests/test-device-fake.c
+++ b/tests/test-device-fake.c
@@ -18,7 +18,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#ifdef TEST_TOD_DRIVER
+#define FP_COMPONENT "fake_test_dev_tod_current"
+#else
 #define FP_COMPONENT "fake_test_dev"
+#endif
 
 #include "test-device-fake.h"
 
diff --git a/tests/test-fp-context-tod.c b/tests/test-fp-context-tod.c
new file mode 100644
index 0000000..f25a31d
--- /dev/null
+++ b/tests/test-fp-context-tod.c
@@ -0,0 +1,103 @@
+/*
+ * FpContext Unit tests
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <libfprint/fprint.h>
+
+static void
+test_context_new (void)
+{
+  g_autoptr(FpContext) context = fp_context_new ();
+  g_assert_true (FP_CONTEXT (context));
+}
+
+static void
+test_context_has_no_devices (void)
+{
+  g_autoptr(FpContext) context = NULL;
+  GPtrArray *devices;
+  const char *old_drivers_dir = g_getenv ("FP_TOD_DRIVERS_DIR");
+
+  g_setenv ("FP_TOD_DRIVERS_DIR", "__HOPEFULLY_AN_INVALID_PATH", TRUE);
+  context = fp_context_new ();
+  devices = fp_context_get_devices (context);
+  g_setenv ("FP_TOD_DRIVERS_DIR", old_drivers_dir, TRUE);
+
+  g_assert_nonnull (devices);
+  g_assert_cmpuint (devices->len, ==, 0);
+}
+
+static void
+test_context_has_fake_device (void)
+{
+  g_autoptr(FpContext) context = NULL;
+  FpDevice *fake_device = NULL;
+  GPtrArray *devices;
+  const char *tod_name;
+  unsigned int i;
+
+  context = fp_context_new ();
+  devices = fp_context_get_devices (context);
+  tod_name = g_getenv ("FP_TOD_TEST_DRIVER_NAME");
+
+  g_assert_nonnull (devices);
+  g_assert_cmpuint (devices->len, ==, 1);
+
+  for (i = 0; i < devices->len; ++i)
+    {
+      FpDevice *device = devices->pdata[i];
+
+      if (g_strcmp0 (fp_device_get_driver (device), tod_name) == 0)
+        {
+          fake_device = device;
+          break;
+        }
+    }
+
+  g_assert_true (FP_IS_DEVICE (fake_device));
+}
+
+static void
+test_context_enumerates_new_devices (void)
+{
+  g_autoptr(FpContext) context = NULL;
+  GPtrArray *devices;
+
+  context = fp_context_new ();
+
+  fp_context_enumerate (context);
+  devices = fp_context_get_devices (context);
+
+  g_assert_nonnull (devices);
+  g_assert_cmpuint (devices->len, ==, 1);
+}
+
+int
+main (int argc, char *argv[])
+{
+  g_test_init (&argc, &argv, NULL);
+
+  g_assert_nonnull (g_getenv ("FP_TOD_DRIVERS_DIR"));
+
+  g_test_add_func ("/context/new", test_context_new);
+  g_test_add_func ("/context/no-devices", test_context_has_no_devices);
+  g_test_add_func ("/context/has-virtual-device", test_context_has_fake_device);
+  g_test_add_func ("/context/enumerates-new-devices", test_context_enumerates_new_devices);
+
+  return g_test_run ();
+}
diff --git a/tests/test-fp-device-tod.c b/tests/test-fp-device-tod.c
new file mode 100644
index 0000000..d134d1e
--- /dev/null
+++ b/tests/test-fp-device-tod.c
@@ -0,0 +1,240 @@
+/*
+ * FpDevice Unit tests
+ * Copyright (C) 2019 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <libfprint/fprint.h>
+
+#include "test-utils-tod.h"
+
+static void
+on_device_opened (FpDevice *dev, GAsyncResult *res, FptContext *tctx)
+{
+  g_autoptr(GError) error = NULL;
+
+  g_assert_true (fp_device_open_finish (dev, res, &error));
+  g_assert_no_error (error);
+  g_assert_true (fp_device_is_open (tctx->device));
+
+  tctx->user_data = GUINT_TO_POINTER (TRUE);
+}
+
+static void
+test_device_open_async (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open (tctx->device, NULL, (GAsyncReadyCallback) on_device_opened, tctx);
+
+  while (!GPOINTER_TO_UINT (tctx->user_data))
+    g_main_context_iteration (NULL, TRUE);
+}
+
+static void
+on_device_closed (FpDevice *dev, GAsyncResult *res, FptContext *tctx)
+{
+  g_autoptr(GError) error = NULL;
+
+  g_assert_true (fp_device_close_finish (dev, res, &error));
+  g_assert_no_error (error);
+  g_assert_false (fp_device_is_open (tctx->device));
+
+  tctx->user_data = GUINT_TO_POINTER (TRUE);
+}
+
+static void
+test_device_close_async (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open (tctx->device, NULL, (GAsyncReadyCallback) on_device_opened, tctx);
+  while (!tctx->user_data)
+    g_main_context_iteration (NULL, TRUE);
+
+  tctx->user_data = GUINT_TO_POINTER (FALSE);
+  fp_device_close (tctx->device, NULL, (GAsyncReadyCallback) on_device_closed, tctx);
+
+  while (!GPOINTER_TO_UINT (tctx->user_data))
+    g_main_context_iteration (NULL, TRUE);
+}
+
+static void
+test_device_open_sync (void)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, &error);
+  g_assert_no_error (error);
+  g_assert_true (fp_device_is_open (tctx->device));
+
+  fp_device_open_sync (tctx->device, NULL, &error);
+  g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_ALREADY_OPEN);
+}
+
+static void
+on_open_notify (FpDevice *rdev, GParamSpec *spec, FptContext *tctx)
+{
+  g_assert_cmpstr (spec->name, ==, "open");
+  tctx->user_data = GUINT_TO_POINTER (TRUE);
+}
+
+static void
+test_device_open_sync_notify (void)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  g_signal_connect (tctx->device, "notify::open", G_CALLBACK (on_open_notify), tctx);
+  g_assert_true (fp_device_open_sync (tctx->device, NULL, &error));
+  g_assert_no_error (error);
+  g_assert_true (GPOINTER_TO_INT (tctx->user_data));
+}
+
+static void
+test_device_close_sync (void)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  fp_device_close_sync (tctx->device, NULL, &error);
+  g_assert_no_error (error);
+  g_assert_false (fp_device_is_open (tctx->device));
+
+  fp_device_close_sync (tctx->device, NULL, &error);
+  g_assert_error (error, FP_DEVICE_ERROR, FP_DEVICE_ERROR_NOT_OPEN);
+}
+
+static void
+on_close_notify (FpDevice *rdev, GParamSpec *spec, FptContext *tctx)
+{
+  g_assert_cmpstr (spec->name, ==, "open");
+  tctx->user_data = GUINT_TO_POINTER (TRUE);
+}
+
+static void
+test_device_close_sync_notify (void)
+{
+  g_autoptr(GError) error = NULL;
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+
+  g_signal_connect (tctx->device, "notify::open", G_CALLBACK (on_close_notify), tctx);
+  fp_device_close_sync (tctx->device, NULL, &error);
+  g_assert_no_error (error);
+  g_assert_true (GPOINTER_TO_INT (tctx->user_data));
+}
+
+static void
+test_device_get_driver (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpstr (fp_device_get_driver (tctx->device), ==, g_getenv ("FP_TOD_TEST_DRIVER_NAME"));
+}
+
+static void
+test_device_get_device_id (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpstr (fp_device_get_device_id (tctx->device), ==, g_getenv ("FP_TOD_TEST_DRIVER_NAME"));
+}
+
+static void
+test_device_get_name (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpstr (fp_device_get_name (tctx->device), ==,
+                   "Virtual device for debugging");
+}
+
+static void
+test_device_get_scan_type (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpint (fp_device_get_scan_type (tctx->device), ==, FP_SCAN_TYPE_PRESS);
+}
+
+static void
+test_device_get_nr_enroll_stages (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_cmpuint (fp_device_get_nr_enroll_stages (tctx->device), ==, 5);
+}
+
+static void
+test_device_supports_identify (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_true (fp_device_supports_identify (tctx->device));
+}
+
+static void
+test_device_supports_capture (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_true (fp_device_supports_capture (tctx->device));
+}
+
+static void
+test_device_has_storage (void)
+{
+  g_autoptr(FptContext) tctx = fpt_context_new_with_fake_dev ();
+
+  fp_device_open_sync (tctx->device, NULL, NULL);
+  g_assert_true (fp_device_has_storage (tctx->device));
+}
+
+int
+main (int argc, char *argv[])
+{
+  g_test_init (&argc, &argv, NULL);
+
+  g_assert_nonnull (g_getenv ("FP_TOD_DRIVERS_DIR"));
+
+  g_test_add_func ("/device/async/open", test_device_open_async);
+  g_test_add_func ("/device/async/close", test_device_close_async);
+  g_test_add_func ("/device/sync/open", test_device_open_sync);
+  g_test_add_func ("/device/sync/open/notify", test_device_open_sync_notify);
+  g_test_add_func ("/device/sync/close", test_device_close_sync);
+  g_test_add_func ("/device/sync/close/notify", test_device_close_sync_notify);
+  g_test_add_func ("/device/sync/get_driver", test_device_get_driver);
+  g_test_add_func ("/device/sync/get_device_id", test_device_get_device_id);
+  g_test_add_func ("/device/sync/get_name", test_device_get_name);
+  g_test_add_func ("/device/sync/get_scan_type", test_device_get_scan_type);
+  g_test_add_func ("/device/sync/get_nr_enroll_stages", test_device_get_nr_enroll_stages);
+  g_test_add_func ("/device/sync/supports_identify", test_device_supports_identify);
+  g_test_add_func ("/device/sync/supports_capture", test_device_supports_capture);
+  g_test_add_func ("/device/sync/has_storage", test_device_has_storage);
+
+  return g_test_run ();
+}
diff --git a/tests/test-fpi-device.c b/tests/test-fpi-device.c
index 57e5cf9..4326128 100644
--- a/tests/test-fpi-device.c
+++ b/tests/test-fpi-device.c
@@ -26,6 +26,26 @@
 #include "fpi-log.h"
 #include "test-device-fake.h"
 
+#ifdef TEST_TOD_DRIVER
+
+#include "test-utils-tod.h"
+
+#undef FPI_TYPE_DEVICE_FAKE
+#define FPI_TYPE_DEVICE_FAKE (fpt_context_device_driver_get_type ())
+
+#undef FPI_DEVICE_FAKE
+#define FPI_DEVICE_FAKE(dev) (G_TYPE_CHECK_INSTANCE_CAST ((dev), FPI_TYPE_DEVICE_FAKE, FpiDeviceFake))
+
+static GType
+fpt_context_device_driver_get_type (void)
+{
+  FptContext *tctx = fpt_context_fake_dev_default ();
+
+  return G_TYPE_FROM_CLASS (FP_DEVICE_GET_CLASS (tctx->device));
+}
+
+#endif
+
 /* Utility functions */
 
 typedef FpDevice FpAutoCloseDevice;
@@ -2402,6 +2422,10 @@ test_driver_retry_error_types (void)
 int
 main (int argc, char *argv[])
 {
+#ifdef TEST_TOD_DRIVER
+  g_autoptr(FptContext) tctx = fpt_context_fake_dev_default ();
+#endif
+
   g_test_init (&argc, &argv, NULL);
 
   g_test_add_func ("/driver/get_driver", test_driver_get_driver);
diff --git a/tests/test-utils-tod.c b/tests/test-utils-tod.c
new file mode 100644
index 0000000..cf606fc
--- /dev/null
+++ b/tests/test-utils-tod.c
@@ -0,0 +1,67 @@
+/*
+ * Unit tests for libfprint
+ * Copyright (C) 2020 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <libfprint/fprint.h>
+
+#include "test-utils-tod.h"
+
+static FptContext *fake_context = NULL;
+
+FptContext *
+fpt_context_new_with_fake_dev (void)
+{
+  FptContext *tctx;
+  GPtrArray *devices;
+  const char *tod_name;
+  unsigned int i;
+
+  tctx = fpt_context_new ();
+  devices = fp_context_get_devices (tctx->fp_context);
+  tod_name = g_getenv ("FP_TOD_TEST_DRIVER_NAME");
+
+  g_assert_nonnull (tod_name);
+  g_assert_nonnull (devices);
+  g_assert_cmpuint (devices->len, ==, 1);
+
+  for (i = 0; i < devices->len; ++i)
+    {
+      FpDevice *device = devices->pdata[i];
+
+      if (g_strcmp0 (fp_device_get_driver (device), tod_name) == 0)
+        {
+          tctx->device = device;
+          break;
+        }
+    }
+
+  g_assert_true (FP_IS_DEVICE (tctx->device));
+  g_object_add_weak_pointer (G_OBJECT (tctx->device), (gpointer) & tctx->device);
+
+  return tctx;
+}
+
+FptContext *
+fpt_context_fake_dev_default (void)
+{
+  if (fake_context)
+    return fake_context;
+
+  fake_context = fpt_context_new_with_fake_dev ();
+  return fake_context;
+}
diff --git a/tests/test-utils-tod.h b/tests/test-utils-tod.h
new file mode 100644
index 0000000..b3d95a0
--- /dev/null
+++ b/tests/test-utils-tod.h
@@ -0,0 +1,25 @@
+/*
+ * Unit tests for libfprint
+ * Copyright (C) 2020 Marco Trevisan <marco.trevisan@canonical.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <glib.h>
+#include "test-utils.h"
+
+FptContext * fpt_context_new_with_fake_dev (void);
+
+FptContext * fpt_context_fake_dev_default (void);
diff --git a/tests/tod-drivers/README.md b/tests/tod-drivers/README.md
new file mode 100644
index 0000000..3afec6d
--- /dev/null
+++ b/tests/tod-drivers/README.md
@@ -0,0 +1,9 @@
+# TOD drivers to use for testing
+
+This directory is used by the test-suite to load and verify pre-built drivers.
+
+For main testing this directory should contain the "fake_test_dev" driver (AKA
+test-device-fake) built using the minimum libfprint TOD we want to support.
+
+In this way the library is loaded during tests and tested for all the upstream
+tests and particularly test-fpi-device.
diff --git a/tests/tod-drivers/libdevice-fake-tod-driver-x86_64.so b/tests/tod-drivers/libdevice-fake-tod-driver-x86_64.so
new file mode 100755
index 0000000..822f417
Binary files /dev/null and b/tests/tod-drivers/libdevice-fake-tod-driver-x86_64.so differ
