diff --git a/README.md b/README.md
index 5b8f01af..2ab86200 100644
--- a/README.md
+++ b/README.md
@@ -94,6 +94,18 @@ If you have problem building with Qt5 Multimedia or experience GStreamer run-tim
 
     qmake "CONFIG+=no_qtmultimedia_player"
 
+### Building with Qt WebEngine instead of Qt WebKit
+
+The Qt WebEngine-based version of GoldenDict is fresh and has not been comprehensively tested. Some aspects work better than
+in the Qt WebKit-based version, but there are downsides and not yet implemented features documented in the description of
+[this pull request](https://github.com/goldendict/goldendict/pull/1542).
+
+Make sure your Qt version is 5.15.2 or later, replace `libqt5webkit5-dev` with `qtwebengine5-dev` in the dependency list
+of the [Installing External Deps on Ubuntu Linux for Qt5](#installing-external-deps-on-ubuntu-linux-for-qt5) section
+and pass `"CONFIG+=use_qtwebengine"` to `qmake` in order to build this version:
+
+    qmake "CONFIG+=use_qtwebengine"
+
 <b>NB:</b> All additional settings for `qmake` that you need must be combined in one `qmake` launch, for example:
 
     qmake "CONFIG+=zim_support" "CONFIG+=no_extra_tiff_handler" "CONFIG+=no_ffmpeg_player"
@@ -113,7 +125,8 @@ To build GoldenDict with Visual Studio take one of next library packs and unpack
 
 To create project files for Visual Studio you can pass `"-tp vc"` option to `qmake`.
 
-Note: In Qt 5.6.0 and later the `Webkit` module was removed from official release builds. You should build it from sources to compile GoldenDict.
+Note: In Qt 5.6.0 and later the `Webkit` module was removed from official release builds.
+You should build it from sources to compile the Qt WebKit version of GoldenDict.
 
 
 ## Installation
diff --git a/about.cc b/about.cc
index 326185be..ad61a224 100644
--- a/about.cc
+++ b/about.cc
@@ -33,10 +33,16 @@ About::About( QWidget * parent ): QDialog( parent )
   QString compilerVersion = QLatin1String( "GCC " ) + QLatin1String( __VERSION__ );
 #endif
 
-  ui.qtVersion->setText( tr( "Based on Qt %1 (%2, %3 bit)" ).arg(
+  QString qtVersionText = tr( "Based on Qt %1 (%2, %3 bit)" ).arg(
                            QLatin1String( qVersion() ),
                            compilerVersion,
-                           QString::number( QSysInfo::WordSize ) ) );
+                           QString::number( QSysInfo::WordSize ) );
+#ifdef USE_QTWEBKIT
+  qtVersionText += QLatin1String( ", Qt WebKit" );
+#else
+  qtVersionText += QLatin1String( ", Qt WebEngine" );
+#endif
+  ui.qtVersion->setText( qtVersionText );
 
   QFile creditsFile( ":/CREDITS.txt" );
 
diff --git a/article-style-expand-optional-parts.css b/article-style-expand-optional-parts.css
new file mode 100644
index 00000000..9aa538c8
--- /dev/null
+++ b/article-style-expand-optional-parts.css
@@ -0,0 +1,14 @@
+:root
+{
+  --gd-page-background-color: ;
+}
+
+.dsl_opt
+{
+  display: inline;
+}
+
+.hidden_expand_opt
+{
+  display: none !important;
+}
diff --git a/article-style-st-babylon.css b/article-style-st-babylon.css
index 9eff7175..cc5d9a6f 100644
--- a/article-style-st-babylon.css
+++ b/article-style-st-babylon.css
@@ -1,3 +1,8 @@
+:root
+{
+  --gd-page-background-color: white;
+}
+
 html
 {
   background-color: white;
@@ -74,19 +79,19 @@ h3 {
 }
 
 .gdexpandicon {
-    background-image: url('qrcx://localhost/icons/expand_article.png');
+    background-image: url('qrc:///icons/expand_article.png');
 }
 
 .gdexpandicon:hover {
-    background-image: url('qrcx://localhost/icons/expand_article_hovered.png');
+    background-image: url('qrc:///icons/expand_article_hovered.png');
 }
 
 .gdcollapseicon {
-    background-image: url('qrcx://localhost/icons/collapse_article.png');
+    background-image: url('qrc:///icons/collapse_article.png');
 }
 
 .gdcollapseicon:hover {
-    background-image: url('qrcx://localhost/icons/collapse_article_hovered.png');
+    background-image: url('qrc:///icons/collapse_article_hovered.png');
 }
 
 .bglpos { color: black; font-weight: bold; font-size: 11px; background: #F0EDED; display: inline; }
diff --git a/article-style-st-lingoes-blue.css b/article-style-st-lingoes-blue.css
index eec74641..922e5d8e 100644
--- a/article-style-st-lingoes-blue.css
+++ b/article-style-st-lingoes-blue.css
@@ -1,3 +1,8 @@
+:root
+{
+  --gd-page-background-color: #EAF0F8;
+}
+
 body {
 	background: #EAF0F8;
 	margin: 0.3em;
@@ -109,19 +114,19 @@ a:hover {
 }
 
 .gdexpandicon {
-    background-image: url('qrcx://localhost/icons/expand_article.png');
+    background-image: url('qrc:///icons/expand_article.png');
 }
 
 .gdexpandicon:hover {
-    background-image: url('qrcx://localhost/icons/expand_article_hovered.png');
+    background-image: url('qrc:///icons/expand_article_hovered.png');
 }
 
 .gdcollapseicon {
-    background-image: url('qrcx://localhost/icons/collapse_article.png');
+    background-image: url('qrc:///icons/collapse_article.png');
 }
 
 .gdcollapseicon:hover {
-    background-image: url('qrcx://localhost/icons/collapse_article_hovered.png');
+    background-image: url('qrc:///icons/collapse_article_hovered.png');
 }
 
 .gdarticleseparator {
@@ -366,4 +371,4 @@ h3 {
 	border-width:1px;
 	background-color:#eeeeee;
 	padding: 8px 8px 8px 8px;
-} 
\ No newline at end of file
+}
diff --git a/article-style-st-lingoes.css b/article-style-st-lingoes.css
index fdae35d1..398c9e6e 100644
--- a/article-style-st-lingoes.css
+++ b/article-style-st-lingoes.css
@@ -1,3 +1,8 @@
+:root
+{
+  --gd-page-background-color: #fffef2;
+}
+
 a 
 {
   color: #2233bb;
@@ -78,19 +83,19 @@ body
 
 
 .gdexpandicon {
-  background-image: url('qrcx://localhost/icons/expand_article.png');
+  background-image: url('qrc:///icons/expand_article.png');
 }
 
 .gdexpandicon:hover {
-  background-image: url('qrcx://localhost/icons/expand_article_hovered.png');
+  background-image: url('qrc:///icons/expand_article_hovered.png');
 }
 
 .gdcollapseicon {
-  background-image: url('qrcx://localhost/icons/collapse_article.png');
+  background-image: url('qrc:///icons/collapse_article.png');
 }
 
 .gdcollapseicon:hover {
-  background-image: url('qrcx://localhost/icons/collapse_article_hovered.png');
+  background-image: url('qrc:///icons/collapse_article_hovered.png');
 }
 
 .gddictnamebodyseparator
diff --git a/article-style-st-lingvo.css b/article-style-st-lingvo.css
index b2e47958..76c11586 100644
--- a/article-style-st-lingvo.css
+++ b/article-style-st-lingvo.css
@@ -1,3 +1,8 @@
+:root
+{
+  --gd-page-background-color: white;
+}
+
 html
 {
   background-color: white;
diff --git a/article-style-st-modern.css b/article-style-st-modern.css
index bb5ba320..110fb700 100644
--- a/article-style-st-modern.css
+++ b/article-style-st-modern.css
@@ -1,3 +1,8 @@
+:root
+{
+  --gd-page-background-color: white;
+}
+
 html
 {
   background-color: white;
@@ -137,19 +142,19 @@ a:hover
 }
 
 .gdexpandicon {
-    background-image: url('qrcx://localhost/icons/expand_article.png');
+    background-image: url('qrc:///icons/expand_article.png');
 }
 
 .gdexpandicon:hover {
-    background-image: url('qrcx://localhost/icons/expand_article_hovered.png');
+    background-image: url('qrc:///icons/expand_article_hovered.png');
 }
 
 .gdcollapseicon {
-    background-image: url('qrcx://localhost/icons/collapse_article.png');
+    background-image: url('qrc:///icons/collapse_article.png');
 }
 
 .gdcollapseicon:hover {
-    background-image: url('qrcx://localhost/icons/collapse_article_hovered.png');
+    background-image: url('qrc:///icons/collapse_article_hovered.png');
 }
 
 /* The first headword in a (possibly) multi-headword DSL article */
diff --git a/article-style.css b/article-style.css
index cacb896b..c6cb1e61 100644
--- a/article-style.css
+++ b/article-style.css
@@ -1,5 +1,9 @@
 /******** Global, non-dictionary-specific classes ***********/
 
+:root
+{
+  --gd-page-background-color: #fefdeb;
+}
 
 body
 {
@@ -76,7 +80,7 @@ pre
 .gderrordesc
 {
   font-style: italic;
-  background: url("qrcx://localhost/icons/warning.png") center left no-repeat !important;
+  background: url("qrc:///icons/warning.png") center left no-repeat !important;
   padding-left: 22px !important;
   margin: 1em;
 }
@@ -499,7 +503,7 @@ div.xdxf
 .dsl_video .img
 {
   display: inline-block;
-  background: url('qrcx://localhost/icons/video.png');
+  background: url('qrc:///icons/video.png');
   background-repeat: no-repeat;
   /* Ugly hack since "vertical-align: middle;" looks _terrible_ in Qt4's webkit: */
   vertical-align: -30%;
@@ -1106,16 +1110,6 @@ div.xdxf
 ** http://style.cleverchimp.com/font_size_intervals/altintervals.html
 */
 
-/*
-body {
-	font: x-small sans-serif;
-	background: #f9f9f9 url(headbg.jpg) 0 0 no-repeat;
-	color: black;
-	margin: 0;
-	padding: 0;
-}
-*/
-
 /* scale back up to a sane default */
 .mwiki #globalWrapper {
 	font-size: 127%;
@@ -1215,7 +1209,6 @@ body {
 	list-style-type: square;
 	margin: .3em 0 0 1.5em;
 	padding: 0;
-	list-style-image: url(bullet.gif);
 }
 .mwiki ol {
 	line-height: 1.5em;
@@ -1726,7 +1719,6 @@ special external link styling */
 .mwiki .portlet ul {
 	line-height: 1.5em;
 	list-style-type: square;
-	list-style-image: url(bullet.gif);
 	font-size: 95%;
 }
 .mwiki .portlet li {
@@ -2902,7 +2894,7 @@ in bg url to hide it from iemac */
     width:16px;
     height:16px;
     vertical-align: text-bottom;
-    background-image:url('qrcx://localhost/icons/arrow.png');
+    background-image:url('qrc:///icons/arrow.png');
 }
 
 .gdcollapseicon {
@@ -2910,7 +2902,7 @@ in bg url to hide it from iemac */
     width:16px;
     height:16px;
     vertical-align: text-bottom;
-    background-image:url('qrcx://localhost/icons/downarrow.png');
+    background-image:url('qrc:///icons/downarrow.png');
 }
 
 /********** Slob dictionaries ***********/
diff --git a/article_maker.cc b/article_maker.cc
index a2a96a6b..56070323 100644
--- a/article_maker.cc
+++ b/article_maker.cc
@@ -7,7 +7,7 @@
 #include "utf8.hh"
 #include "wstring_qt.hh"
 #include <limits.h>
-#include <QFile>
+#include <QFileInfo>
 #include <QUrl>
 #include <QTextDocumentFragment>
 #include "folding.hh"
@@ -15,216 +15,516 @@
 #include "gddebug.hh"
 #include "qt4x5.hh"
 
+#include <algorithm>
+
+#ifndef USE_QTWEBKIT
+#include <QColor>
+#include <QFile>
+#include <QMessageBox>
+#include <QVarLengthArray>
+
+#include <cctype>
+#include <regex>
+#endif
+
 using std::vector;
 using std::string;
 using gd::wstring;
 using std::set;
 using std::list;
 
-ArticleMaker::ArticleMaker( vector< sptr< Dictionary::Class > > const & dictionaries_,
-                            vector< Instances::Group > const & groups_,
-                            QString const & displayStyle_,
-                            QString const & addonStyle_):
-  dictionaries( dictionaries_ ),
-  groups( groups_ ),
-  displayStyle( displayStyle_ ),
-  addonStyle( addonStyle_ ),
-  needExpandOptionalParts( true )
-, collapseBigArticles( true )
-, articleLimitSize( 500 )
-{
-}
+namespace {
 
-void ArticleMaker::setDisplayStyle( QString const & st, QString const & adst )
+void appendScripts( string & result )
 {
-  displayStyle = st;
-  addonStyle = adst;
+  result +=
+  // *blocking.js scripts block HTML parser, which is acceptable here,
+  // because the scripts are local, instantly available and fast.
+#ifdef USE_QTWEBKIT
+  // Evaluate webkit_blocking.js now to call gdArticleView.onJsPageInitStarted() ASAP.
+            "<script src='qrc:///scripts/webkit_blocking.js'></script>"
+#else
+  // Create QWebChannel now to make gdArticleView available ASAP.
+            "<script src='qrc:///qtwebchannel/qwebchannel.js'></script>"
+            "<script src='qrc:///scripts/webengine_blocking.js'></script>"
+#endif
+  // Start reading the deferred scripts early so that they are ready when needed.
+            "<script defer src='qrc:///scripts/deferred.js'></script>"
+#ifndef USE_QTWEBKIT
+  // Load webengine_deferred.js in the end because it calls gdArticleView.onJsPageInitFinished().
+            "<script defer src='qrc:///scripts/webengine_deferred.js'></script>"
+#endif
+            "<script>"
+            "const gdExpandArticleTitle = \"";
+  result += ArticleMaker::tr( "Expand article" ).toUtf8().constData();
+  result += "\";\n"
+            "const gdCollapseArticleTitle = \"";
+  result += ArticleMaker::tr( "Collapse article" ).toUtf8().constData();
+  result += "\";\n"
+            "</script>"
+            "<script src='qrc:///scripts/blocking.js'></script>"
+            "\n";
 }
 
-std::string ArticleMaker::makeHtmlHeader( QString const & word,
-                                          QString const & icon,
-                                          bool expandOptionalParts ) const
+class CssAppender
 {
-  string result =
-    "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">"
-    "<html><head>"
-    "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">";
+public:
+  /// @param needPageBackgroundColor_ whether findPageBackgroundColor() will be called.
+  explicit CssAppender( string & result_, bool needPageBackgroundColor_ ):
+    result( result_ ), needPageBackgroundColor( needPageBackgroundColor_ ), isPrintMedia( false )
+  {}
+
+  /// Style sheets appended after a call to this function apply only while printing.
+  /// @note: style sheets with media="print" are appended after uncoditional style sheets,
+  ///        because print-only CSS needs higher priority to override the style used for printing.
+  void startPrintMedia()
+  { isPrintMedia = true; }
+
+  void appendFile( QString const & fileName )
+  {
+    if( !QFileInfo( fileName ).isFile() )
+      return;
 
-  // Add a css stylesheet
+#ifndef USE_QTWEBKIT
+    // We are not looking for printed background color.
+    if( needPageBackgroundColor && !isPrintMedia )
+      cssFiles.push_back( fileName );
+#endif
 
+    result += "<link href=\"";
+    result += Html::escape( localFileNameToHtml( fileName ) );
+    result += "\" rel=\"stylesheet\" media=\"";
+    result += isPrintMedia ? "print" : "all";
+    result += "\" />\n";
+  }
+
+#ifndef USE_QTWEBKIT
+  static constexpr auto getPageBackgroundColorPropertyName()
+  { return QLatin1String( pageBackgroundColorPropertyName, pageBackgroundColorPropertyNameSize ); }
+
+  /// @return The page background color or an empty string if
+  ///         the background color could not be found in the style sheets.
+  /// @warning This function parses the style sheets that have been appended to @a result. Therefore it
+  ///          must be called after appending all style sheets that may override the page background color.
+  string findPageBackgroundColor( vector< QString > & unspecifiedColorFileNames ) const
   {
-    QFile builtInCssFile( ":/article-style.css" );
-    builtInCssFile.open( QFile::ReadOnly );
-    QByteArray css = builtInCssFile.readAll();
+    Q_ASSERT( needPageBackgroundColor );
 
-    if( !css.isEmpty() )
-    {
-      result += "\n<!-- Built-in css -->\n";
-      result += "<style type=\"text/css\" media=\"all\">\n";
-      result += css.data();
-      result += "</style>\n";
-    }
+    string backgroundColor;
 
-    if ( displayStyle.size() )
-    {
-      // Load an additional stylesheet
-      QFile builtInCssFile( QString( ":/article-style-st-%1.css" ).arg( displayStyle ) );
-      builtInCssFile.open( QFile::ReadOnly );
-      css = builtInCssFile.readAll();
-      if( !css.isEmpty() )
+    // Iterate in the reverse order because the CSS code lower in the page overrides.
+    std::find_if( cssFiles.crbegin(), cssFiles.crend(),
+                  [ &backgroundColor, &unspecifiedColorFileNames ]( QString const & fileName ) {
+      QFile cssFile( fileName );
+      if( !cssFile.open( QIODevice::ReadOnly | QIODevice::Text ) )
       {
-        result += "<!-- Built-in style css -->\n";
-        result += "<style type=\"text/css\" media=\"all\">\n";
-        result += css.data();
-        result += "</style>\n";
+        gdWarning( "Couldn't open CSS file \"%s\" for reading: %s (%d)", qUtf8Printable( fileName ),
+                   qUtf8Printable( cssFile.errorString() ), static_cast< int >( cssFile.error() ) );
+        return false;
       }
+
+      if( !findPageBackgroundColor( cssFile, backgroundColor ) )
+        unspecifiedColorFileNames.push_back( fileName );
+
+      // Empty backgroundColor means that this CSS file does not override page
+      // background color, in which case we look for it in the remaining CSS files.
+      return !backgroundColor.empty();
+    } );
+
+    return backgroundColor;
+  }
+#endif // USE_QTWEBKIT
+
+private:
+  static std::string localFileNameToHtml( QString const & fileName )
+  {
+    string result;
+    if( fileName.startsWith( QLatin1String( ":/" ) ) )
+    {
+      // Replace the local file resource prefix ":/" with "qrc:///" for the web page.
+      result = "qrc:///";
+      result += fileName.toUtf8().constData() + 2;
     }
+    else
+    {
+      // fileName must be a local filesystem path => convert it into a file URL.
+#ifdef Q_OS_WIN32
+      result = "file:///";
+#else
+      result = "file://";
+#endif
+      result += fileName.toUtf8().constData();
+    }
+    return result;
+  }
 
-    QFile cssFile( Config::getUserCssFileName() );
+  string & result;
+  bool const needPageBackgroundColor;
+  bool isPrintMedia;
+
+#ifndef USE_QTWEBKIT
+  static constexpr char pageBackgroundColorPropertyName[] = "--gd-page-background-color";
+  // - 1 accounts for the terminating null character.
+  static constexpr std::size_t pageBackgroundColorPropertyNameSize = sizeof( pageBackgroundColorPropertyName )
+                                                                      / sizeof( char ) - 1;
+
+  vector< QString > cssFiles;
+
+  /// Finds the page background color in @p cssFile.
+  /// First looks for the page background color CSS property. If the property specification
+  /// is missing, falls back to a slower search of the background color of the <body> element.
+  /// @param[out] backgroundColor is set to the page background color or to an empty string
+  ///             if the CSS file does not override page background color.
+  /// @return true if a valid page background color CSS property specification was found, false otherwise.
+  static bool findPageBackgroundColor( QFile & cssFile, string & backgroundColor )
+  {
+    Q_ASSERT( cssFile.isOpen() );
 
-    if ( cssFile.open( QFile::ReadOnly ) )
+    // TODO: remove the regex fallback, including this variable, all its uses and findBodyBackgroundColor(),
+    // once users have had some time to add the page background color property into their article style files.
+    string cssCode;
+
+    // At the time of writing, each line in built-in article style files fits into maxReasonableLineLength.
+    constexpr int maxReasonableLineLength = 212;
+    QVarLengthArray< char, maxReasonableLineLength > line( maxReasonableLineLength );
+    int offset = 0;
+
+    while( !cssFile.atEnd() )
     {
-      css = cssFile.readAll();
-      if( !css.isEmpty() )
+      int const maxSize = line.size() - offset;
+      int bytesRead = cssFile.readLine( line.data() + offset, maxSize );
+      if( bytesRead == -1 )
       {
-        result += "<!-- User css -->\n";
-        result += "<style type=\"text/css\" media=\"all\">\n";
-        result += css.data();
-        result += "</style>\n";
+        gdWarning( "Error while reading CSS file \"%s\": %s (%d)", qUtf8Printable( cssFile.fileName() ),
+                   qUtf8Printable( cssFile.errorString() ), static_cast< int >( cssFile.error() ) );
+        break;
       }
-    }
 
-    if( !addonStyle.isEmpty() )
-    {
-      QString name = Config::getStylesDir() + addonStyle
-                     + QDir::separator() + "article-style.css";
-      QFile addonCss( name );
-      if( addonCss.open( QFile::ReadOnly ) )
+      Q_ASSERT( bytesRead >= 0 );
+      Q_ASSERT( bytesRead < maxSize ); // QIODevice::readLine() reads up to a maximum of maxSize - 1 bytes.
+      if( bytesRead == maxSize - 1 && line[ line.size() - 2 ] != '\n' && !cssFile.atEnd() )
       {
-        css = addonCss.readAll();
-        if( !css.isEmpty() )
-        {
-          result += "<!-- Addon style css -->\n";
-          result += "<style type=\"text/css\" media=\"all\">\n";
-          result += css.data();
-          result += "</style>\n";
-        }
+        // This line is longer than line.size() => increase the buffer size until the entire line fits in.
+        Q_ASSERT( line.back() == 0 ); // A terminating '\0' byte is always appended to data.
+        offset = line.size() - 1; // Overwrite the terminating '\0' character during the next iteration.
+        line.resize( line.size() * 2 );
+        continue;
       }
+
+      bytesRead += offset;
+      Q_ASSERT( bytesRead < line.size() );
+      Q_ASSERT( line[ bytesRead ] == 0 ); // A terminating '\0' byte is always appended to data.
+      // We require the property and its value to be on the same line to be able to process the CSS file line by line.
+      if( findPageBackgroundColorProperty( line.data(), line.data() + bytesRead, backgroundColor ) )
+        return true;
+      offset = 0;
+
+      cssCode.append( line.data(), bytesRead );
     }
+    gdWarning( "Page background color specification is missing from CSS file \"%s\"",
+               qUtf8Printable( cssFile.fileName() ) );
+
+    backgroundColor = findBodyBackgroundColor( cssCode.data(), cssCode.data() + cssCode.size() );
+    return false;
+  }
+
+  static bool isSpace( char ch )
+  {
+    // The behavior of std::isspace() is undefined if the value of ch
+    // is not representable as unsigned char and is not equal to EOF.
+    return std::isspace( static_cast< unsigned char >( ch ) );
+  }
 
-    // Turn on/off expanding of article optional parts
-    if( expandOptionalParts )
+  /// Finds the page background color CSS property in [@p first, @p last).
+  /// @param[out] backgroundColor is set to the page background color if the CSS property is found, unchanged otherwise.
+  /// @note @p backgroundColor set to an empty string means that the CSS file does not override page background color.
+  /// @return true if a valid page background color CSS property specification was found, false otherwise.
+  static bool findPageBackgroundColorProperty( char const * first, char const * last, string & backgroundColor )
+  {
+    char const * it = std::search( first, last, pageBackgroundColorPropertyName,
+                                   pageBackgroundColorPropertyName + pageBackgroundColorPropertyNameSize );
+    if( it == last )
+      return false;
+    it += pageBackgroundColorPropertyNameSize;
+    Q_ASSERT( it <= last );
+
+    auto const skipWhitespace = [ &it, last ] {
+      it = std::find_if_not( it, last, isSpace );
+    };
+
+    skipWhitespace();
+    if( it == last || *it != ':' )
     {
-      result += "<!-- Expand optional parts css -->\n";
-      result += "<style type=\"text/css\" media=\"all\">\n";
-      result += "\n.dsl_opt\n{\n  display: inline;\n}\n\n.hidden_expand_opt\n{\n  display: none !important;\n}\n";
-      result += "</style>\n";
+      gdWarning( "Missing colon after %s CSS property name. Ignoring this malformed specification.",
+                 pageBackgroundColorPropertyName );
+      return false;
     }
+    ++it;
+    skipWhitespace();
 
-  }
+    char const * const colorBegin = it;
 
-  // Add print-only css
+    auto const isCssPropertyValueEnd = []( char ch ) {
+      return ch == ';' || ch == '}' || isSpace( ch );
+    };
+    it = std::find_if( it, last, isCssPropertyValueEnd );
 
+    backgroundColor.assign( colorBegin, it );
+    return true;
+  }
+
+  /// Finds the background color of the <body> element in [@p first, @p last).
+  /// @return the background color or an empty string if it could not be found.
+  static string findBodyBackgroundColor( char const * first, char const * last )
   {
-    QFile builtInCssFile( ":/article-style-print.css" );
-    builtInCssFile.open( QFile::ReadOnly );
-    QByteArray css = builtInCssFile.readAll();
-    if( !css.isEmpty() )
+    // This regular expression is simple and efficient. But the result is not always accurate:
+    // 1. The first word after "background:" is considered to be the color, even though this first word could
+    //    be something else, e.g. "border-box".
+    // 2. The code inside CSS comments (/*comment*/) is matched too, not skipped.
+    // Built-in and user-defined style sheets must take this simplified matching into account.
+    // On the bright side, the user can easily override the background color matched here by adding a comment
+    // like /* body{ background:#abcdef } */ at the end of the user-defined article-style.css file.
+    static std::regex const backgroundRegex( R"(\bbody\s*\{[^}]*\bbackground(?:|-color)\s*:\s*([^\s;}]+))",
+                      // CSS code is case-insensitive => regex::icase.
+                      // The regex object is reused (static) and the CSS code can be large => regex::optimize.
+                                             std::regex::icase | std::regex::optimize );
+
+    // Iterate over all matches and return the last one, because the CSS code lower in the page overrides.
+    string::const_iterator::difference_type position = -1, length;
+    for( std::cregex_iterator it( first, last, backgroundRegex ), end; it != end; ++it )
     {
-      result += "<!-- Built-in print css -->\n";
-      result += "<style type=\"text/css\" media=\"print\">\n";
-      result += css.data();
-      result += "</style>\n";
+      Q_ASSERT( it->size() == 2 );
+
+      position = it->position( 1 );
+      Q_ASSERT( position >= 0 );
+
+      length = it->length( 1 );
+      Q_ASSERT( length > 0 );
+      Q_ASSERT( first + position + length <= last );
     }
 
-    QFile cssFile( Config::getUserCssPrintFileName() );
+    if( position == -1 )
+      return {};
+    return string( first + position, first + position + length );
+  }
+#endif
+};
+
+#ifndef USE_QTWEBKIT
+constexpr char CssAppender::pageBackgroundColorPropertyName[];
+
+QString wrapInHtmlCodeElement( QLatin1String text )
+{
+  return QLatin1String( "<code>%1</code>" ).arg( text );
+}
+
+QString bodyElementHtmlCode()
+{
+  return wrapInHtmlCodeElement( QLatin1String{ "&lt;body&gt;" } );
+}
+
+QString htmlElementHtmlCode()
+{
+  return wrapInHtmlCodeElement( QLatin1String{ "&lt;html&gt;" } );
+}
+
+QString propertyNameHtmlCode()
+{
+  return wrapInHtmlCodeElement( CssAppender::getPageBackgroundColorPropertyName() );
+}
+
+QString missingSpecificationWarningMessage( vector< QString > const & unspecifiedColorFileNames )
+{
+  Q_ASSERT( !unspecifiedColorFileNames.empty() );
+
+  QString message = ArticleMaker::tr( "<p>Page background color specification is missing from the following CSS files:"
+                                      "</p>" ) + QLatin1String( "<pre>" );
+  for( auto const & fileName : unspecifiedColorFileNames )
+  {
+    message += QLatin1String( "<p style='margin: 0px;'>" );
+    message += fileName;
+    message += QLatin1String( "</p>" );
+  }
+  message += QLatin1String( "</pre>" );
+
+  message += ArticleMaker::tr( "<p>Please insert a page background color specification at the top (or close to the "
+                               "top) of each of these files. For example:</p>" );
+  // Recommend to define the page background color custom property on the :root pseudo-class to allow using it globally
+  // across the CSS file in the future. Do not recommend actually using the custom property value with
+  // `var(--gd-page-background-color)` for now. Custom CSS properties are not supported by Qt 5 WebKit, and it is
+  // important to maintain style sheet compatibility with the Qt WebKit version of GoldenDict while it is widely used.
+  message += QLatin1String( "<pre>:root\n{\n  %1: COLOR;\n}</pre>" )
+              .arg( CssAppender::getPageBackgroundColorPropertyName() );
+
+  message += ArticleMaker::tr( "<p>Replace %1 with the actual page background color specified in the CSS file, that is "
+                               "%2 or %3 background color. If the CSS file does not specify the page background color, "
+                               "replace %1 with an empty string (without quotes).</p>"
+                               "<p>Incorrect or missing page background color specification may cause article page "
+                               "background flashes.</p>"
+                               "<p>Supported page background color specification format is strict: quotes are not "
+                               "allowed, the property name %4 and its value must be on the same line. On the other "
+                               "hand, the surrounding declaration block does not matter to GoldenDict. The property "
+                               "specification can just as well be inside a CSS comment instead of the %5 pseudo-class "
+                               "block.</p>" )
+              .arg( wrapInHtmlCodeElement( QLatin1String{ "COLOR" } ), bodyElementHtmlCode(), htmlElementHtmlCode(),
+                    propertyNameHtmlCode(), wrapInHtmlCodeElement( QLatin1String{ ":root" } ) );
+
+  return message;
+}
+
+QString invalidColorWarningMessage( QString const & pageBackgroundColor )
+{
+  return ArticleMaker::tr( "<p>Invalid page background color is specified in the article style sheets:</p>" )
+         + QLatin1String( "<pre>%1</pre>" ).arg( pageBackgroundColor )
+         + ArticleMaker::tr( "<p>Set %1 to the actual page background color specified in the CSS file, that is %2 or "
+                             "%3 background color. If the CSS file does not specify the page background color, set %1 "
+                             "to an empty string (without quotes).</p>"
+                             "<p>Supported color value formats:</p><ul>"
+                             "<li>#RGB (each of R, G, and B is a single hex digit)</li>"
+                             "<li>#RRGGBB</li>"
+                             "<li>#AARRGGBB</li>"
+                             "<li>#RRRGGGBBB</li>"
+                             "<li>#RRRRGGGGBBBB</li>"
+                             "<li>A name from the list of colors defined in the list of <a href=\""
+                             "https://www.w3.org/TR/SVG11/types.html#ColorKeywords\">SVG color keyword names</a> "
+                             "provided by the World Wide Web Consortium; for example, %4 or %5.</li>"
+                             "<li>%6 - representing the absence of a color.</li></ul>" )
+            .arg( propertyNameHtmlCode(), bodyElementHtmlCode(), htmlElementHtmlCode(),
+                  wrapInHtmlCodeElement( QLatin1String{ "steelblue" } ),
+                  wrapInHtmlCodeElement( QLatin1String{ "gainsboro" } ),
+                  wrapInHtmlCodeElement( QLatin1String{ "transparent" } ) );
+}
+
+#endif // USE_QTWEBKIT
 
-    if ( cssFile.open( QFile::ReadOnly ) )
+} // unnamed namespace
+
+ArticleMaker::ArticleMaker( vector< sptr< Dictionary::Class > > const & dictionaries_,
+                            vector< Instances::Group > const & groups_,
+                            QString const & displayStyle_,
+                            QString const & addonStyle_,
+                            QWidget * dialogParent_ ):
+  dictionaries( dictionaries_ ),
+  groups( groups_ ),
+  displayStyle( displayStyle_ ),
+  addonStyle( addonStyle_ ),
+#ifndef USE_QTWEBKIT
+  dialogParent( dialogParent_ ),
+#endif
+  needExpandOptionalParts( true )
+, collapseBigArticles( true )
+, articleLimitSize( 500 )
+{
+  Q_UNUSED( dialogParent_ )
+}
+
+void ArticleMaker::setDisplayStyle( QString const & st, QString const & adst )
+{
+  displayStyle = st;
+  addonStyle = adst;
+}
+
+#ifndef USE_QTWEBKIT
+QColor ArticleMaker::colorFromString( string const & pageBackgroundColor ) const
+{
+  if( pageBackgroundColor.empty() )
+  {
+    Q_ASSERT_X( false, Q_FUNC_INFO, "The default built-in style sheet :/article-style.css is unconditionally appended "
+                                    "and specifies a valid page background color, which is parsed correctly." );
+    gdWarning( "Couldn't find the page background color in the article style sheets." );
+    return QColor();
+  }
+
+  auto const pageBackgroundColorQString = QString::fromUtf8( pageBackgroundColor.c_str() );
+  QColor color( pageBackgroundColorQString );
+  if( !color.isValid() )
+  {
+    gdWarning( "Found invalid page background color in the article style sheets: \"%s\"", pageBackgroundColor.c_str() );
+    if( !hasShownBackgroundColorWarningMessage )
     {
-      css = cssFile.readAll();
-      if( !css.isEmpty() )
-      {
-        result += "<!-- User print css -->\n";
-        result += "<style type=\"text/css\" media=\"print\">\n";
-        result += css.data();
-        result += "</style>\n";
-        css.clear();
-      }
+      hasShownBackgroundColorWarningMessage = true;
+      QMessageBox::warning( dialogParent, "GoldenDict", invalidColorWarningMessage( pageBackgroundColorQString ) );
     }
+    return QColor();
+  }
 
-    if( !addonStyle.isEmpty() )
+  GD_DPRINTF( "Found page background color in the article style sheets: \"%s\" = %s\n", pageBackgroundColor.c_str(),
+              // Print the result of QColor's nontrivial parsing of pageBackgroundColor string.
+              // Print the alpha component only if the color is not fully opaque.
+              qPrintable( color.name( color.alpha() == 255 ? QColor::HexRgb : QColor::HexArgb ) ) );
+  return color;
+}
+#endif
+
+void ArticleMaker::appendCss( string & result, bool expandOptionalParts, QColor * pageBackgroundColor ) const
+{
+  CssAppender cssAppender( result, static_cast< bool >( pageBackgroundColor ) );
+
+  cssAppender.appendFile( ":/article-style.css" );
+  if( !displayStyle.isEmpty() )
+    cssAppender.appendFile( QString( ":/article-style-st-%1.css" ).arg( displayStyle ) );
+  cssAppender.appendFile( Config::getUserCssFileName() );
+  if( !addonStyle.isEmpty() )
+    cssAppender.appendFile( Config::getStylesDir() + addonStyle + QDir::separator() + "article-style.css" );
+
+  // Turn on/off expanding of article optional parts
+  if( expandOptionalParts )
+    cssAppender.appendFile( ":/article-style-expand-optional-parts.css" );
+
+  cssAppender.startPrintMedia();
+
+  cssAppender.appendFile( ":/article-style-print.css" );
+  cssAppender.appendFile( Config::getUserCssPrintFileName() );
+  if( !addonStyle.isEmpty() )
+    cssAppender.appendFile( Config::getStylesDir() + addonStyle + QDir::separator() + "article-style-print.css" );
+
+#ifdef USE_QTWEBKIT
+  Q_ASSERT( !pageBackgroundColor );
+#else
+  if( pageBackgroundColor )
+  {
+    vector< QString > unspecifiedColorFileNames;
+    auto const backgroundColorString = cssAppender.findPageBackgroundColor( unspecifiedColorFileNames );
+    if( !unspecifiedColorFileNames.empty() && !hasShownBackgroundColorWarningMessage )
     {
-      QString name = Config::getStylesDir() + addonStyle
-                     + QDir::separator() + "article-style-print.css";
-      QFile addonCss( name );
-      if( addonCss.open( QFile::ReadOnly ) )
-      {
-        css = addonCss.readAll();
-        if( !css.isEmpty() )
-        {
-          result += "<!-- Addon style print css -->\n";
-          result += "<style type=\"text/css\" media=\"print\">\n";
-          result += css.data();
-          result += "</style>\n";
-        }
-      }
+      hasShownBackgroundColorWarningMessage = true;
+      QMessageBox::warning( dialogParent, "GoldenDict",
+                            missingSpecificationWarningMessage( unspecifiedColorFileNames ) );
     }
+    *pageBackgroundColor = colorFromString( backgroundColorString );
   }
+#endif
+}
+
+std::string ArticleMaker::makeHtmlHeader( QString const & word,
+                                          QString const & icon,
+                                          bool expandOptionalParts,
+                                          QColor * pageBackgroundColor ) const
+{
+  string result =
+    "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">"
+    "<html><head>"
+    "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">";
+
+  appendScripts( result );
+  appendCss( result, expandOptionalParts, pageBackgroundColor );
 
   result += "<title>" + Html::escape( Utf8::encode( gd::toWString( word ) ) ) + "</title>";
 
   // This doesn't seem to be much of influence right now, but we'll keep
   // it anyway.
   if ( icon.size() )
-    result += "<link rel=\"icon\" type=\"image/png\" href=\"qrcx://localhost/flags/" + Html::escape( icon.toUtf8().data() ) + "\" />\n";
-
-  result += "<script type=\"text/javascript\">"
-            "var gdAudioLinks = { first: null, current: null };"
-            "function gdMakeArticleActive( newId ) {"
-            "if ( gdCurrentArticle != 'gdfrom-' + newId ) {"
-            "el=document.getElementById( gdCurrentArticle ); el.className = el.className.replace(' gdactivearticle','');"
-            "el=document.getElementById( 'gdfrom-' + newId ); el.className = el.className + ' gdactivearticle';"
-            "gdCurrentArticle = 'gdfrom-' + newId; gdAudioLinks.current = newId;"
-            "articleview.onJsActiveArticleChanged(gdCurrentArticle); } }"
-            "var overIframeId = null;"
-            "function gdSelectArticle( id ) {"
-            "var selection = window.getSelection(); var range = document.createRange();"
-            "range.selectNodeContents(document.getElementById('gdfrom-' + id));"
-            "selection.removeAllRanges(); selection.addRange(range); }"
-            "function processIframeMouseOut() { overIframeId = null; top.focus(); }"
-            "function processIframeMouseOver( newId ) { overIframeId = newId; }"
-            "function processIframeClick() { if( overIframeId != null ) { overIframeId = overIframeId.replace( 'gdexpandframe-', '' ); gdMakeArticleActive( overIframeId ) } }"
-            "function init() { window.addEventListener('blur', processIframeClick, false); }"
-            "window.addEventListener('load', init, false);"
-            "function gdExpandOptPart( expanderId, optionalId ) {  var d1=document.getElementById(expanderId); var i = 0; if( d1.alt == '[+]' ) {"
-            "d1.alt = '[-]'; d1.src = 'qrcx://localhost/icons/collapse_opt.png'; for( i = 0; i < 1000; i++ ) { var d2=document.getElementById( optionalId + i ); if( !d2 ) break; d2.style.display='inline'; } }"
-            "else { d1.alt = '[+]'; d1.src = 'qrcx://localhost/icons/expand_opt.png'; for( i = 0; i < 1000; i++ ) { var d2=document.getElementById( optionalId + i ); if( !d2 ) break; d2.style.display='none'; } } };"
-            "function gdExpandArticle( id ) { elem = document.getElementById('gdarticlefrom-'+id); ico = document.getElementById('expandicon-'+id); art=document.getElementById('gdfrom-'+id);"
-            "ev=window.event; t=null;"
-            "if(ev) t=ev.target || ev.srcElement;"
-            "if(elem.style.display=='inline' && t==ico) {"
-            "elem.style.display='none'; ico.className='gdexpandicon';"
-            "art.className = art.className+' gdcollapsedarticle';"
-            "nm=document.getElementById('gddictname-'+id); nm.style.cursor='pointer';"
-            "if(ev) ev.stopPropagation(); ico.title=''; nm.title=\"";
-  result += tr( "Expand article" ).toUtf8().data();
-  result += "\" } else if(elem.style.display=='none') {"
-            "elem.style.display='inline'; ico.className='gdcollapseicon';"
-            "art.className=art.className.replace(' gdcollapsedarticle','');"
-            "nm=document.getElementById('gddictname-'+id); nm.style.cursor='default';"
-            "nm.title=''; ico.title=\"";
-  result += tr( "Collapse article").toUtf8().data();
-  result += "\" } }"
-            "function gdCheckArticlesNumber() {"
-            "elems=document.getElementsByClassName('gddictname');"
-            "if(elems.length == 1) {"
-              "el=elems.item(0); s=el.id.replace('gddictname-','');"
-              "el=document.getElementById('gdfrom-'+s);"
-              "if(el && el.className.search('gdcollapsedarticle')>0) gdExpandArticle(s);"
-            "} }"
-            "</script>";
-
-  result += "</head><body>";
+    result += "<link rel=\"icon\" type=\"image/png\" href=\"qrc:///flags/" + Html::escape( icon.toUtf8().data() ) + "\" />\n";
+
+  result += "</head><body"
+#ifndef USE_QTWEBKIT
+  // Qt WebEngine API does not provide a way to check whether a mouse click occurs on a page
+  // proper or on its scrollbar. We are only interested in clicks on the page contents
+  // within <body>. Listen to such mouse events and send messages from JavaScript to C++.
+            " onMouseDown='gdBodyMouseDown(event);'"
+            " onMouseUp='gdBodyMouseUp(event);'"
+#endif
+            ">";
 
   return result;
 }
@@ -235,11 +535,7 @@ std::string ArticleMaker::makeNotFoundBody( QString const & word,
   string result( "<div class=\"gdnotfound\"><p>" );
 
   QString str( word );
-  if( str.isRightToLeft() )
-  {
-    str.insert( 0, (ushort)0x202E ); // RLE, Right-to-Left Embedding
-    str.append( (ushort)0x202C ); // PDF, POP DIRECTIONAL FORMATTING
-  }
+  Folding::prepareToEmbedRTL( str );
 
   if ( word.size() )
     result += tr( "No translation for <b>%1</b> was found in group <b>%2</b>." ).
@@ -405,10 +701,15 @@ sptr< Dictionary::DataRequest > ArticleMaker::makeNotFoundTextFor(
   return r;
 }
 
-sptr< Dictionary::DataRequest > ArticleMaker::makeEmptyPage() const
+string ArticleMaker::makeBlankPageHtmlCode( QColor * pageBackgroundColor ) const
 {
-  string result = makeHtmlHeader( tr( "(untitled)" ), QString(), true ) +
+  return makeHtmlHeader( tr( "(untitled)" ), QString(), true, pageBackgroundColor ) +
     "</body></html>";
+}
+
+sptr< Dictionary::DataRequest > ArticleMaker::makeBlankPage() const
+{
+  string const result = makeBlankPageHtmlCode();
 
   sptr< Dictionary::DataRequestInstant > r =
       new Dictionary::DataRequestInstant( true );
@@ -422,7 +723,7 @@ sptr< Dictionary::DataRequest > ArticleMaker::makeEmptyPage() const
 sptr< Dictionary::DataRequest > ArticleMaker::makePicturePage( string const & url ) const
 {
   string result = makeHtmlHeader( tr( "(picture)" ), QString(), true )
-                  + "<a href=\"javascript: if(history.length>2) history.go(-1)\">"
+                  + "<a href=\"javascript: history.back();\">"
                   + "<img src=\"" + url + "\" /></a>"
                   + "</body></html>";
 
@@ -593,6 +894,15 @@ int ArticleRequest::findEndOfCloseDiv( const QString &str, int pos )
   }
 }
 
+static void appendGdMakeArticleActiveOn( string & result, char const * jsEvent, string const & dictionaryId )
+{
+  result += " on";
+  result += jsEvent;
+  result += "=\"gdMakeArticleActive('";
+  result += dictionaryId;
+  result += "');\"";
+}
+
 void ArticleRequest::bodyFinished()
 {
   if ( bodyDone )
@@ -630,13 +940,7 @@ void ArticleRequest::bodyFinished()
         {
           head += "</div></div><div style=\"clear:both;\"></div><span class=\"gdarticleseparator\"></span>";
         }
-        else
-        {
-          // This is the first article
-          head += "<script type=\"text/javascript\">"
-                  "var gdCurrentArticle=\"" + gdFrom  + "\"; "
-                  "articleview.onJsActiveArticleChanged(gdCurrentArticle)</script>";
-        }
+        // else: this is the first article
 
         bool collapse = false;
         if( articleSizeLimit >= 0 )
@@ -676,17 +980,26 @@ void ArticleRequest::bodyFinished()
         }
 
         string jsVal = Html::escapeForJavaScript( dictId );
-        head += "<script type=\"text/javascript\">var gdArticleContents; "
-          "if ( !gdArticleContents ) gdArticleContents = \"" + jsVal +" \"; "
-          "else gdArticleContents += \"" + jsVal + " \";</script>";
 
         head += string( "<div class=\"gdarticle" ) +
+#ifdef USE_QTWEBKIT
+                // gdCurrentArticleLoaded() initializes " gdactivearticle" in the Qt WebEngine version.
                 ( closePrevSpan ? "" : " gdactivearticle" ) +
+#endif
                 ( collapse ? " gdcollapsedarticle" : "" ) +
-                "\" id=\"" + gdFrom +
-                "\" onClick=\"gdMakeArticleActive( '" + jsVal + "' );\" " +
-                " onContextMenu=\"gdMakeArticleActive( '" + jsVal + "' );\""
-                + ">";
+                "\" id=\"" + gdFrom + '"';
+
+        // Make the article active on left, middle or right mouse button click.
+        appendGdMakeArticleActiveOn( head, "click", jsVal );
+        // A right mouse button click triggers only "contextmenu" JavaScript event.
+        appendGdMakeArticleActiveOn( head, "contextmenu", jsVal );
+        // In the Qt WebKit version both a left and a middle mouse button click triggers "click" JavaScript event.
+        // In the Qt WebEngine version a left mouse button click triggers "click", a middle - "auxclick" event.
+#ifndef USE_QTWEBKIT
+        appendGdMakeArticleActiveOn( head, "auxclick", jsVal );
+#endif
+
+        head += '>';
 
         closePrevSpan = true;
 
@@ -698,7 +1011,7 @@ void ArticleRequest::bodyFinished()
           + "/dicticon.png\"></span><span class=\"gdfromprefix\">"  +
           Html::escape( tr( "From " ).toUtf8().data() ) + "</span><span class=\"gddicttitle\">" +
           Html::escape( activeDict->getName().c_str() ) + "</span>"
-          + "<span class=\"collapse_expand_area\"><img src=\"qrcx://localhost/icons/blank.png\" class=\""
+          + "<span class=\"collapse_expand_area\"><img src=\"qrc:///icons/blank.png\" class=\""
           + ( collapse ? "gdexpandicon" : "gdcollapseicon" )
           + "\" id=\"expandicon-" + Html::escape( dictId ) + "\""
           + ( collapse ? "" : string( " title=\"" ) + tr( "Collapse article" ).toUtf8().data() + "\"" )
@@ -726,7 +1039,9 @@ void ArticleRequest::bodyFinished()
 
         size_t offset = data.size();
 
-        data.resize( data.size() + head.size() + ( req.dataSize() > 0 ? req.dataSize() : 0 ) );
+        string const articleEnding = "<script>gdArticleLoaded(\"" + gdFrom + "\");</script>";
+
+        data.resize( data.size() + head.size() + ( req.dataSize() > 0 ? req.dataSize() : 0 ) + articleEnding.size() );
 
         memcpy( &data.front() + offset, head.data(), head.size() );
 
@@ -741,6 +1056,8 @@ void ArticleRequest::bodyFinished()
           gdWarning( "getDataSlice error: %s\n", e.what() );
         }
 
+        std::copy( articleEnding.begin(), articleEnding.end(), data.end() - articleEnding.size() );
+
         wasUpdated = true;
 
         foundAnyDefinitions = true;
diff --git a/article_maker.hh b/article_maker.hh
index 98fa0dbc..56d1cf4f 100644
--- a/article_maker.hh
+++ b/article_maker.hh
@@ -13,6 +13,9 @@
 #include "instances.hh"
 #include "wordfinder.hh"
 
+class QColor;
+class QWidget;
+
 /// This class generates the article's body for the given lookup request
 class ArticleMaker: public QObject
 {
@@ -23,6 +26,12 @@ class ArticleMaker: public QObject
 
   QString displayStyle, addonStyle;
 
+#ifndef USE_QTWEBKIT
+  QWidget * dialogParent;
+  /// Ensures that a page background color specification warning message appears at most once per GoldenDict launch.
+  mutable bool hasShownBackgroundColorWarningMessage = false;
+#endif
+
   bool needExpandOptionalParts;
   bool collapseBigArticles;
   int articleLimitSize;
@@ -36,7 +45,8 @@ public:
   ArticleMaker( std::vector< sptr< Dictionary::Class > > const & dictionaries,
                 std::vector< Instances::Group > const & groups,
                 QString const & displayStyle,
-                QString const & addonStyle);
+                QString const & addonStyle,
+                QWidget * dialogParent_ );
 
   /// Sets the display style to use for any new requests. This affects the
   /// choice of the stylesheet file.
@@ -63,8 +73,14 @@ public:
   /// known that there's no translation.
   sptr< Dictionary::DataRequest > makeNotFoundTextFor( QString const & word, QString const & group ) const;
 
-  /// Creates an 'untitled' page. The result is guaranteed to be instant.
-  sptr< Dictionary::DataRequest > makeEmptyPage() const;
+  /// Creates an 'untitled' page and returns its contents.
+  /// @param pageBackgroundColor if not null, is set to the page's background color
+  ///        specified in style sheets or to an invalid color in case of error.
+  /// @warning pageBackgroundColor must be a null pointer in the Qt WebKit version.
+  std::string makeBlankPageHtmlCode( QColor * pageBackgroundColor = 0 ) const;
+
+  /// Create an 'untitled' page
+  sptr< Dictionary::DataRequest > makeBlankPage() const;
 
   /// Create page with one picture
   sptr< Dictionary::DataRequest > makePicturePage( std::string const & url ) const;
@@ -81,9 +97,16 @@ public:
 
 private:
 
+#ifndef USE_QTWEBKIT
+  QColor colorFromString( std::string const & pageBackgroundColor ) const;
+#endif
+
+  /// Appends CSS style sheets to @p result.
+  void appendCss( std::string & result, bool expandOptionalParts, QColor * pageBackgroundColor ) const;
+
   /// Makes everything up to and including the opening body tag.
   std::string makeHtmlHeader( QString const & word, QString const & icon,
-                              bool expandOptionalParts ) const;
+                              bool expandOptionalParts, QColor * pageBackgroundColor = 0 ) const;
 
   /// Makes the html body for makeNotFoundTextFor()
   static std::string makeNotFoundBody( QString const & word, QString const & group );
diff --git a/article_netmgr.cc b/article_netmgr.cc
index 00f31059..b1e3634c 100644
--- a/article_netmgr.cc
+++ b/article_netmgr.cc
@@ -10,12 +10,18 @@
 #include <QUrl>
 
 #include "article_netmgr.hh"
+#include "article_maker.hh"
 #include "wstring_qt.hh"
 #include "gddebug.hh"
 #include "qt4x5.hh"
 
+#ifndef USE_QTWEBKIT
+#include <QThread>
+#endif
+
 using std::string;
 
+#ifdef USE_QTWEBKIT
 #if QT_VERSION >= 0x050300 // Qt 5.3+
 
   // SecurityWhiteList
@@ -91,7 +97,7 @@ using std::string;
 
     connect( baseReply, SIGNAL( encrypted() ), this, SIGNAL( encrypted() ) );
 
-    connect( baseReply, SIGNAL( finished() ), this, SIGNAL( finished() ) );
+    connect( baseReply, SIGNAL( finished() ), this, SLOT( finishedSlot() ) );
 
     connect( baseReply, SIGNAL( preSharedKeyAuthenticationRequired( QSslPreSharedKeyAuthenticator * ) ),
              this, SIGNAL( preSharedKeyAuthenticationRequired( QSslPreSharedKeyAuthenticator * ) ) );
@@ -204,7 +210,16 @@ using std::string;
     return size;
   }
 
+  void AllowFrameReply::finishedSlot()
+  {
+#if QT_VERSION >= QT_VERSION_CHECK( 4, 8, 0 )
+    setFinished( true );
 #endif
+    emit finished();
+  }
+
+#endif // QT_VERSION
+#endif // USE_QTWEBKIT
 
 namespace
 {
@@ -238,10 +253,22 @@ namespace
   }
 }
 
+string ArticleNetworkAccessManager::makeBlankPage( QColor * pageBackgroundColor ) const
+{
+  return articleMaker.makeBlankPageHtmlCode( pageBackgroundColor );
+}
+
 QNetworkReply * ArticleNetworkAccessManager::createRequest( Operation op,
                                                             QNetworkRequest const & req,
                                                             QIODevice * outgoingData )
 {
+  // Don't wrap in AllowFrameReply replies for local URL schemes used by the initial blank and Welcome! pages
+  // to prevent the warning "QIODevice::read (QNetworkReplyFileImpl): device not open" at GoldenDict start
+  // as AllowFrameReply::baseReply is not open when AllowFrameReply::readDataFromBase() is invoked then.
+
+  if( req.url().scheme() == QLatin1String( "qrc" ) )
+    return QNetworkAccessManager::createRequest( op, req, outgoingData ); // bypass AllowFrameReply
+
   QNetworkRequest localReq( req );
 
   if( ( localReq.url().scheme() == "gdlookup" || localReq.url().scheme() == "http" ) && localReq.url().host() == "upload.wikimedia.org" )
@@ -257,8 +284,14 @@ QNetworkReply * ArticleNetworkAccessManager::createRequest( Operation op,
   {
     if ( localReq.url().scheme() == "qrcx" )
     {
-      // We have to override the local load policy for the qrc scheme, hence
-      // we use qrcx and redirect it here back to qrc
+      // We had to override the local load policy for the qrc URL scheme until QWebSecurityOrigin::addLocalScheme() was
+      // introduced in Qt 4.6. Hence we used a custom qrcx URL scheme and redirected it here back to qrc. Qt versions
+      // older than 4.6 are no longer supported, so GoldenDict itself no longer uses the qrcx scheme. However, qrcx has
+      // been used for many years in our built-in article styles, and so may appear in user-defined article styles.
+      // TODO: deprecate (print a warning or show a warning message box) and eventually remove support for the obsolete
+      // qrcx URL scheme. A recent commit "Add support for qrc:// URL scheme" is the first one where the qrc scheme
+      // works correctly. So the deprecation has to wait until older GoldenDict versions become rarely used.
+
       QUrl newUrl( localReq.url() );
 
       newUrl.setScheme( "qrc" );
@@ -269,6 +302,7 @@ QNetworkReply * ArticleNetworkAccessManager::createRequest( Operation op,
       return QNetworkAccessManager::createRequest( op, localReq, outgoingData );
     }
 
+#ifdef USE_QTWEBKIT
 #if QT_VERSION >= 0x050300 // Qt 5.3+
     // Workaround of same-origin policy
     if( ( localReq.url().scheme().startsWith( "http" ) || localReq.url().scheme() == "ftp" )
@@ -301,14 +335,21 @@ QNetworkReply * ArticleNetworkAccessManager::createRequest( Operation op,
         }
       }
     }
-#endif
+#endif // QT_VERSION
+#endif // USE_QTWEBKIT
 
     QString contentType;
 
     sptr< Dictionary::DataRequest > dr = getResource( localReq.url(), contentType );
 
     if ( dr.get() )
-      return new ArticleResourceReply( this, localReq, dr, contentType );
+    {
+      ArticleResourceReply * const reply = new ArticleResourceReply( this, localReq, dr, contentType );
+#ifndef USE_QTWEBKIT
+      reply->setStreamingDeviceWorkarounds( streamingDeviceWorkarounds );
+#endif
+      return reply;
+    }
   }
 
   // Check the Referer. If the user has opted-in to block elements from external
@@ -330,10 +371,14 @@ QNetworkReply * ArticleNetworkAccessManager::createRequest( Operation op,
     {
       gdWarning( "Blocking element \"%s\"\n", localReq.url().toEncoded().data() );
 
-      return new BlockedNetworkReply( this );
+      return new BlockedNetworkReply( localReq, this );
     }
   }
 
+  // TODO (Qt WebEngine): obtain a dictionary that contains file:// links for testing and
+  // make this code work in the Qt WebEngine version. Currently it does not work because
+  // GoldenDict does not install an URL scheme handler for the standard "file" scheme.
+  // This looks like an adjustment of a relative path to a dictionary in the portable version.
   if( localReq.url().scheme() == "file" )
   {
     // Check file presence and adjust path if necessary
@@ -350,6 +395,8 @@ QNetworkReply * ArticleNetworkAccessManager::createRequest( Operation op,
 
       return QNetworkAccessManager::createRequest( op, localReq, outgoingData );
     }
+
+    return QNetworkAccessManager::createRequest( op, localReq, outgoingData ); // bypass AllowFrameReply
   }
 
   QNetworkReply *reply = 0;
@@ -374,7 +421,7 @@ QNetworkReply * ArticleNetworkAccessManager::createRequest( Operation op,
 #endif
   }
 
-#if QT_VERSION >= 0x050300 // Qt 5.3+
+#if defined( USE_QTWEBKIT ) && QT_VERSION >= 0x050300 // Qt 5.3+
   return op == QNetworkAccessManager::GetOperation
          || op == QNetworkAccessManager::HeadOperation ? new AllowFrameReply( reply ) : reply;
 #else
@@ -400,7 +447,11 @@ sptr< Dictionary::DataRequest > ArticleNetworkAccessManager::getResource(
     contentType = "text/html";
 
     if ( Qt4x5::Url::queryItemValue( url, "blank" ) == "1" )
-      return articleMaker.makeEmptyPage();
+    {
+      // This branch is never taken in the Qt WebEngine and Qt 4 WebKit versions.
+      // It is taken in the Qt 5 WebKit version only when the initial blank page is reloaded.
+      return articleMaker.makeBlankPage();
+    }
 
     Config::InputPhrase phrase ( Qt4x5::Url::queryItemValue( url, "word" ).trimmed(),
                                  Qt4x5::Url::queryItemValue( url, "punctuation_suffix" ) );
@@ -469,6 +520,7 @@ sptr< Dictionary::DataRequest > ArticleNetworkAccessManager::getResource(
         {
             if( url.scheme() == "gico" )
             {
+                contentType = "image/png";
                 QByteArray bytes;
                 QBuffer buffer(&bytes);
                 buffer.open(QIODevice::WriteOnly);
@@ -534,6 +586,7 @@ ArticleResourceReply::ArticleResourceReply( QObject * parent,
   QString const & contentType ):
   QNetworkReply( parent ), req( req_ ), alreadyRead( 0 )
 {
+  setUrl( netReq.url() );
   setRequest( netReq );
 
   setOpenMode( ReadOnly );
@@ -590,6 +643,26 @@ qint64 ArticleResourceReply::bytesAvailable() const
   return avail - alreadyRead + QNetworkReply::bytesAvailable();
 }
 
+#ifndef USE_QTWEBKIT
+bool ArticleResourceReply::atEnd() const
+{
+  if( streamingDeviceWorkarounds != StreamingDeviceWorkarounds::None )
+  {
+    // QWebEngineUrlRequestJob finishes and is destroyed as soon as QIODevice::atEnd() returns true.
+    // QNetworkReply::atEnd() returns true while bytesAvailable() returns 0.
+    // Return false if the data request is not finished to work around always-blank web page.
+    return req->isFinished() && QNetworkReply::atEnd();
+  }
+  return QNetworkReply::atEnd();
+}
+#endif
+
+void ArticleResourceReply::close()
+{
+  req->cancel();
+  QNetworkReply::close();
+}
+
 qint64 ArticleResourceReply::readData( char * out, qint64 maxSize )
 {
   // From the doc: "This function might be called with a maxSize of 0,
@@ -607,6 +680,20 @@ qint64 ArticleResourceReply::readData( char * out, qint64 maxSize )
     return finished ? -1 : 0;
 
   qint64 left = avail - alreadyRead;
+
+#ifndef USE_QTWEBKIT
+  if( streamingDeviceWorkarounds == StreamingDeviceWorkarounds::AtEndAndReadData && left == 0 && !finished )
+  {
+    // Work around endlessly repeated useless calls to readData(). The sleep duration is a tradeoff.
+    // On the one hand, lowering the duration reduces CPU usage. On the other hand, overly long
+    // sleep duration reduces page content update frequency in the web view.
+    // Waiting on a condition variable is more complex and actually works worse than
+    // simple fixed-duration sleeping, because the web view is not updated until
+    // the data request is finished if readData() returns only when new data arrives.
+    QThread::msleep( 30 );
+    return 0;
+  }
+#endif
   
   qint64 toRead = maxSize < left ? maxSize : left;
 
@@ -643,11 +730,16 @@ void ArticleResourceReply::finishedSlot()
 #endif
   }
 
-  finished();
+#if QT_VERSION >= QT_VERSION_CHECK( 4, 8, 0 )
+  setFinished( true );
+#endif
+  emit finished();
 }
 
-BlockedNetworkReply::BlockedNetworkReply( QObject * parent ): QNetworkReply( parent )
+BlockedNetworkReply::BlockedNetworkReply( QNetworkRequest const & request, QObject * parent ):
+  QNetworkReply( parent )
 {
+  setUrl( request.url() );
   setError( QNetworkReply::ContentOperationNotPermittedError, "Content Blocked" );
 
   connect( this, SIGNAL( finishedSignal() ), this, SLOT( finishedSlot() ),
@@ -660,5 +752,9 @@ BlockedNetworkReply::BlockedNetworkReply( QObject * parent ): QNetworkReply( par
 void BlockedNetworkReply::finishedSlot()
 {
   emit readyRead();
+
+#if QT_VERSION >= QT_VERSION_CHECK( 4, 8, 0 )
+  setFinished( true );
+#endif
   emit finished();
 }
diff --git a/article_netmgr.hh b/article_netmgr.hh
index e075474a..210caa08 100644
--- a/article_netmgr.hh
+++ b/article_netmgr.hh
@@ -6,21 +6,26 @@
 
 #include <QtNetwork>
 
+#ifdef USE_QTWEBKIT
 #if QT_VERSION >= 0x050300  // Qt 5.3+
 #include <QWebSecurityOrigin>
 #include <QSet>
 #include <QMap>
 #include <QPair>
-#endif
+#endif // QT_VERSION
+#endif // USE_QTWEBKIT
 
 #include "dictionary.hh"
-#include "article_maker.hh"
 
 using std::vector;
 
+class ArticleMaker;
+class QColor;
+
 /// A custom QNetworkAccessManager version which fetches images from the
 /// dictionaries when requested.
 
+#ifdef USE_QTWEBKIT
 #if QT_VERSION >= 0x050300  // Qt 5.3+
 
 // White lists for QWebSecurityOrigin
@@ -119,6 +124,20 @@ protected:
   { return baseReply->readLine( data, maxSize ); }
   qint64 writeData( const char * data, qint64 maxSize )
   { return baseReply->write( data, maxSize ); }
+
+private slots:
+  void finishedSlot();
+};
+#endif // QT_VERSION
+#endif // USE_QTWEBKIT
+
+#ifndef USE_QTWEBKIT
+/// Signifies workarounds for QTBUG-106461 needed in the current run-time Qt WebEngine version.
+enum class StreamingDeviceWorkarounds
+{
+  None, ///< The bug is completely fixed in Qt WebEngine 6.4.1.
+  AtEndOnly, ///< Busy waiting is fixed in Qt WebEngine 5.15.11 and 6.4.0.
+  AtEndAndReadData
 };
 #endif
 
@@ -128,9 +147,13 @@ class ArticleNetworkAccessManager: public QNetworkAccessManager
   ArticleMaker const & articleMaker;
   bool const & disallowContentFromOtherSites;
   bool const & hideGoldenDictHeader;
-#if QT_VERSION >= 0x050300  // Qt 5.3+
+#if defined( USE_QTWEBKIT ) && QT_VERSION >= 0x050300  // Qt 5.3+
   Origins allOrigins;
 #endif
+#ifndef USE_QTWEBKIT
+  StreamingDeviceWorkarounds streamingDeviceWorkarounds = StreamingDeviceWorkarounds::None;
+#endif
+
 public:
 
   ArticleNetworkAccessManager( QObject * parent,
@@ -145,6 +168,14 @@ public:
     hideGoldenDictHeader( hideGoldenDictHeader_ )
   {}
 
+#ifndef USE_QTWEBKIT
+  void setStreamingDeviceWorkarounds( StreamingDeviceWorkarounds workarounds )
+  { streamingDeviceWorkarounds = workarounds; }
+#endif
+
+  /// @return articleMaker.makeBlankPageHtmlCode( pageBackgroundColor )
+  std::string makeBlankPage( QColor * pageBackgroundColor = 0 ) const;
+
   /// Tries handling any kind of internal resources referenced by dictionaries.
   /// If it succeeds, the result is a dictionary request object. Otherwise, an
   /// empty pointer is returned.
@@ -165,6 +196,9 @@ class ArticleResourceReply: public QNetworkReply
 
   sptr< Dictionary::DataRequest > req;
   qint64 alreadyRead;
+#ifndef USE_QTWEBKIT
+  StreamingDeviceWorkarounds streamingDeviceWorkarounds = StreamingDeviceWorkarounds::None;
+#endif
 
 public:
 
@@ -175,12 +209,23 @@ public:
 
   ~ArticleResourceReply();
 
+#ifndef USE_QTWEBKIT
+  void setStreamingDeviceWorkarounds( StreamingDeviceWorkarounds workarounds )
+  { streamingDeviceWorkarounds = workarounds; }
+#endif
+
 protected:
 
   virtual qint64 bytesAvailable() const;
 
+#ifndef USE_QTWEBKIT
+  bool atEnd() const override;
+#endif
+
   virtual void abort()
   {}
+  virtual void close();
+
   virtual qint64 readData( char * data, qint64 maxSize );
 
   // We use the hackery below to work around the fact that we need to emit
@@ -205,7 +250,7 @@ class BlockedNetworkReply: public QNetworkReply
 
 public:
 
-  BlockedNetworkReply( QObject * parent );
+  explicit BlockedNetworkReply( QNetworkRequest const & request, QObject * parent );
 
   virtual qint64 readData( char *, qint64 )
   {
diff --git a/article_urlschemehandler.cc b/article_urlschemehandler.cc
new file mode 100644
index 00000000..5bf0f51a
--- /dev/null
+++ b/article_urlschemehandler.cc
@@ -0,0 +1,194 @@
+/* This file is (c) 2022 Igor Kushnir <igorkuo@gmail.com>
+ * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */
+
+#ifndef USE_QTWEBKIT
+
+#include "article_urlschemehandler.hh"
+
+#include "article_netmgr.hh"
+#include "gddebug.hh"
+
+#include <QByteArray>
+#include <QMetaEnum>
+#include <QMimeDatabase>
+#include <QNetworkReply>
+#include <QNetworkRequest>
+#include <QPointer>
+#include <QWebEngineProfile>
+#include <QWebEngineUrlRequestJob>
+#include <QWebEngineUrlScheme>
+
+#include <array>
+#include <utility>
+
+namespace {
+
+/// @return the names of GoldenDict's custom URL schemes handled by ArticleUrlSchemeHandler.
+auto const & handledUrlSchemeNames()
+{
+  // Note that the remaining custom URL scheme names - "bword", "gdprg" and "gdtts" - do not
+  // belong in this list, because they are handled only in ArticleView::linkHovered() and
+  // ArticleView::openLink(). ArticleNetworkAccessManager does not know about these schemes.
+
+  static std::array< QByteArray, 7 > const names {
+    QByteArrayLiteral( "bres" ),
+    QByteArrayLiteral( "gdau" ),
+    QByteArrayLiteral( "gdlookup" ),
+    QByteArrayLiteral( "gdpicture" ),
+    QByteArrayLiteral( "gdvideo" ),
+    QByteArrayLiteral( "gico" ),
+    QByteArrayLiteral( "qrcx" )
+  };
+  return names;
+}
+
+QNetworkRequest networkRequestFromJob( QWebEngineUrlRequestJob & job )
+{
+  QNetworkRequest request( job.requestUrl() );
+  auto const headers = job.requestHeaders();
+  for( auto it = headers.constKeyValueBegin(), end = headers.constKeyValueEnd(); it != end; ++it )
+    request.setRawHeader( it->first, it->second );
+  return request;
+}
+
+QWebEngineUrlRequestJob::Error jobErrorFromNetworkError( QNetworkReply::NetworkError networkError )
+{
+  switch( networkError )
+  {
+    case QNetworkReply::HostNotFoundError:
+    case QNetworkReply::ProxyNotFoundError:
+    case QNetworkReply::ContentNotFoundError:
+    case QNetworkReply::ContentGoneError:
+      return QWebEngineUrlRequestJob::UrlNotFound;
+    case QNetworkReply::ProtocolUnknownError:
+    case QNetworkReply::ProtocolInvalidOperationError:
+      return QWebEngineUrlRequestJob::UrlInvalid;
+    case QNetworkReply::OperationCanceledError:
+      return QWebEngineUrlRequestJob::RequestAborted;
+    case QNetworkReply::ConnectionRefusedError:
+    case QNetworkReply::BackgroundRequestNotAllowedError:
+    case QNetworkReply::ProxyConnectionRefusedError:
+    case QNetworkReply::ProxyAuthenticationRequiredError:
+    case QNetworkReply::ContentAccessDenied:
+    case QNetworkReply::ContentOperationNotPermittedError:
+    case QNetworkReply::AuthenticationRequiredError:
+      return QWebEngineUrlRequestJob::RequestDenied;
+    default:
+      return QWebEngineUrlRequestJob::RequestFailed;
+  }
+}
+
+void reportError( QNetworkReply::NetworkError networkError, QNetworkReply const & reply, QWebEngineUrlRequestJob * job )
+{
+  gdWarning( "Error while requesting URL %s: %s (%s)", qUtf8Printable( reply.url().toString() ),
+             qUtf8Printable( reply.errorString() ),
+             QMetaEnum::fromType< decltype( networkError ) >().valueToKey( networkError ) );
+
+  if( job )
+    job->fail( jobErrorFromNetworkError( networkError ) );
+}
+
+bool respondToUrlRequest( QWebEngineUrlRequestJob * job, QNetworkReply * reply )
+{
+  Q_ASSERT( job );
+  Q_ASSERT( reply );
+
+  auto const networkError = reply->error();
+  if( networkError != QNetworkReply::NoError )
+  {
+    reportError( networkError, *reply, job );
+    return false;
+  }
+
+  auto contentType = reply->header( QNetworkRequest::ContentTypeHeader ).toByteArray();
+  if( contentType.isEmpty() )
+  {
+    // GoldenDict does not always set the Content-Type header => fall back to guessing the MIME type from the URL.
+    contentType = QMimeDatabase().mimeTypeForUrl( reply->url() ).name().toUtf8();
+  }
+
+  job->reply( contentType, reply );
+  return true;
+}
+
+} // unnamed namespace
+
+void registerArticleUrlSchemes()
+{
+  // When unhandled URL schemes - "gdprg", "gdtts", "bword" - are registered, a blank page is
+  // loaded when the user clicks on a link that points to such an URL => don't register them.
+
+  for( auto const & name : handledUrlSchemeNames() )
+  {
+    QWebEngineUrlScheme scheme( name );
+    scheme.setSyntax( QWebEngineUrlScheme::Syntax::Host );
+    // Register dictionary schemes as local to make file:// and qrc:// links work in articles.
+    scheme.setFlags( QWebEngineUrlScheme::SecureScheme
+                     | QWebEngineUrlScheme::LocalScheme
+                     | QWebEngineUrlScheme::LocalAccessAllowed );
+    QWebEngineUrlScheme::registerScheme( scheme );
+  }
+}
+
+ArticleUrlSchemeHandler::ArticleUrlSchemeHandler( ArticleNetworkAccessManager & netMgr ) :
+  QWebEngineUrlSchemeHandler( &netMgr ),
+  articleNetMgr( netMgr )
+{
+}
+
+void ArticleUrlSchemeHandler::install( QWebEngineProfile & profile )
+{
+  for( auto const & name : handledUrlSchemeNames() )
+    profile.installUrlSchemeHandler( name, this );
+}
+
+void ArticleUrlSchemeHandler::requestStarted( QWebEngineUrlRequestJob * job )
+{
+  if( job->requestMethod() != "GET" )
+  {
+    gdWarning( "Unsupported custom scheme request method: %s. Initiator: %s. URL: %s.",
+               job->requestMethod().constData(), qUtf8Printable( job->initiator().toString() ),
+               qUtf8Printable( job->requestUrl().toString() ) );
+    job->fail( QWebEngineUrlRequestJob::UrlInvalid );
+    return;
+  }
+
+  auto * const reply = articleNetMgr.get( networkRequestFromJob( *job ) );
+
+  // Respond to the request immediately in order to show topmost articles as
+  // soon as they become available, without waiting for all articles to load.
+  // job uses the QIODevice interface of reply in another thread. *reply can be one of the following:
+  // - a qrc:// QNetworkAccessManager's QNetworkReply;
+  // - QNetworkAccessManager's QNetworkReply for a GoldenDict's custom URL scheme (an error page);
+  // - ArticleResourceReply;
+  // - BlockedNetworkReply.
+  // Hopefully the QNetworkAccessManager's replies support such usage. ArticleResourceReply is designed
+  // to be thread-safe in this scenario. BlockedNetworkReply is trivial and obviously thread-safe.
+
+  if( !respondToUrlRequest( job, reply ) )
+  {
+    // A network error occurred and respondToUrlRequest() handled it.
+    // Destroy the no longer needed reply as soon as it finishes.
+    connect( reply, &QNetworkReply::finished, reply, &QObject::deleteLater );
+    return;
+  }
+
+  QPointer< QWebEngineUrlRequestJob > jobPointer( job );
+
+  connect( reply, &QNetworkReply::errorOccurred, reply, [ reply, jobPointer ]( QNetworkReply::NetworkError code ) {
+    reportError( code, *reply, jobPointer );
+  } );
+
+  // Deliberately don't use job as context in this connection: if job is destroyed
+  // before reply is finished, reply would be leaked. Using reply as context does
+  // not impact behavior, but silences Clazy checker connect-3arg-lambda (level1).
+  connect( reply, &QNetworkReply::finished, reply, [ reply, jobPointer = std::move( jobPointer ) ] {
+    // At this point reply is no longer written to and can be safely destroyed once job ends reading from it.
+    if( jobPointer )
+      connect( jobPointer, &QObject::destroyed, reply, &QObject::deleteLater );
+    else
+      reply->deleteLater();
+  } );
+}
+
+#endif // USE_QTWEBKIT
diff --git a/article_urlschemehandler.hh b/article_urlschemehandler.hh
new file mode 100644
index 00000000..401955db
--- /dev/null
+++ b/article_urlschemehandler.hh
@@ -0,0 +1,38 @@
+/* This file is (c) 2022 Igor Kushnir <igorkuo@gmail.com>
+ * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */
+
+#ifndef ARTICLE_URLSCHEMEHANDLER_HH_INCLUDED
+#define ARTICLE_URLSCHEMEHANDLER_HH_INCLUDED
+
+#ifndef USE_QTWEBKIT
+
+#include <QWebEngineUrlSchemeHandler>
+
+class ArticleNetworkAccessManager;
+class QWebEngineProfile;
+
+/// Register custom article URL schemes.
+/// This function should be called early at application startup, before creating any
+/// Qt WebEngine classes, i.e. before a QGuiApplication or QApplication instance is created.
+/// @sa QWebEngineUrlScheme
+void registerArticleUrlSchemes();
+
+class ArticleUrlSchemeHandler: public QWebEngineUrlSchemeHandler
+{
+  Q_OBJECT
+public:
+  /// @note netMgr becomes the parent of this handler object.
+  explicit ArticleUrlSchemeHandler( ArticleNetworkAccessManager & netMgr );
+
+  /// Register this handler for custom article URL schemes in @p profile.
+  void install( QWebEngineProfile & profile );
+
+  void requestStarted( QWebEngineUrlRequestJob * job ) override;
+
+private:
+  ArticleNetworkAccessManager & articleNetMgr;
+};
+
+#endif // USE_QTWEBKIT
+
+#endif // ARTICLE_URLSCHEMEHANDLER_HH_INCLUDED
diff --git a/articleinspector.cc b/articleinspector.cc
index 2d1c2006..012974bd 100644
--- a/articleinspector.cc
+++ b/articleinspector.cc
@@ -1,6 +1,6 @@
-#include "articleinspector.hh"
+#ifdef USE_QTWEBKIT
 
-#if QT_VERSION >= 0x040600
+#include "articleinspector.hh"
 
 #include <algorithm>
 
@@ -53,4 +53,4 @@ void ArticleInspector::showEvent( QShowEvent * event )
   QWebInspector::showEvent( event );
 }
 
-#endif // QT_VERSION
+#endif // USE_QTWEBKIT
diff --git a/articleinspector.hh b/articleinspector.hh
index 97f0b593..e6011573 100644
--- a/articleinspector.hh
+++ b/articleinspector.hh
@@ -1,9 +1,12 @@
 #ifndef ARTICLEINSPECTOR_HH
 #define ARTICLEINSPECTOR_HH
 
-#include <QtGlobal>
+// TODO (Qt WebKit): drop ArticleInspector and code that uses it in ArticleWebView, share the cleaner
+// alternative implementation in ArticleWebPage with the Qt WebEngine version once Qt 4 is no longer
+// supported. The problem with Qt 4 is: destroying an article inspector when it is closed, then
+// creating another one for the same page causes a crash in QWebInspector::setPage().
 
-#if QT_VERSION >= 0x040600
+#ifdef USE_QTWEBKIT
 
 #include <QWebInspector>
 #include <list>
@@ -32,6 +35,6 @@ private:
   static std::list< ArticleInspector * > openedInspectors;
 };
 
-#endif // QT_VERSION
+#endif // USE_QTWEBKIT
 
 #endif // ARTICLEINSPECTOR_HH
diff --git a/articleview.cc b/articleview.cc
index e7158ec2..8dfe8736 100644
--- a/articleview.cc
+++ b/articleview.cc
@@ -4,13 +4,13 @@
 #include "articleview.hh"
 #include <map>
 #include <QMessageBox>
-#include <QWebHitTestResult>
 #include <QMenu>
 #include <QDesktopServices>
-#include <QWebHistory>
 #include <QClipboard>
 #include <QKeyEvent>
 #include <QFileDialog>
+#include "articlewebpage.hh"
+#include "webkit_or_webengine.hh"
 #include "folding.hh"
 #include "wstring_qt.hh"
 #include "webmultimediadownload.hh"
@@ -21,9 +21,22 @@
 #include "gestures.hh"
 #include "fulltextsearch.hh"
 
-#if QT_VERSION >= 0x040600
+#ifdef USE_QTWEBKIT
 #include <QWebElement>
 #include <QWebElementCollection>
+#include <QWebHistory>
+#include <QWebHitTestResult>
+#else
+#include <QColor>
+#include <QWebChannel>
+#include <QWebEngineContextMenuData>
+#include <QWebEngineFindTextResult>
+#include <QWebEngineHistory>
+#include <QWebEngineProfile>
+#include <QWebEngineScript>
+#include <QWebEngineScriptCollection>
+
+#include <utility>
 #endif
 
 #if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
@@ -61,8 +74,39 @@ public:
     QObject( &view ), articleView( view )
   {}
 
-  Q_INVOKABLE void onJsActiveArticleChanged( QString const & id )
+public slots:
+#ifdef USE_QTWEBKIT
+  void onJsPageInitStarted()
+  { articleView.onJsPageInitStarted(); }
+
+  void onJsActiveArticleChanged( QString const & id )
   { articleView.onJsActiveArticleChanged( id ); }
+#else
+  void onJsPageInitStarted( QStringList const & loadedArticles, QStringList const & loadedAudioLinks,
+                            int activeArticleIndex, bool hasPageInitFinished, QDateTime const & pageTimestamp )
+  {
+    articleView.onJsPageInitStarted( loadedArticles, loadedAudioLinks,
+                                     activeArticleIndex, hasPageInitFinished, pageTimestamp );
+  }
+
+  void onJsPageInitFinished()
+  { articleView.onJsPageInitFinished(); }
+
+  void onJsActiveArticleChanged( QString const & id, QDateTime const & currentArticleTimestamp )
+  { articleView.onJsActiveArticleChanged( id, currentArticleTimestamp ); }
+
+  void onJsFirstLeftButtonMouseDown()
+  { articleView.onJsFirstLeftButtonMouseDown(); }
+
+  void onJsDoubleClicked( QString const & imageUrl )
+  { articleView.onJsDoubleClicked( imageUrl ); }
+#endif
+
+  void onJsArticleLoaded( QString const & id, QString const & audioLink, bool isActive )
+  { articleView.onJsArticleLoaded( id, audioLink, isActive ); }
+
+  void onJsLocationHashChanged()
+  { articleView.onJsLocationHashChanged(); }
 
 private:
   ArticleView & articleView;
@@ -194,12 +238,14 @@ public:
 
 /// End of DiacriticsHandler class
 
+#ifdef USE_QTWEBKIT
 static QVariant evaluateJavaScriptVariableSafe( QWebFrame * frame, const QString & variable )
 {
   return frame->evaluateJavaScript(
         QString( "( typeof( %1 ) !== 'undefined' && %1 !== undefined ) ? %1 : null;" )
         .arg( variable ) );
 }
+#endif
 
 namespace {
 
@@ -217,6 +263,11 @@ QString dictionaryIdFromScrollTo( QString const & scrollTo )
   return scrollTo.mid( scrollToPrefixLength );
 }
 
+WebPage::FindFlags caseSensitivityFindFlags( bool matchCase )
+{
+  return matchCase ? WebPage::FindCaseSensitively : WebPage::FindFlags();
+}
+
 QString searchStatusMessageNoMatches()
 {
   return ArticleView::tr( "Phrase not found" );
@@ -230,8 +281,171 @@ QString searchStatusMessage( int activeMatch, int matchCount )
   return ArticleView::tr( "%1 of %2 matches" ).arg( activeMatch ).arg( matchCount );
 }
 
+std::string makeBlankPage( ArticleNetworkAccessManager const & articleNetMgr, WebPage & webPage )
+{
+#ifdef USE_QTWEBKIT
+  Q_UNUSED( webPage )
+  return articleNetMgr.makeBlankPage();
+#else
+  // Loading the default blank page instantly via QWebEnginePage::setHtml() alone is not sufficient to prevent
+  // white background flashes when the background color in the current article style is not white. The white
+  // background is visible for a particularly long time when a large page is loaded in a new foreground tab.
+  // Setting QWebEnginePage::backgroundColor to Qt::transparent replaces the white background flashes with gray
+  // background flashes. Eliminate the flashes by finding the page background color in the article style sheets and
+  // assigning it to QWebEnginePage::backgroundColor. See also the documentation for QWebEnginePage::backgroundColor.
+  QColor pageBackgroundColor;
+  auto blankPage = articleNetMgr.makeBlankPage( &pageBackgroundColor );
+  if( pageBackgroundColor.isValid() )
+    webPage.setBackgroundColor( pageBackgroundColor );
+  return blankPage;
+#endif
+}
+
+QLatin1String javaScriptBool( bool value )
+{
+  return QLatin1String( value ? "true" : "false" );
+}
+
+#ifndef USE_QTWEBKIT
+/// @return the string representation of @p date in the ISO 8601 format required by JavaScript Date constructor.
+/// @note Qt::ISODateWithMs format is used to include milliseconds. The alternative Qt::ISODate format's
+///       one-second precision is definitely too coarse for timestamp-based synchronization.
+/// @note A JavaScript function, connected to a C++ signal with a QDateTime parameter, receives a value of the type
+///       String rather than of the expected type Date in Qt 5.15.5. Explicitly sending date&time strings in the
+///       required format will keep working correctly even if the type conversion issue is fixed in a future Qt version.
+QString javaScriptDateString( QDateTime const & date )
+{
+  return date.toString( Qt::ISODateWithMs );
+}
+
+QString pageReloadingScriptName()
+{
+  return QStringLiteral( "PageReloading" );
+}
+
+QString pageReloadingScriptSourceCode( QString const & currentArticle, bool scrollToCurrentArticle )
+{
+  return QLatin1String( "const gdCurrentArticleBeforePageReloading = '%1';\n"
+                        "const gdScrollToCurrentArticleAfterPageReloading = %2;" )
+      .arg( currentArticle, javaScriptBool( scrollToCurrentArticle ) );
+}
+
+QWebEngineScript createScript( QString const & name, QString const & sourceCode )
+{
+  QWebEngineScript script;
+  script.setInjectionPoint( QWebEngineScript::DocumentCreation );
+  script.setRunsOnSubFrames( false );
+  script.setWorldId( QWebEngineScript::MainWorld );
+
+  script.setName( name );
+  script.setSourceCode( sourceCode );
+
+  return script;
+}
+
+QWebEngineScript createPageReloadingScript()
+{
+  return createScript( pageReloadingScriptName(), pageReloadingScriptSourceCode( QString{}, false ) );
+}
+
+QString variableDeclarationFromAssignmentScript( QString const & assignmentScript )
+{
+  return QLatin1String( "let " ) + assignmentScript;
+}
+
+QString profilePreferencesScriptName()
+{
+  return QStringLiteral( "ProfilePreferences" );
+}
+
+QString selectWordBySingleClickAssignmentScript( bool selectWordBySingleClick )
+{
+  return QLatin1String( "gdSelectWordBySingleClick = %1;" ).arg( javaScriptBool( selectWordBySingleClick ) );
+}
+
+bool profilePreferencesChanged( Config::Preferences const & oldPreferences, Config::Preferences const & newPreferences )
+{
+  return oldPreferences.selectWordBySingleClick != newPreferences.selectWordBySingleClick;
+}
+
+QString profilePreferencesScriptSourceCode( Config::Preferences const & preferences )
+{
+  return variableDeclarationFromAssignmentScript( selectWordBySingleClickAssignmentScript(
+                                                    preferences.selectWordBySingleClick ) );
+}
+
+/// QUrl::StripTrailingSlash does not remove a slash if it is the only character in the path.
+/// gdlookup URL's path is either empty or equal to a slash, depending on representation. Consider such paths matching.
+bool pathsMatch( QUrl const & a, QUrl const & b )
+{
+  auto const isEmptyOrSlash = []( QString const & str ) {
+    return str.isEmpty() || str == QLatin1Char( '/' );
+  };
+  return a.path() == b.path() || ( isEmptyOrSlash( a.path() ) && isEmptyOrSlash( b.path() ) );
+}
+
+bool urlsOrWordsMatch( QUrl const & a, QUrl const & b )
+{
+  if( !pathsMatch( a, b ) )
+    return false;
+
+  constexpr auto formattingOptions = QUrl::RemovePath | QUrl::RemoveFragment;
+
+  if( a.matches( b, formattingOptions ) )
+    return true;
+
+  static const QLatin1String lookupScheme( "gdlookup" );
+  auto const wordQueryItem = []( QUrl const & url ) {
+    return QUrlQuery{ url }.queryItemValue( QStringLiteral( "word" ) );
+  };
+
+  return a.scheme() == lookupScheme && b.scheme() == lookupScheme
+          && a.matches( b, formattingOptions | QUrl::RemoveQuery )
+          && wordQueryItem( a ).compare( wordQueryItem( b ), Qt::CaseInsensitive ) == 0;
+}
+#endif // USE_QTWEBKIT
+
 } // unnamed namespace
 
+#ifndef USE_QTWEBKIT
+class ArticleView::MouseEventInfo
+{
+public:
+  void assign( QObject * target_, QMouseEvent const & event )
+  {
+    Q_ASSERT( target_ );
+
+    target = target_;
+    localPos = event.localPos();
+    windowPos = event.windowPos();
+    screenPos = event.screenPos();
+    buttons = event.buttons();
+    modifiers = event.modifiers();
+  }
+
+  void invalidate()
+  { target = nullptr; }
+
+  bool isValid() const
+  { return target != nullptr; }
+
+  void synthesize( QEvent::Type type, Qt::MouseButton button ) const
+  {
+    QMouseEvent event( type, localPos, windowPos, screenPos, button, buttons, modifiers,
+                       Qt::MouseEventSynthesizedByApplication );
+    QApplication::sendEvent( target, &event );
+  }
+
+private:
+  QObject * target = nullptr;
+  QPointF localPos;
+  QPointF windowPos;
+  QPointF screenPos;
+  Qt::MouseButtons buttons;
+  Qt::KeyboardModifiers modifiers;
+};
+#endif
+
 QString ArticleView::scrollToFromDictionaryId( QString const & dictionaryId )
 {
   Q_ASSERT( !isScrollTo( dictionaryId ) );
@@ -239,10 +453,13 @@ QString ArticleView::scrollToFromDictionaryId( QString const & dictionaryId )
 }
 
 ArticleView::ArticleView( QWidget * parent, ArticleNetworkAccessManager & nm,
+#ifndef USE_QTWEBKIT
+                          QWebEngineProfile & webEngineProfile,
+#endif
                           AudioPlayerPtr const & audioPlayer_,
                           std::vector< sptr< Dictionary::Class > > const & allDictionaries_,
                           Instances::Groups const & groups_, bool popupView_,
-                          Config::Class const & cfg_,
+                          Config::Class & cfg_,
                           QAction & openSearchAction_,
                           QAction * dictionaryBarToggled_,
                           GroupComboBox const * groupComboBox_ ):
@@ -264,6 +481,7 @@ ArticleView::ArticleView( QWidget * parent, ArticleNetworkAccessManager & nm,
   inspectAction( this ),
   openSearchAction( openSearchAction_ ),
   searchIsOpened( false ),
+  isLoading( false ),
   dictionaryBarToggled( dictionaryBarToggled_ ),
   groupComboBox( groupComboBox_ ),
   ftsSearchIsOpened( false ),
@@ -272,7 +490,17 @@ ArticleView::ArticleView( QWidget * parent, ArticleNetworkAccessManager & nm,
 {
   ui.setupUi( this );
 
-  ui.definition->setUp( const_cast< Config::Class * >( &cfg ) );
+  ArticleWebPage * const webPage = new ArticleWebPage(
+#ifndef USE_QTWEBKIT
+                                                        *this,
+                                                        cfg_,
+                                                        &webEngineProfile,
+#endif
+                                                        ui.definition );
+  ui.definition->setPage( webPage );
+#ifdef USE_QTWEBKIT
+  ui.definition->setUp( &cfg_ );
+#endif
 
   goBackAction.setShortcut( QKeySequence( "Alt+Left" ) );
   ui.definition->addAction( &goBackAction );
@@ -284,26 +512,51 @@ ArticleView::ArticleView( QWidget * parent, ArticleNetworkAccessManager & nm,
   connect( &goForwardAction, SIGNAL( triggered() ),
            this, SLOT( forward() ) );
 
-  ui.definition->pageAction( QWebPage::Copy )->setShortcut( QKeySequence::Copy );
-  ui.definition->addAction( ui.definition->pageAction( QWebPage::Copy ) );
+  QAction * const copyAction = ui.definition->pageAction( WebPage::Copy );
+  copyAction->setShortcut( QKeySequence::Copy );
+  ui.definition->addAction( copyAction );
 
-  QAction * selectAll = ui.definition->pageAction( QWebPage::SelectAll );
+  QAction * selectAll = ui.definition->pageAction( WebPage::SelectAll );
   selectAll->setShortcut( QKeySequence::SelectAll );
   selectAll->setShortcutContext( Qt::WidgetWithChildrenShortcut );
   ui.definition->addAction( selectAll );
 
   ui.definition->setContextMenuPolicy( Qt::CustomContextMenu );
 
+#ifdef USE_QTWEBKIT
+  // ArticleWebPage always delegates all links in the Qt WebEngine version.
   ui.definition->page()->setLinkDelegationPolicy( QWebPage::DelegateAllLinks );
 
+  // ArticleUrlSchemeHandler implements this using articleNetMgr in the Qt WebEngine version.
   ui.definition->page()->setNetworkAccessManager( &articleNetMgr );
 
+  // QWebView::loadFinished() is emitted immediately after the JavaScript load event, which always
+  // occurs after the page's JavaScript code finishes executing, so at the time of its emission
+  // onJsArticleLoaded() has already obtained the data required by loadFinished(). An exception:
+  // loadFinished() for the initial Welcome! page is emitted before the page's JavaScript code finishes
+  // executing. This exception is not a problem in practice as the Welcome! page contains neither
+  // dictionary articles nor audio links, so onJsArticleLoaded() isn't called at all on this page.
+  // Calling ArticleView::loadFinished() before QWebView::loadFinished() is emitted, for example,
+  // as soon as the page's JavaScript code finishes executing, breaks scrolling to current article
+  // after ArticleView::reload(), i.e. causes a wrong vertical scroll position.
   connect( ui.definition, SIGNAL( loadFinished( bool ) ),
            this, SLOT( loadFinished( bool ) ) );
 
   attachToJavaScript();
   connect( ui.definition->page()->mainFrame(), SIGNAL( javaScriptWindowObjectCleared() ),
            this, SLOT( attachToJavaScript() ) );
+#else
+  auto * const webChannel = new QWebChannel( webPage );
+  webPage->setWebChannel( webChannel, QWebEngineScript::MainWorld );
+  webChannel->registerObject( QStringLiteral( "gdArticleView" ), jsProxy );
+
+  webPage->scripts().insert( createPageReloadingScript() );
+
+  connect( webPage, &QWebEnginePage::findTextFinished, this, &ArticleView::findTextFinished );
+
+  // QWebEnginePage always highlights all occurences, and this cannot be disabled => hide the useless button.
+  ui.highlightAllButton->hide();
+#endif // USE_QTWEBKIT
 
   connect( ui.definition, SIGNAL( titleChanged( QString const & ) ),
            this, SLOT( handleTitleChanged( QString const & ) ) );
@@ -314,13 +567,18 @@ ArticleView::ArticleView( QWidget * parent, ArticleNetworkAccessManager & nm,
   connect( ui.definition, SIGNAL( customContextMenuRequested( QPoint const & ) ),
            this, SLOT( contextMenuRequested( QPoint const & ) ) );
 
-  connect( ui.definition, SIGNAL( linkClicked( QUrl const & ) ),
+  connect( webPage, SIGNAL( linkClicked( QUrl const & ) ),
            this, SLOT( linkClicked( QUrl const & ) ) );
 
+#ifdef USE_QTWEBKIT
+  connect( ui.definition, SIGNAL( doubleClicked( QPoint ) ), this, SLOT( doubleClicked( QPoint ) ) );
+
   connect( ui.definition->page(), SIGNAL( linkHovered ( const QString &, const QString &, const QString & ) ),
            this, SLOT( linkHovered ( const QString &, const QString &, const QString & ) ) );
-
-  connect( ui.definition, SIGNAL( doubleClicked( QPoint ) ),this,SLOT( doubleClicked( QPoint ) ) );
+#else
+  connect( ui.definition->page(), &QWebEnginePage::linkHovered,
+           this, [ this ]( QString const & url ) { linkHovered( url ); } );
+#endif
 
   pasteAction.setShortcut( QKeySequence::Paste  );
   ui.definition->addAction( &pasteAction );
@@ -354,25 +612,28 @@ ArticleView::ArticleView( QWidget * parent, ArticleNetworkAccessManager & nm,
   ui.definition->addAction( &inspectAction );
   connect( &inspectAction, SIGNAL( triggered() ), this, SLOT( inspect() ) );
 
+#ifdef USE_QTWEBKIT
   ui.definition->installEventFilter( this );
+#else
+  ui.definition->setEventFilter( this );
+#endif
   ui.searchFrame->installEventFilter( this );
   ui.ftsSearchFrame->installEventFilter( this );
 
+#ifdef USE_QTWEBKIT
+  // registerArticleUrlSchemes() is responsible for similar configuration in the Qt WebEngine version.
   QWebSettings * settings = ui.definition->page()->settings();
   settings->setAttribute( QWebSettings::LocalContentCanAccessRemoteUrls, true );
   settings->setAttribute( QWebSettings::LocalContentCanAccessFileUrls, true );
+#endif
 
+  std::string const blankPage = makeBlankPage( articleNetMgr, *webPage );
   // Load the default blank page instantly, so there would be no flicker.
-
-  QString contentType;
-  QUrl blankPage( "gdlookup://localhost?blank=1" );
-
-  sptr< Dictionary::DataRequest > r = articleNetMgr.getResource( blankPage,
-                                                                 contentType );
-
-  ui.definition->setHtml( QString::fromUtf8( &( r->getFullData().front() ),
-                                             r->getFullData().size() ),
-                          blankPage );
+  // When the correct WebEnginePage::backgroundColor is set, loading this blank page is less important,
+  // but still prevents brief white background flashes when a new empty tab is created and switched to,
+  // or when the scan popup is opened for the first time.
+  ui.definition->setHtml( QString::fromUtf8( blankPage.data(), blankPage.size() ),
+                          QUrl( "gdlookup://localhost?blank=1" ) );
 
   expandOptionalParts = cfg.preferences.alwaysExpandOptionalParts;
 
@@ -381,8 +642,10 @@ ArticleView::ArticleView( QWidget * parent, ArticleNetworkAccessManager & nm,
   ui.definition->grabGesture( Gestures::GDSwipeGestureType );
 #endif
 
+#ifdef USE_QTWEBKIT
   // Variable name for store current selection range
   rangeVarName = QString( "sr_%1" ).arg( QString::number( (quint64)this, 16 ) );
+#endif
 }
 
 // explicitly report the minimum size, to avoid
@@ -408,25 +671,42 @@ ArticleView::~ArticleView()
 #endif
 }
 
-void ArticleView::showDefinition( Config::InputPhrase const & phrase, unsigned group,
-                                  QString const & scrollTo,
-                                  Contexts const & contexts_ )
+void ArticleView::saveConfigData() const
 {
-  // first, let's stop the player
-  audioPlayer->stop();
+#ifdef USE_QTWEBKIT
+  ui.definition->saveConfigData();
+#else
+  auto * const page = static_cast< ArticleWebPage const * >( ui.definition->page() );
+  page->saveConfigData();
+#endif
+}
 
+static QUrl createGdlookupUrl( Config::InputPhrase const & phrase, unsigned group, bool ignoreDiacritics )
+{
   QUrl req;
-  Contexts contexts( contexts_ );
 
   req.setScheme( "gdlookup" );
   req.setHost( "localhost" );
   Qt4x5::Url::addQueryItem( req, "word", phrase.phrase );
-  if ( !phrase.punctuationSuffix.isEmpty() )
+  if( !phrase.punctuationSuffix.isEmpty() )
     Qt4x5::Url::addQueryItem( req, "punctuation_suffix", phrase.punctuationSuffix );
   Qt4x5::Url::addQueryItem( req, "group", QString::number( group ) );
-  if( cfg.preferences.ignoreDiacritics )
+  if( ignoreDiacritics )
     Qt4x5::Url::addQueryItem( req, "ignore_diacritics", "1" );
 
+  return req;
+}
+
+void ArticleView::showDefinition( Config::InputPhrase const & phrase, unsigned group,
+                                  QString const & scrollTo,
+                                  Contexts const & contexts_ )
+{
+  // first, let's stop the player
+  audioPlayer->stop();
+
+  QUrl req = createGdlookupUrl( phrase, group, cfg.preferences.ignoreDiacritics );
+  Contexts contexts( contexts_ );
+
   if ( scrollTo.size() )
     Qt4x5::Url::addQueryItem( req, "scrollto", scrollTo );
 
@@ -457,18 +737,34 @@ void ArticleView::showDefinition( Config::InputPhrase const & phrase, unsigned g
   if ( mutedDicts.size() )
     Qt4x5::Url::addQueryItem( req,  "muted", mutedDicts );
 
+  showDefinition( phrase, req );
+}
+
+void ArticleView::showDefinition( Config::InputPhrase const & phrase, QUrl const & url )
+{
   // Update headwords history
   emit sendWordToHistory( phrase.phrase );
 
   // Any search opened is probably irrelevant now
+#ifdef USE_QTWEBKIT
+  // TODO (Qt WebKit): put this statement under the condition currently restricted to the Qt WebEngine
+  // version (see below) once Qt version < 5.2 and C++ standard < 11 are no longer supported.
   closeSearch();
+#else
+  // Handle only regular searchFrame here, because handleUrlChanged() hides ftsSearchFrame.
+  // If the looked-up word is the same as the currently displayed one, keep searchFrame visible:
+  // the user may have re-requested translation of the word to search from the beginning of the
+  // page, or switched to a different dictionary group to search the same text there.
+  if( searchIsOpened && !urlsOrWordsMatch( ui.definition->url(), url ) )
+    hideSearchFrameOnceJsSavesStateToWebHistory = true;
+#endif
 
   // Clear highlight all button selection
   ui.highlightAllButton->setChecked(false);
 
   emit setExpandMode( expandOptionalParts );
 
-  load( req );
+  load( url );
 
   //QApplication::setOverrideCursor( Qt::WaitCursor );
   ui.definition->setCursor( Qt::WaitCursor );
@@ -481,9 +777,8 @@ void ArticleView::showDefinition( QString const & word, unsigned group,
   showDefinition( Config::InputPhrase::fromPhrase( word ), group, scrollTo, contexts_ );
 }
 
-void ArticleView::showDefinition( QString const & word, QStringList const & dictIDs,
-                                  QRegExp const & searchRegExp, unsigned group,
-                                  bool ignoreDiacritics )
+void ArticleView::showDefinition( Config::InputPhrase const & phrase, QStringList const & dictIDs,
+                                  QRegExp const & searchRegExp, unsigned group, bool ignoreDiacritics )
 {
   if( dictIDs.isEmpty() )
     return;
@@ -491,52 +786,35 @@ void ArticleView::showDefinition( QString const & word, QStringList const & dict
   // first, let's stop the player
   audioPlayer->stop();
 
-  QUrl req;
+  QUrl req = createGdlookupUrl( phrase, group, ignoreDiacritics );
 
-  req.setScheme( "gdlookup" );
-  req.setHost( "localhost" );
-  Qt4x5::Url::addQueryItem( req, "word", word );
   Qt4x5::Url::addQueryItem( req, "dictionaries", dictIDs.join( ",") );
   Qt4x5::Url::addQueryItem( req, "regexp", searchRegExp.pattern() );
   if( searchRegExp.caseSensitivity() == Qt::CaseSensitive )
     Qt4x5::Url::addQueryItem( req, "matchcase", "1" );
   if( searchRegExp.patternSyntax() == QRegExp::WildcardUnix )
     Qt4x5::Url::addQueryItem( req, "wildcards", "1" );
-  Qt4x5::Url::addQueryItem( req, "group", QString::number( group ) );
-  if( ignoreDiacritics )
-    Qt4x5::Url::addQueryItem( req, "ignore_diacritics", "1" );
-
-  // Update headwords history
-  emit sendWordToHistory( word );
 
-  // Any search opened is probably irrelevant now
-  closeSearch();
-
-  // Clear highlight all button selection
-  ui.highlightAllButton->setChecked(false);
-
-  emit setExpandMode( expandOptionalParts );
-
-  load( req );
-
-  //QApplication::setOverrideCursor( Qt::WaitCursor );
-  ui.definition->setCursor( Qt::WaitCursor );
+  showDefinition( phrase, req );
 }
 
-void ArticleView::showAnticipation()
+void ArticleView::showDefinition( QString const & word, QStringList const & dictIDs,
+                                  QRegExp const & searchRegExp, unsigned group, bool ignoreDiacritics )
 {
-  ui.definition->setHtml( "" );
-  ui.definition->setCursor( Qt::WaitCursor );
-  //QApplication::setOverrideCursor( Qt::WaitCursor );
+  showDefinition( Config::InputPhrase::fromPhrase( word ), dictIDs, searchRegExp, group, ignoreDiacritics );
 }
 
-void ArticleView::loadFinished( bool )
-{
-  QUrl url = ui.definition->url();
+#ifdef USE_QTWEBKIT
 
+// This function relies on Qt WebKit API unavailable in Qt WebEngine.
+// The code is useful only for website dictionaries.
+static void expandFrames( QWebView & view )
+{
   // See if we have any iframes in need of expansion
 
-  QList< QWebFrame * > frames = ui.definition->page()->mainFrame()->childFrames();
+  QWebFrame & mainFrame = *view.page()->mainFrame();
+
+  QList< QWebFrame * > frames = mainFrame.childFrames();
 
   bool wereFrames = false;
 
@@ -549,12 +827,12 @@ void ArticleView::loadFinished( bool )
       //DPRINTF( ">>>>>>>>Height = %s\n", (*i)->evaluateJavaScript( "document.body.offsetHeight;" ).toString().toUtf8().data() );
 
       // Set the height
-      ui.definition->page()->mainFrame()->evaluateJavaScript( QString( "document.getElementById('%1').height = %2;" ).
+      mainFrame.evaluateJavaScript( QString( "document.getElementById('%1').height = %2;" ).
         arg( (*i)->frameName() ).
         arg( (*i)->contentsSize().height() ) );
 
       // Show it
-      ui.definition->page()->mainFrame()->evaluateJavaScript( QString( "document.getElementById('%1').style.display = 'block';" ).
+      mainFrame.evaluateJavaScript( QString( "document.getElementById('%1').style.display = 'block';" ).
         arg( (*i)->frameName() ) );
 
       (*i)->evaluateJavaScript( "var gdLastUrlText;" );
@@ -571,12 +849,13 @@ void ArticleView::loadFinished( bool )
 
     QMouseEvent ev( QEvent::MouseMove, QPoint(), Qt::MouseButton(), Qt::MouseButtons(), Qt::KeyboardModifiers() );
 
-    qApp->sendEvent( ui.definition, &ev );
+    qApp->sendEvent( &view, &ev );
   }
+}
 
-  // Expand collapsed article if only one loaded
-  ui.definition->page()->mainFrame()->evaluateJavaScript( "gdCheckArticlesNumber();" );
-
+// JavaScript code implements this feature in the Qt WebEngine version.
+void ArticleView::initCurrentArticleAndScroll()
+{
   QVariant userDataVariant = ui.definition->history()->currentItem().userData();
   if ( userDataVariant.type() == QVariant::Map )
   {
@@ -597,13 +876,13 @@ void ArticleView::loadFinished( bool )
       moveToCurrentArticle = false;
     }
 
-    const QString currentArticle = userData.value( "currentArticle" ).toString();
-    if( !currentArticle.isEmpty() )
+    QString const savedCurrentArticle = userData.value( "currentArticle" ).toString();
+    if( !savedCurrentArticle.isEmpty() )
     {
       // There's a current article saved, so set it to be current.
       // If a scroll position was stored - even (0, 0) - don't move to the
       // current article.
-      setCurrentArticle( currentArticle, moveToCurrentArticle );
+      setCurrentArticle( savedCurrentArticle, moveToCurrentArticle );
     }
 
     if ( sx != 0 || sy != 0 )
@@ -616,7 +895,7 @@ void ArticleView::loadFinished( bool )
   }
   else
   {
-    QString const scrollTo = Qt4x5::Url::queryItemValue( url, "scrollto" );
+    QString const scrollTo = Qt4x5::Url::queryItemValue( ui.definition->url(), "scrollto" );
     if( isScrollTo( scrollTo ) )
     {
       // There is no active article saved in history, but we have it as a parameter.
@@ -624,13 +903,17 @@ void ArticleView::loadFinished( bool )
       setCurrentArticle( scrollTo, true );
     }
   }
+}
 
-  ui.definition->unsetCursor();
-  //QApplication::restoreOverrideCursor();
+// JavaScript code implements this feature in the Qt WebEngine version.
+static void scrollToGdAnchor( QWebView const & view )
+{
+  QUrl url = view.url();
 
-#if QT_VERSION >= QT_VERSION_CHECK(4, 6, 0)
   if( !Qt4x5::Url::queryItemValue( url, "gdanchor" ).isEmpty() )
   {
+    QWebFrame & mainFrame = *view.page()->mainFrame();
+
     QString anchor = QUrl::fromPercentEncoding( Qt4x5::Url::encodedQueryItemValue( url, "gdanchor" ) );
 
     // Find GD anchor on page
@@ -650,8 +933,8 @@ void ArticleView::loadFinished( bool )
       rx.setMinimal( true );
       rx.setPattern( anchor.left( 34 ) + "[0-9a-f]*_" + originalAnchor );
 
-      QWebElementCollection coll = ui.definition->page()->mainFrame()->findAllElements( "a[name]" );
-      coll += ui.definition->page()->mainFrame()->findAllElements( "a[id]" );
+      QWebElementCollection coll = mainFrame.findAllElements( "a[name]" );
+      coll += mainFrame.findAllElements( "a[id]" );
 
       for( QWebElementCollection::iterator it = coll.begin(); it != coll.end(); ++it )
       {
@@ -664,7 +947,7 @@ void ArticleView::loadFinished( bool )
 
           url.clear();
           url.setFragment( rx.cap( 0 ) );
-          ui.definition->page()->mainFrame()->evaluateJavaScript(
+          mainFrame.evaluateJavaScript(
              QString( "window.location.hash = \"%1\"" ).arg( QString::fromUtf8( url.toEncoded() ) ) );
 
           break;
@@ -675,26 +958,84 @@ void ArticleView::loadFinished( bool )
     {
       url.clear();
       url.setFragment( anchor );
-      ui.definition->page()->mainFrame()->evaluateJavaScript(
+      mainFrame.evaluateJavaScript(
          QString( "window.location.hash = \"%1\"" ).arg( QString::fromUtf8( url.toEncoded() ) ) );
     }
   }
+}
+
+#endif // USE_QTWEBKIT
+
+void ArticleView::loadFinished( bool )
+{
+#ifdef USE_QTWEBKIT
+  expandFrames( *ui.definition );
+
+  // If true, the user has managed to activate an article already.
+  // The code below does not override this explicit user choice.
+  bool const wasCurrentArticleSetExplicitly = evaluateJavaScriptVariableSafe(
+        ui.definition->page()->mainFrame(), "gdWasCurrentArticleSetExplicitly" ).toBool();
+
+  // Don't set the current article or scroll if the user has activated an article already.
+  // However, if this was a back/forward navigation or page reloading, the user also has to
+  // scroll the mouse wheel to prevent QWebPage from restoring its saved scroll position.
+  if( !wasCurrentArticleSetExplicitly )
+  {
+    initCurrentArticleAndScroll();
+    scrollToGdAnchor( *ui.definition );
+  }
 #endif
 
+  ui.definition->unsetCursor();
+  //QApplication::restoreOverrideCursor();
+
   emit pageLoaded( this );
 
   if( Qt4x5::Url::hasQueryItem( ui.definition->url(), "regexp" ) )
     highlightFTSResults();
+
+  isLoading = false;
+  emit pageLoadingStateChanged( this, isLoading );
 }
 
 void ArticleView::handleTitleChanged( QString const & title )
 {
-  if( !title.isEmpty() ) // Qt 5.x WebKit raise signal titleChanges(QString()) while navigation within page
-    emit titleChanged( this, title );
+  // Qt 5.x WebKit raise signal titleChanges(QString()) while navigation within page.
+  // The Qt WebEngine-specific code below assumes title is not empty.
+  if( title.isEmpty() )
+    return;
+
+#ifndef USE_QTWEBKIT
+  // When a page is loaded, QWebEngineView::title first becomes equal to the URL,
+  // then quickly changes to the HTML <title>. Ignore the temporary title change
+  // to prevent the flashing of the main window title.
+
+  auto const url = ui.definition->url().toString();
+  if( title == url )
+    return;
+
+  constexpr QChar leftToRightEmbedding( u'\u202A' );
+  constexpr QChar popDirectionalFormatting( u'\u202C' );
+  Q_ASSERT( !title.isEmpty() );
+  bool const titleMatchesUrl = title.front() == leftToRightEmbedding && title.back() == popDirectionalFormatting
+                               && QStringView{ title.constData() + 1, title.size() - 2 } == url;
+  if( titleMatchesUrl )
+    return;
+#endif
+
+  emit titleChanged( this, title );
 }
 
 void ArticleView::handleUrlChanged( QUrl const & url )
 {
+#ifndef USE_QTWEBKIT
+  isBlankPagePresentInWebHistory = isBlankPagePresentInWebHistory
+          || QUrlQuery{ url }.queryItemValue( QStringLiteral( "blank" ) ) == QLatin1String( "1" );
+#endif
+
+  if( ftsSearchIsOpened && Qt4x5::Url::queryItemValue( url, "regexp" ).isEmpty() )
+    closeSearch(); // ftsSearchFrame does not make sense on a non-FTS-search page => hide it.
+
   QIcon icon;
 
   unsigned group = getGroup( url );
@@ -715,6 +1056,27 @@ void ArticleView::handleUrlChanged( QUrl const & url )
   emit iconChanged( this, icon );
 }
 
+void ArticleView::runJavaScript( TargetFrame targetFrame, QString const & scriptSource )
+{
+#ifdef USE_QTWEBKIT
+  QWebPage * const page = ui.definition->page();
+  Q_ASSERT( page );
+  QWebFrame * const frame = targetFrame == MainFrame ? page->mainFrame() : page->currentFrame();
+  Q_ASSERT( frame );
+  frame->evaluateJavaScript( scriptSource );
+#else
+  // The Qt WebEngine API allows to run JavaScript only on the main frame of a page.
+  // Hopefully the target frame does not matter in the Qt WebEngine version.
+  Q_UNUSED( targetFrame )
+  ui.definition->page()->runJavaScript( scriptSource, QWebEngineScript::MainWorld );
+#endif
+}
+
+void ArticleView::clearPageSelection()
+{
+  runJavaScript( CurrentFrame, "window.getSelection().removeAllRanges();" );
+}
+
 unsigned ArticleView::getGroup( QUrl const & url )
 {
   if ( url.scheme() == "gdlookup" && Qt4x5::Url::hasQueryItem( url, "group" ) )
@@ -723,37 +1085,25 @@ unsigned ArticleView::getGroup( QUrl const & url )
   return 0;
 }
 
-QStringList ArticleView::getArticlesList()
+QStringList ArticleView::getArticleList() const
 {
-  return evaluateJavaScriptVariableSafe( ui.definition->page()->mainFrame(), "gdArticleContents" )
-      .toString().trimmed().split( ' ', Qt4x5::skipEmptyParts() );
+  return articleList;
 }
 
 QString ArticleView::getActiveArticleId()
 {
-  QString currentArticle = getCurrentArticle();
   if ( !isScrollTo( currentArticle ) )
     return QString(); // Incorrect id
 
   return dictionaryIdFromScrollTo( currentArticle );
 }
 
-QString ArticleView::getCurrentArticle()
-{
-  QVariant v = evaluateJavaScriptVariableSafe( ui.definition->page()->mainFrame(), "gdCurrentArticle" );
-
-  if ( v.type() == QVariant::String )
-    return v.toString();
-  else
-    return QString();
-}
-
 void ArticleView::jumpToDictionary( QString const & id, bool force )
 {
   QString targetArticle = scrollToFromDictionaryId( id );
 
   // jump only if neceessary, or when forced
-  if ( force || targetArticle != getCurrentArticle() )
+  if ( force || targetArticle != currentArticle )
   {
     setCurrentArticle( targetArticle, true );
   }
@@ -762,30 +1112,46 @@ void ArticleView::jumpToDictionary( QString const & id, bool force )
 bool ArticleView::setCurrentArticle( QString const & id, bool moveToIt )
 {
   if ( !isScrollTo( id ) )
-    return false; // Incorrect id
+  {
+    gdWarning( "Attempt to set invalid current article ID: %s", id.toUtf8().constData() );
+    return false;
+  }
 
   if ( !ui.definition->isVisible() )
     return false; // No action on background page, scrollIntoView there don't work
 
-  QString const dictionaryId = dictionaryIdFromScrollTo( id );
-  if( !getArticlesList().contains( dictionaryId ) )
+  if( !articleList.contains( dictionaryIdFromScrollTo( id ) ) )
     return false;
 
-  if ( moveToIt )
-    ui.definition->page()->mainFrame()->evaluateJavaScript( QString( "document.getElementById('%1').scrollIntoView(true);" ).arg( id ) );
+#ifdef USE_QTWEBKIT
+  runJavaScript( MainFrame,
+    QString( "gdOnCppActiveArticleChanged('%1', %2);" ).arg( id, javaScriptBool( moveToIt ) ) );
+#else
+  currentArticleTimestamp = QDateTime::currentDateTimeUtc();
+  ui.definition->page()->runJavaScript( QLatin1String( "gdOnCppActiveArticleChanged('%1', %2, '%3', '%4');" )
+                                        .arg( id, javaScriptBool( moveToIt ), javaScriptDateString( pageTimestamp ),
+                                              javaScriptDateString( currentArticleTimestamp ) ) );
+#endif
 
-  ui.definition->page()->mainFrame()->evaluateJavaScript(
-    QString( "gdMakeArticleActive( '%1' );" ).arg( dictionaryId ) );
+  setValidCurrentArticleNoJs( id );
 
   return true;
 }
 
+void ArticleView::setValidCurrentArticleNoJs( QString const & id )
+{
+  if( currentArticle == id )
+    return; // nothing to do
+  currentArticle = id;
+  emit activeArticleChanged( this, dictionaryIdFromScrollTo( id ) );
+}
+
 void ArticleView::selectCurrentArticle()
 {
-  ui.definition->page()->mainFrame()->evaluateJavaScript(
-        QString( "gdSelectArticle( '%1' );" ).arg( getActiveArticleId() ) );
+  runJavaScript( MainFrame, "gdSelectCurrentArticle();" );
 }
 
+#ifdef USE_QTWEBKIT
 bool ArticleView::isFramedArticle( QString const & ca )
 {
   if ( ca.isEmpty() )
@@ -795,6 +1161,7 @@ bool ArticleView::isFramedArticle( QString const & ca )
                evaluateJavaScript( QString( "!!document.getElementById('gdexpandframe-%1');" )
                                           .arg( dictionaryIdFromScrollTo( ca ) ) ).toBool();
 }
+#endif
 
 bool ArticleView::isExternalLink( QUrl const & url )
 {
@@ -803,6 +1170,7 @@ bool ArticleView::isExternalLink( QUrl const & url )
          url.scheme() == "file";
 }
 
+#ifdef USE_QTWEBKIT
 void ArticleView::tryMangleWebsiteClickedUrl( QUrl & url, Contexts & contexts )
 {
   // Don't try mangling audio urls, even if they are from the framed websites
@@ -812,16 +1180,14 @@ void ArticleView::tryMangleWebsiteClickedUrl( QUrl & url, Contexts & contexts )
   {
     // Maybe a link inside a website was clicked?
 
-    QString ca = getCurrentArticle();
-
-    if ( isFramedArticle( ca ) )
+    if( isFramedArticle( currentArticle ) )
     {
       QVariant result = evaluateJavaScriptVariableSafe( ui.definition->page()->currentFrame(), "gdLastUrlText" );
 
       if ( result.type() == QVariant::String )
       {
         // Looks this way
-        contexts[ dictionaryIdFromScrollTo( ca ) ] = QString::fromLatin1( url.toEncoded() );
+        contexts[ dictionaryIdFromScrollTo( currentArticle ) ] = QString::fromLatin1( url.toEncoded() );
 
         QUrl target;
 
@@ -855,22 +1221,44 @@ void ArticleView::updateCurrentArticleFromCurrentFrame( QWebFrame * frame )
     {
       QString newCurrent = scrollToFromDictionaryId( frameName.mid( 14 ) );
 
-      if ( getCurrentArticle() != newCurrent )
+      if( currentArticle != newCurrent )
         setCurrentArticle( newCurrent, false );
 
       break;
     }
   }
 }
+#endif // USE_QTWEBKIT
+
+#ifndef USE_QTWEBKIT
+void ArticleView::updateSourceCodeOfInjectedScript( QWebEngineScriptCollection & scripts,
+                                                    QString const & name, QString const & sourceCode )
+{
+  auto script = scripts.findScript( name );
+  Q_ASSERT( !script.isNull() );
+
+  scripts.remove( script );
+  script.setSourceCode( sourceCode );
+  scripts.insert( script );
+}
+
+void ArticleView::updateInjectedPageReloadingScript( bool scrollToCurrentArticle )
+{
+  updateSourceCodeOfInjectedScript( ui.definition->page()->scripts(), pageReloadingScriptName(),
+                                    pageReloadingScriptSourceCode( currentArticle, scrollToCurrentArticle ) );
+}
+#endif
 
 void ArticleView::saveHistoryUserData()
 {
+  // JavaScript code implements this feature in the Qt WebEngine version.
+#ifdef USE_QTWEBKIT
   QMap< QString, QVariant > userData = ui.definition->history()->
                                        currentItem().userData().toMap();
 
   // Save current article, which can be empty
 
-  userData[ "currentArticle" ] = getCurrentArticle();
+  userData[ "currentArticle" ] = currentArticle;
 
   // We also save window position. We restore it when the page is fully loaded,
   // when any hidden frames are expanded.
@@ -879,10 +1267,18 @@ void ArticleView::saveHistoryUserData()
   userData[ "sy" ] = ui.definition->page()->mainFrame()->evaluateJavaScript( "window.scrollY;" ).toDouble();
 
   ui.definition->history()->currentItem().setUserData( userData );
+#endif // USE_QTWEBKIT
 }
 
 void ArticleView::load( QUrl const & url )
 {
+#ifndef USE_QTWEBKIT
+  // Translating the current word again looks like reloading the page to JavaScript code.
+  // Update the script to prevent setting a wrong current article and unwanted scrolling.
+  // After such "reloading" the web engine restores the window position automatically.
+  updateInjectedPageReloadingScript( false );
+#endif
+
   saveHistoryUserData();
   ui.definition->load( url );
 }
@@ -1010,10 +1406,32 @@ bool ArticleView::eventFilter( QObject * obj, QEvent * ev )
     return true;
   }
 
-  if ( obj == ui.definition )
+#ifdef USE_QTWEBKIT
+  if ( obj != ui.definition )
+#else
+  if( !ui.definition->isWatched( obj ) )
+#endif
+    return QFrame::eventFilter( obj, ev );
+
+  switch( ev->type() )
   {
-    if ( ev->type() == QEvent::MouseButtonPress ) {
+    case QEvent::MouseButtonPress:
+    {
       QMouseEvent * event = static_cast< QMouseEvent * >( ev );
+
+#ifndef USE_QTWEBKIT
+      if( lastLeftMouseButtonPressEvent && event->button() == Qt::LeftButton
+          // Don't store events synthesized by this class to prevent recursion.
+          && event->source() != Qt::MouseEventSynthesizedByApplication )
+      {
+        // "Select word by single click" option is on. A double click must be generated to select the word
+        // under cursor. But if this click is on a scrollbar, generating a double click prevents dragging it.
+        // We cannot determine if the click is on a scrollbar here. Store the event away; generate a double
+        // click once the JavaScript side confirms this is a click on the page proper, not on its scrollbar.
+        lastLeftMouseButtonPressEvent->assign( obj, *event );
+      }
+#endif
+
       if ( event->button() == Qt::XButton1 ) {
         back();
         return true;
@@ -1022,10 +1440,59 @@ bool ArticleView::eventFilter( QObject * obj, QEvent * ev )
         forward();
         return true;
       }
+
+      break;
     }
-    else
-    if ( ev->type() == QEvent::KeyPress )
+#ifndef USE_QTWEBKIT
+    case QEvent::MouseButtonDblClick:
+    {
+      auto * const event = static_cast< QMouseEvent * >( ev );
+      if( lastLeftMouseButtonPressEvent && event->button() == Qt::LeftButton )
+      {
+        if( lastLeftMouseButtonPressEvent->isValid() )
+        {
+          // This means a double click on a scrollbar or a timing issue. In any case, now that a non-synthesized
+          // double click has occurred, synthesizing another one makes no sense => invalidate the stored event.
+          lastLeftMouseButtonPressEvent->invalidate();
+        }
+        else
+        {
+          // A synthesized double click has already selected a word after the first click.
+          // The web page treats a second non-synthesized click as a separate first click.
+          // Filter it out to prevent immediate deselection of the word.
+          return true;
+        }
+      }
+      break;
+    }
+    case QEvent::MouseButtonRelease:
+      // In the Qt WebEngine version, ArticleWebPage::linkClicked() is emitted several milliseconds after the mouse
+      // button release event, so the Qt WebKit version's ArticleWebView::isMidButtonPressed() approach does not work.
+      // Resort to the following hack: on events that can activate a link, set isNavigationByMiddleMouseButton to true
+      // in the case of the middle mouse button release, to false otherwise.
+      isNavigationByMiddleMouseButton = static_cast< QMouseEvent * >( ev )->button() == Qt::MiddleButton;
+      break;
+    case QEvent::Wheel:
+      if( static_cast< QWheelEvent * >( ev )->modifiers().testFlag( Qt::ControlModifier ) )
+      {
+        // Follow the behavior of the Qt WebKit version:
+        // 1. If this view is in the main window, bypass the widget child of QWebEngineView, which only scales the view,
+        //    and let the event propagate to MainWindow. MainWindow::wheelEvent() scales views in all tabs and in the
+        //    scan popup, as well as updates zoom factor in Preferences (stored on disk, persists across app restarts).
+        // 2. If this view is in the scan popup, the event is also propagated but never handled, and thus ignored.
+        QApplication::sendEvent( ui.definition, ev );
+        return true;
+      }
+      break;
+#endif // USE_QTWEBKIT
+    case QEvent::KeyPress:
     {
+#ifndef USE_QTWEBKIT
+      // Once a link is focused with [Shift+]Tab key presses, pressing a Return/Enter key activates it.
+      // The last released mouse button must not affect whether the link is opened in a new tab then.
+      isNavigationByMiddleMouseButton = false;
+#endif
+
       QKeyEvent * keyEvent = static_cast< QKeyEvent * >( ev );
 
       if ( keyEvent->modifiers() &
@@ -1050,10 +1517,12 @@ bool ArticleView::eventFilter( QObject * obj, QEvent * ev )
         emit typingEvent( text );
         return true;
       }
+
+      break;
     }
+    default:
+      break;
   }
-  else
-    return QFrame::eventFilter( obj, ev );
 
   return false;
 }
@@ -1170,10 +1639,12 @@ void ArticleView::linkHovered ( const QString & link, const QString & , const QS
   emit statusBarMessage( msg );
 }
 
+#ifdef USE_QTWEBKIT
 void ArticleView::attachToJavaScript()
 {
-  ui.definition->page()->mainFrame()->addToJavaScriptWindowObject( "articleview", jsProxy );
+  ui.definition->page()->mainFrame()->addToJavaScriptWindowObject( "gdArticleView", jsProxy );
 }
+#endif
 
 void ArticleView::linkClicked( QUrl const & url_ )
 {
@@ -1183,22 +1654,83 @@ void ArticleView::linkClicked( QUrl const & url_ )
   if( kmod & Qt::AltModifier )
     return;
 
+#ifdef USE_QTWEBKIT
   updateCurrentArticleFromCurrentFrame();
+#endif
 
   QUrl url( url_ );
   Contexts contexts;
 
+#ifdef USE_QTWEBKIT
   tryMangleWebsiteClickedUrl( url, contexts );
+  bool const isNavigationByMiddleMouseButton = ui.definition->isMidButtonPressed();
+#endif
 
   if ( !popupView &&
-       ( ui.definition->isMidButtonPressed() ||
+       ( isNavigationByMiddleMouseButton ||
          ( kmod & ( Qt::ControlModifier | Qt::ShiftModifier ) ) ) )
   {
-    // Mid button or Control/Shift is currently pressed - open the link in new tab
-    emit openLinkInNewTab( url, ui.definition->url(), getCurrentArticle(), contexts );
+    // The link was middle-button-clicked or Control/Shift is currently pressed => open the link in a new tab.
+    emit openLinkInNewTab( url, ui.definition->url(), currentArticle, contexts );
   }
   else
-    openLink( url, ui.definition->url(), getCurrentArticle(), contexts );
+    openLink( url, ui.definition->url(), currentArticle, contexts );
+}
+
+static QUrl replaceScrollToInLinkWithFragment( QUrl const & url, QString const & scrollTo )
+{
+  static QString const scrollToQueryKey = "scrollto";
+
+  QUrl result = url;
+
+#ifdef USE_QTWEBKIT
+  // In the Qt WebKit version, the "scrollto" query item value has no effect in background tabs and
+  // overrides the more precise and useful scrolling to the fragment ID in foreground tabs => remove it.
+  // TODO (Qt WebKit): fix these issues and share code with the Qt WebEngine version in order to set correct current
+  // article instead of keeping the first article active (a new Qt4x5::Url::replaceQueryItem() wrapper could be useful).
+  Q_UNUSED( scrollTo )
+  Qt4x5::Url::removeQueryItem( result, scrollToQueryKey );
+#else
+  QUrlQuery urlQuery( url );
+  urlQuery.removeQueryItem( scrollToQueryKey );
+  if( !scrollTo.isEmpty() )
+    urlQuery.addQueryItem( scrollToQueryKey, scrollTo );
+  result.setQuery( urlQuery );
+#endif
+
+  return result;
+}
+
+void ArticleView::openLinkWithFragment( QUrl const & url, QString const & scrollTo )
+{
+  Q_ASSERT( url.hasFragment() );
+
+  // This must be fragment navigation on the same page, but possibly in a new tab. No need to save
+  // history user data, because its only user - loadFinished() - is not called after navigating back
+  // within the page; navigating back to the initial blank page in the new tab is not allowed.
+
+  // Neither assigning to window.location in the current tab nor navigating from the initial blank page
+  // in the new tab looks like reloading to JavaScript code => no need to update the page-reloading script.
+
+#if QT_VERSION >= QT_VERSION_CHECK( 5, 2, 0 )
+  if( url.matches( ui.definition->url(), QUrl::RemoveFragment ) )
+#else
+  QUrl currentUrlWithEqualFragment = ui.definition->url();
+  currentUrlWithEqualFragment.setFragment( url.fragment() );
+  if( url == currentUrlWithEqualFragment )
+#endif
+  {
+    // This is a fragment navigation on the same page and not in a new tab.
+    // The regular loading of the url is slower and causes other issues => assign url to window.location.
+    runJavaScript( MainFrame, QString( "window.location = \"%1\"" ).arg( QString::fromUtf8( url.toEncoded() ) ) );
+    return;
+  }
+
+  // url's target is a different page (is that possible?) or this link is being opened in a new tab.
+  // Load the url regularly, because assigning it to window.location fails in the Qt WebEngine
+  // version - the new tab's page remains blank and the following error message is printed:
+  // JS error: Not allowed to load local resource: <url> (at :1)
+  ui.definition->load( replaceScrollToInLinkWithFragment( url, scrollTo ) );
 }
 
 void ArticleView::openLink( QUrl const & url, QUrl const & ref,
@@ -1229,10 +1761,7 @@ void ArticleView::openLink( QUrl const & url, QUrl const & ref,
   if ( url.scheme() == "gdlookup" ) // Plain html links inherit gdlookup scheme
   {
     if ( url.hasFragment() )
-    {
-      ui.definition->page()->mainFrame()->evaluateJavaScript(
-        QString( "window.location = \"%1\"" ).arg( QString::fromUtf8( url.toEncoded() ) ) );
-    }
+      openLinkWithFragment( url, scrollTo );
     else
     {
       if( Qt4x5::Url::hasQueryItem( ref, "dictionaries" ) )
@@ -1508,14 +2037,15 @@ void ArticleView::openLink( QUrl const & url, QUrl const & ref,
   }
 }
 
-ResourceToSaveHandler * ArticleView::saveResource( const QUrl & url, const QString & fileName )
+void ArticleView::saveResource( QUrl const & url, ResourceToSaveHandler & handler )
 {
-  return saveResource( url, ui.definition->url(), fileName );
+  return saveResource( url, ui.definition->url(), &handler );
 }
 
-ResourceToSaveHandler * ArticleView::saveResource( const QUrl & url, const QUrl & ref, const QString & fileName )
+void ArticleView::saveResource( QUrl const & url, QUrl const & ref, ResourceToSaveHandler * handler )
 {
-  ResourceToSaveHandler * handler = new ResourceToSaveHandler( this, fileName );
+  Q_ASSERT( handler );
+
   sptr< Dictionary::DataRequest > req;
 
   if( url.scheme() == "bres" || url.scheme() == "gico" || url.scheme() == "gdau" || url.scheme() == "gdvideo" )
@@ -1565,7 +2095,7 @@ ResourceToSaveHandler * ArticleView::saveResource( const QUrl & url, const QUrl
                 if( req->isFinished() && req->dataSize() > 0 )
                 {
                   handler->downloadFinished();
-                  return handler;
+                  return;
                 }
                 break;
               }
@@ -1632,7 +2162,7 @@ ResourceToSaveHandler * ArticleView::saveResource( const QUrl & url, const QUrl
   // Check already finished downloads
   handler->downloadFinished();
 
-  return handler;
+  return;
 }
 
 void ArticleView::updateMutedContents()
@@ -1665,27 +2195,58 @@ void ArticleView::updateMutedContents()
   }
 }
 
-bool ArticleView::canGoBack()
+bool ArticleView::canGoBack() const
 {
-  // First entry in a history is always an empty page,
-  // so we skip it.
-  return ui.definition->history()->currentItemIndex() > 1;
+#ifndef USE_QTWEBKIT
+  // Don't allow navigating back to page 0 if it is the initial blank page.
+  if( isBlankPagePresentInWebHistory )
+    return ui.definition->history()->currentItemIndex() > 1;
+#endif
+  return ui.definition->history()->canGoBack();
 }
 
-bool ArticleView::canGoForward()
+bool ArticleView::canGoForward() const
 {
   return ui.definition->history()->canGoForward();
 }
 
+#ifndef USE_QTWEBKIT
+void ArticleView::initProfilePreferences( QWebEngineProfile & profile, Config::Preferences const & preferences )
+{
+  Q_ASSERT( profile.scripts()->findScript( profilePreferencesScriptName() ).isNull() );
+  auto const script = createScript( profilePreferencesScriptName(), profilePreferencesScriptSourceCode( preferences ) );
+  profile.scripts()->insert( script );
+}
+
+void ArticleView::updateProfilePreferences( QWebEngineProfile & profile, Config::Preferences const & oldPreferences,
+                                            Config::Preferences const & newPreferences )
+{
+  if( !profilePreferencesChanged( oldPreferences, newPreferences ) )
+    return;
+  updateSourceCodeOfInjectedScript( *profile.scripts(), profilePreferencesScriptName(),
+                                    profilePreferencesScriptSourceCode( newPreferences ) );
+}
+#endif
+
 void ArticleView::setSelectionBySingleClick( bool set )
 {
+#ifdef USE_QTWEBKIT
   ui.definition->setSelectionBySingleClick( set );
+#else
+  if( set == static_cast< bool >( lastLeftMouseButtonPressEvent ) )
+    return; // nothing changed
+
+  if( set )
+    lastLeftMouseButtonPressEvent.reset( new MouseEventInfo{} );
+  else
+    lastLeftMouseButtonPressEvent.reset();
+
+  ui.definition->page()->runJavaScript( selectWordBySingleClickAssignmentScript( set ) );
+#endif
 }
 
 void ArticleView::back()
 {
-  // Don't allow navigating back to page 0, which is usually the initial
-  // empty page
   if ( canGoBack() )
   {
     saveHistoryUserData();
@@ -1701,61 +2262,64 @@ void ArticleView::forward()
 
 void ArticleView::reload()
 {
+  // Reloading occurs in response to changes that may affect content height, so restoring the
+  // current window position can cause uncontrolled jumps. Scrolling to the current article
+  // (i.e. jumping to he top of it) is simple, reliable and predictable, if not ideal.
+#ifdef USE_QTWEBKIT
   QMap< QString, QVariant > userData = ui.definition->history()->currentItem().userData().toMap();
 
   // Save current article, which can be empty
-  userData[ "currentArticle" ] = getCurrentArticle();
+  userData[ "currentArticle" ] = currentArticle;
 
-  // Remove saved window position. Reloading occurs in response to changes that
-  // may affect content height, so restoring the current window position can cause
-  // uncontrolled jumps. Scrolling to the current article (i.e. jumping to the top
-  // of it) is simple, reliable and predictable, if not ideal.
+  // Remove saved window position to request scrolling to the current article.
   userData[ "sx" ].clear();
   userData[ "sy" ].clear();
 
   ui.definition->history()->currentItem().setUserData( userData );
+#else
+  // Scroll to the current article only if the "regexp" query item value is empty.
+  // If it is not empty, highlightFTSResults() will most likely call
+  // QWebEngineView::findText(), which will scroll to the first match instead.
+  bool const scrollToCurrentArticle = QUrlQuery{ ui.definition->url() }
+          .queryItemValue( QStringLiteral( "regexp" ) ).isEmpty();
+  updateInjectedPageReloadingScript( scrollToCurrentArticle );
+#endif // USE_QTWEBKIT
 
   ui.definition->reload();
 }
 
-bool ArticleView::hasSound()
+bool ArticleView::hasSound() const
 {
-  QVariant v = ui.definition->page()->mainFrame()->evaluateJavaScript( "gdAudioLinks.first" );
-  if ( v.type() == QVariant::String )
-    return !v.toString().isEmpty();
-  return false;
+  return !firstAudioLink.isEmpty();
 }
 
 void ArticleView::playSound()
 {
-  QVariant v;
-  QString soundScript;
-
-  v = ui.definition->page()->mainFrame()->evaluateJavaScript( "gdAudioLinks[gdAudioLinks.current]" );
-
-  if ( v.type() == QVariant::String )
-    soundScript = v.toString();
-
   // fallback to the first one
-  if ( soundScript.isEmpty() )
-  {
-    v = ui.definition->page()->mainFrame()->evaluateJavaScript( "gdAudioLinks.first" );
-    if ( v.type() == QVariant::String )
-      soundScript = v.toString();
-  }
-
+  QString const soundScript = audioLinks.value( currentArticle, firstAudioLink );
   if ( !soundScript.isEmpty() )
     openLink( QUrl::fromEncoded( soundScript.toUtf8() ), ui.definition->url() );
 }
 
+#ifdef USE_QTWEBKIT
 QString ArticleView::toHtml()
 {
   return ui.definition->page()->mainFrame()->toHtml();
 }
+#else
+void ArticleView::toHtml( std::function< void( QString const & ) > resultCallback )
+{
+  ui.definition->page()->toHtml( std::move( resultCallback ) );
+}
+#endif
 
-QString ArticleView::getTitle()
+QString ArticleView::getTitle() const
 {
+#ifdef USE_QTWEBKIT
   return ui.definition->page()->mainFrame()->title();
+#else
+  return ui.definition->page()->title();
+#endif
 }
 
 Config::InputPhrase ArticleView::getPhrase() const
@@ -1767,17 +2331,29 @@ Config::InputPhrase ArticleView::getPhrase() const
 
 void ArticleView::print( QPrinter * printer ) const
 {
+#ifdef USE_QTWEBKIT
   ui.definition->print( printer );
+#else
+  // TODO (Qt WebEngine): port this function and its uses to QWebEnginePage::print(). From the documentation:
+  // "It is the users responsibility to ensure the printer remains valid until resultCallback has been called." =>
+  // consider capturing sptr< QPrinter > MainWindow::printer by value and calling sptr::reset() in the resultCallback.
+  Q_UNUSED( printer )
+#endif
 }
 
 void ArticleView::contextMenuRequested( QPoint const & pos )
 {
   // Is that a link? Is there a selection?
 
+#ifdef USE_QTWEBKIT
   QWebHitTestResult r = ui.definition->page()->mainFrame()->
                           hitTestContent( pos );
 
   updateCurrentArticleFromCurrentFrame( r.frame() );
+#else
+  auto const & r = ui.definition->page()->contextMenuData();
+  Q_ASSERT( r.isValid() );
+#endif
 
   QMenu menu( this );
 
@@ -1798,7 +2374,9 @@ void ArticleView::contextMenuRequested( QPoint const & pos )
   QUrl targetUrl( r.linkUrl() );
   Contexts contexts;
 
+#ifdef USE_QTWEBKIT
   tryMangleWebsiteClickedUrl( targetUrl, contexts );
+#endif
 
   if ( !r.linkUrl().isEmpty() )
   {
@@ -1819,19 +2397,25 @@ void ArticleView::contextMenuRequested( QPoint const & pos )
     {
       followLinkExternal = new QAction( tr( "Open Link in &External Browser" ), &menu );
       menu.addAction( followLinkExternal );
-      menu.addAction( ui.definition->pageAction( QWebPage::CopyLinkToClipboard ) );
+      menu.addAction( ui.definition->pageAction( WebPage::CopyLinkToClipboard ) );
     }
   }
 
-#if QT_VERSION >= 0x040600
-  QWebElement el = r.element();
   QUrl imageUrl;
-  if( !popupView && el.tagName().compare( "img", Qt::CaseInsensitive ) == 0 )
+  if( !popupView )
   {
-    imageUrl = QUrl::fromPercentEncoding( el.attribute( "src" ).toLatin1() );
+#ifdef USE_QTWEBKIT
+    QWebElement const el = r.element();
+    if( el.tagName().compare( "img", Qt::CaseInsensitive ) == 0 )
+      imageUrl = QUrl::fromPercentEncoding( el.attribute( "src" ).toLatin1() );
+#else
+    if( r.mediaType() == QWebEngineContextMenuData::MediaTypeImage )
+      imageUrl = r.mediaUrl();
+#endif
+
     if( !imageUrl.isEmpty() )
     {
-      menu.addAction( ui.definition->pageAction( QWebPage::CopyImageToClipboard ) );
+      menu.addAction( ui.definition->pageAction( WebPage::CopyImageToClipboard ) );
       saveImageAction = new QAction( tr( "Save &image..." ), &menu );
       menu.addAction( saveImageAction );
     }
@@ -1843,7 +2427,6 @@ void ArticleView::contextMenuRequested( QPoint const & pos )
     saveSoundAction = new QAction( tr( "Save s&ound..." ), &menu );
     menu.addAction( saveSoundAction );
   }
-#endif
 
   QString selectedText = ui.definition->selectedText();
   QString text = selectedText.trimmed();
@@ -1853,11 +2436,7 @@ void ArticleView::contextMenuRequested( QPoint const & pos )
     // We don't prompt for selections larger or equal to 60 chars, since
     // it ruins the menu and it's hardly a single word anyway.
 
-    if( text.isRightToLeft() )
-    {
-      text.insert( 0, (ushort)0x202E ); // RLE, Right-to-Left Embedding
-      text.append( (ushort)0x202C ); // PDF, POP DIRECTIONAL FORMATTING
-    }
+    Folding::prepareToEmbedRTL( text );
 
     lookupSelection = new QAction( tr( "&Look up \"%1\"" ).
                                    arg( text ),
@@ -1922,27 +2501,25 @@ void ArticleView::contextMenuRequested( QPoint const & pos )
 
   if ( selectedText.size() )
   {
-    menu.addAction( ui.definition->pageAction( QWebPage::Copy ) );
+    menu.addAction( ui.definition->pageAction( WebPage::Copy ) );
     menu.addAction( &copyAsTextAction );
   }
   else
   {
     menu.addAction( &selectCurrentArticleAction );
-    menu.addAction( ui.definition->pageAction( QWebPage::SelectAll ) );
+    menu.addAction( ui.definition->pageAction( WebPage::SelectAll ) );
   }
 
   map< QAction *, QString > tableOfContents;
 
   // Add table of contents
-  QStringList ids = getArticlesList();
-
-  if ( !menu.isEmpty() && ids.size() )
+  if ( !menu.isEmpty() && !articleList.empty() )
     menu.addSeparator();
 
   unsigned refsAdded = 0;
   bool maxDictionaryRefsReached = false;
 
-  for( QStringList::const_iterator i = ids.constBegin(); i != ids.constEnd();
+  for( QStringList::const_iterator i = articleList.constBegin(); i != articleList.constEnd();
        ++i, ++refsAdded )
   {
     // Find this dictionary
@@ -1993,13 +2570,13 @@ void ArticleView::contextMenuRequested( QPoint const & pos )
       return;
 
     if ( result == followLink )
-      openLink( targetUrl, ui.definition->url(), getCurrentArticle(), contexts );
+      openLink( targetUrl, ui.definition->url(), currentArticle, contexts );
     else
     if ( result == followLinkExternal )
       QDesktopServices::openUrl( r.linkUrl() );
     else
     if ( result == lookupSelection )
-      showDefinition( selectedText, getGroup( ui.definition->url() ), getCurrentArticle() );
+      showDefinition( selectedText, getGroup( ui.definition->url() ), currentArticle );
     else
     if ( result == lookupSelectionGr && groupComboBox )
       showDefinition( selectedText, groupComboBox->getCurrentGroup(), QString() );
@@ -2013,14 +2590,14 @@ void ArticleView::contextMenuRequested( QPoint const & pos )
       emit sendWordToInputLine( selectedText );
     else
     if ( !popupView && result == followLinkNewTab )
-      emit openLinkInNewTab( targetUrl, ui.definition->url(), getCurrentArticle(), contexts );
+      emit openLinkInNewTab( targetUrl, ui.definition->url(), currentArticle, contexts );
     else
     if ( !popupView && result == lookupSelectionNewTab )
-      emit showDefinitionInNewTab( selectedText, getGroup( ui.definition->url() ),
-                                   getCurrentArticle(), Contexts() );
+      emit showDefinitionInNewTab( Config::InputPhrase::fromPhrase( selectedText ), getGroup( ui.definition->url() ),
+                                   currentArticle, Contexts() );
     else
     if ( !popupView && result == lookupSelectionNewTabGr && groupComboBox )
-      emit showDefinitionInNewTab( selectedText, groupComboBox->getCurrentGroup(),
+      emit showDefinitionInNewTab( Config::InputPhrase::fromPhrase( selectedText ), groupComboBox->getCurrentGroup(),
                                    QString(), Contexts() );
     else
     if( result == saveImageAction || result == saveSoundAction )
@@ -2072,7 +2649,9 @@ void ArticleView::contextMenuRequested( QPoint const & pos )
       {
         QFileInfo fileInfo( fileName );
         emit storeResourceSavePath( QDir::toNativeSeparators( fileInfo.absoluteDir().absolutePath() ) );
-        saveResource( url, ui.definition->url(), fileName );
+
+        ResourceToSaveHandler * const handler = new ResourceToSaveHandler( this, fileName );
+        saveResource( url, ui.definition->url(), handler );
       }
 #endif
     }
@@ -2193,47 +2772,39 @@ void ArticleView::pasteTriggered()
       // so let's try the currently selected group.
       groupId = groupComboBox->getCurrentGroup();
     }
-    showDefinition( phrase, groupId, getCurrentArticle() );
+    showDefinition( phrase, groupId, currentArticle );
   }
 }
 
 void ArticleView::moveOneArticleUp()
 {
-  QString current = getCurrentArticle();
-
-  if ( current.size() )
+  if( !currentArticle.isEmpty() )
   {
-    QStringList lst = getArticlesList();
-
-    int idx = lst.indexOf( dictionaryIdFromScrollTo( current ) );
+    int idx = articleList.indexOf( dictionaryIdFromScrollTo( currentArticle ) );
 
     if ( idx != -1 )
     {
       --idx;
 
       if ( idx < 0 )
-        idx = lst.size() - 1;
+        idx = articleList.size() - 1;
 
-      setCurrentArticle( scrollToFromDictionaryId( lst[ idx ] ), true );
+      setCurrentArticle( scrollToFromDictionaryId( articleList.at( idx ) ), true );
     }
   }
 }
 
 void ArticleView::moveOneArticleDown()
 {
-  QString current = getCurrentArticle();
-
-  if ( current.size() )
+  if( !currentArticle.isEmpty() )
   {
-    QStringList lst = getArticlesList();
-
-    int idx = lst.indexOf( dictionaryIdFromScrollTo( current ) );
+    int idx = articleList.indexOf( dictionaryIdFromScrollTo( currentArticle ) );
 
     if ( idx != -1 )
     {
-      idx = ( idx + 1 ) % lst.size();
+      idx = ( idx + 1 ) % articleList.size();
 
-      setCurrentArticle( scrollToFromDictionaryId( lst[ idx ] ), true );
+      setCurrentArticle( scrollToFromDictionaryId( articleList.at( idx ) ), true );
     }
   }
 }
@@ -2258,11 +2829,10 @@ void ArticleView::openSearch()
 
   // Clear any current selection
   if ( ui.definition->selectedText().size() )
-  {
-    ui.definition->page()->currentFrame()->
-           evaluateJavaScript( "window.getSelection().removeAllRanges();_=0;" );
-  }
+    clearPageSelection();
 
+  // Don't display obsolete status from the previous search.
+  ui.searchStatusLabel->clear();
   if ( ui.searchText->property( "noResults" ).toBool() )
   {
     ui.searchText->setProperty( "noResults", false );
@@ -2309,118 +2879,294 @@ void ArticleView::on_highlightAllButton_clicked()
   performFindOperation( false, false, true );
 }
 
+#ifdef USE_QTWEBKIT
+void ArticleView::onJsPageInitStarted()
+#else
+void ArticleView::onJsPageInitStarted( QStringList const & loadedArticles, QStringList const & loadedAudioLinks,
+                                       int activeArticleIndex, bool hasPageInitFinished,
+                                       QDateTime const & pageTimestamp_ )
+#endif
+{
+  // When JavaScript code initialization starts, the previous page is definitely gone.
+  // Clear the data associated with it and prepare to receive the current page's data.
+
+  articleList.clear();
+  audioLinks.clear();
+  firstAudioLink.clear();
+  currentArticle.clear();
+
+  emit canGoBackForwardChanged( this );
+  emit pageUnloaded( this );
+
+#ifdef USE_QTWEBKIT
+  // In the Qt WebKit version loadFinished() for the initial Welcome! page is called before JavaScript execution on this
+  // initial page starts. Don't transition into the loading state if the current URL's group is the internal Help group,
+  // which contains the Welcome! page, to prevent being stuck in the loading state at GoldenDict start. Pages in the
+  // Help group are built into GoldenDict and are loaded instantly, so this workaround shouldn't be noticeable.
+  if( Qt4x5::Url::queryItemValue( ui.definition->url(), "group" ).toUInt() != Instances::Group::HelpGroupId )
+#endif
+  {
+    isLoading = true;
+    emit pageLoadingStateChanged( this, isLoading );
+  }
+
+#ifndef USE_QTWEBKIT
+  if( hideSearchFrameOnceJsSavesStateToWebHistory )
+  {
+    hideSearchFrameOnceJsSavesStateToWebHistory = false;
+    closeSearch();
+  }
+
+  // This is the first message from JavaScript on this page.
+  // Initialize our stored timestamps to the page timestamp received from JavaScript.
+  currentArticleTimestamp = pageTimestamp = pageTimestamp_;
+
+  if( loadedArticles.size() == loadedAudioLinks.size() )
+  {
+    for( int i = 0; i != loadedArticles.size(); ++i )
+      onJsArticleLoadedNoTimestamps( loadedArticles.at( i ), loadedAudioLinks.at( i ), i == activeArticleIndex );
+  }
+  else
+    gdWarning( "Loaded item list sizes don't match: %d != %d", loadedArticles.size(), loadedAudioLinks.size() );
+
+  if( hasPageInitFinished )
+    onJsPageInitFinished();
+#endif
+}
+
+#ifndef USE_QTWEBKIT
+void ArticleView::onJsPageInitFinished()
+{
+  if( currentArticle.isEmpty() && !articleList.empty() )
+  {
+    // Deferred JavaScript code silently activates the first article in this case. Do the same here.
+    setValidCurrentArticleNoJs( scrollToFromDictionaryId( articleList.constFirst() ) );
+  }
+
+  // Slots connected to ArticleView::pageLoaded signal, which is emitted from ArticleView::loadFinished(), may
+  // call ArticleView::playSound(), which requires up-to-date values of the current article and the audio links.
+  // So ArticleView::loadFinished() must not be invoked before this moment, even if QWebEngineView::loadFinished
+  // is emitted before gdArticleView becomes available (rarely, but happens). Calling it here works well.
+  loadFinished( true );
+}
+
+void ArticleView::onJsFirstLeftButtonMouseDown()
+{
+  if( !lastLeftMouseButtonPressEvent || !lastLeftMouseButtonPressEvent->isValid() )
+    return; // "Select word by single click" option is off or this is a synthesized mousedown event => nothing to do.
+
+  // The JavaScript mousedown event that invoked this function must represent the same user action as the stored
+  // lastLeftMouseButtonPressEvent. Generate a double click with the stored event's data.
+
+  // When "Select word by single click" option is on and more than one word is selected, clicking on one of the selected
+  // words reduces the selection to this single word in the Qt WebKit version. In the Qt WebEngine version clicking on
+  // one of the selected words has no effect. So the user has to click outside a selection to modify it. If the entire
+  // page is selected (e.g. after the Select All action is triggered), the user can resort to a middle mouse button
+  // click or press the left mouse button, move the cursor, then release the button.
+  // A consequence of this unchanging selection: when "Double-click translates the word clicked" option is on, double
+  // clicking on a selected word translates the entire selection, which can be considered a feature as it allows
+  // translating a phrase, not just a single word, using only the left mouse button.
+  // This selection issue can we worked around by sending an additional mouse release event, but then links are
+  // activated on left mouse button press rather than release, which is a worse bug.
+
+  // Even though a non-synthesized first MouseButtonPress event occurred just a few milliseconds ago, the web page
+  // treats a synthesized MouseButtonPress or MouseButtonDblClick event as a separate first click. Synthesize two
+  // identical events to generate a double click and select the word under cursor.
+  for( int i = 0; i < 2; ++i )
+    lastLeftMouseButtonPressEvent->synthesize( QEvent::MouseButtonPress, Qt::LeftButton );
+
+  // This stored event has served its purpose. Prevent recursion by invalidating it.
+  lastLeftMouseButtonPressEvent->invalidate();
+}
+
+void ArticleView::onJsDoubleClicked( QString const & imageUrl )
+{
+  if( !imageUrl.isEmpty() )
+  {
+    downloadImage( QUrl{ imageUrl } );
+    return;
+  }
+
+  if( cfg.preferences.doubleClickTranslates )
+  {
+    // Sanitize selected text before translating, because multiple words and punctuation
+    // marks can be selected during a prolonged double-click in the Qt WebEngine version.
+    auto const phrase = cfg.preferences.sanitizeInputPhrase( ui.definition->selectedText() );
+    if( phrase.isValid() )
+      translatePossiblyInNewTab( phrase );
+  }
+}
+#endif // USE_QTWEBKIT
+
+void ArticleView::onJsArticleLoaded( QString const & id, QString const & audioLink, bool isActive )
+{
+#ifndef USE_QTWEBKIT
+  // When JavaScript does not send the current article timestamp, it is implicitly equal to pageTimestamp.
+  // If currentArticleTimestamp != pageTimestamp, then our current article value is fresher => keep it.
+  // Keep isActive true if id == currentArticle (happens when the user activates an article while it is being loaded).
+  if( isActive && currentArticleTimestamp != pageTimestamp && id != currentArticle )
+    isActive = false;
+#endif
+
+  onJsArticleLoadedNoTimestamps( id, audioLink, isActive );
+}
+
+void ArticleView::onJsArticleLoadedNoTimestamps( QString const & id, QString const & audioLink, bool isActive )
+{
+  if( !isScrollTo( id ) )
+  {
+    gdWarning( "Invalid article ID received from JavaScript: %s", id.toUtf8().constData() );
+    return;
+  }
+
+  articleList.push_back( dictionaryIdFromScrollTo( id ) );
+  if( !audioLink.isEmpty() )
+  {
+    audioLinks.insert( id, audioLink );
+    if( firstAudioLink.isEmpty() )
+      firstAudioLink = audioLink;
+  }
+  if( isActive )
+    currentArticle = id;
+
+  emit articleLoaded( this, articleList.back(), isActive );
+}
+
+#ifdef USE_QTWEBKIT
 void ArticleView::onJsActiveArticleChanged(QString const & id)
+#else
+void ArticleView::onJsActiveArticleChanged( QString const & id, QDateTime const & currentArticleTimestamp_ )
+#endif
 {
   if ( !isScrollTo( id ) )
-    return; // Incorrect id
+  {
+    gdWarning( "Invalid active article ID received from JavaScript: %s", id.toUtf8().constData() );
+    return;
+  }
 
-  emit activeArticleChanged( this, dictionaryIdFromScrollTo( id ) );
+#ifndef USE_QTWEBKIT
+  // Compare the received and stored current article timestamps using operator< here and using
+  // operator<= in the JavaScript code to ensure that the current article values are always consistent,
+  // even if the user manages to activate different articles in JavaScript and C++ at the same time.
+  if( currentArticleTimestamp_ < currentArticleTimestamp )
+    return; // Our current article value is fresher => keep it.
+  currentArticleTimestamp = currentArticleTimestamp_;
+#endif
+
+  setValidCurrentArticleNoJs( id );
+}
+
+void ArticleView::onJsLocationHashChanged()
+{
+  emit canGoBackForwardChanged( this ); // Fragment navigation on the same page adds a web history entry.
 }
 
+#ifdef USE_QTWEBKIT
 void ArticleView::doubleClicked( QPoint pos )
 {
-#if QT_VERSION >= 0x040600
   QWebHitTestResult r = ui.definition->page()->mainFrame()->hitTestContent( pos );
   QWebElement el = r.element();
-  QUrl imageUrl;
   if( el.tagName().compare( "img", Qt::CaseInsensitive ) == 0 )
   {
     // Double click on image; download it and transfer to external program
-
-    imageUrl = QUrl::fromPercentEncoding( el.attribute( "src" ).toLatin1() );
+    QUrl const imageUrl = QUrl::fromPercentEncoding( el.attribute( "src" ).toLatin1() );
     if( !imageUrl.isEmpty() )
-    {
-      // Download it
+      downloadImage( imageUrl );
+    return;
+  }
 
-      // Clear any pending ones
-      resourceDownloadRequests.clear();
+  // We might want to initiate translation of the selected word
+  if( cfg.preferences.doubleClickTranslates )
+  {
+    QString const selectedText = ui.definition->selectedText();
+    // Do some checks to make sure there's a sensible selection indeed
+    if( !Folding::applyWhitespaceOnly( gd::toWString( selectedText ) ).empty() && selectedText.size() < 60 )
+      translatePossiblyInNewTab( Config::InputPhrase::fromPhrase( selectedText ) );
+  }
+}
+#endif // USE_QTWEBKIT
 
-      resourceDownloadUrl = imageUrl;
-      sptr< Dictionary::DataRequest > req;
+void ArticleView::downloadImage( QUrl const & imageUrl )
+{
+  // Clear any pending ones
+  resourceDownloadRequests.clear();
 
-      if ( imageUrl.scheme() == "http" || imageUrl.scheme() == "https" || imageUrl.scheme() == "ftp" )
-      {
-        // Web resource
-        req = new Dictionary::WebMultimediaDownload( imageUrl, articleNetMgr );
-      }
-      else
-      if ( imageUrl.scheme() == "bres" || imageUrl.scheme() == "gdpicture" )
-      {
-        // Local resource
-        QString contentType;
-        req = articleNetMgr.getResource( imageUrl, contentType );
-      }
-      else
-      {
-        // Unsupported scheme
-        gdWarning( "Unsupported url scheme \"%s\" to download image\n", imageUrl.scheme().toUtf8().data() );
-        return;
-      }
+  resourceDownloadUrl = imageUrl;
+  sptr< Dictionary::DataRequest > req;
 
-      if ( !req.get() )
-      {
-        // Request failed, fail
-        gdWarning( "Can't create request to download image \"%s\"\n", imageUrl.toString().toUtf8().data() );
-        return;
-      }
+  if ( imageUrl.scheme() == "http" || imageUrl.scheme() == "https" || imageUrl.scheme() == "ftp" )
+  {
+    // Web resource
+    req = new Dictionary::WebMultimediaDownload( imageUrl, articleNetMgr );
+  }
+  else
+  if ( imageUrl.scheme() == "bres" || imageUrl.scheme() == "gdpicture" )
+  {
+    // Local resource
+    QString contentType;
+    req = articleNetMgr.getResource( imageUrl, contentType );
+  }
+  else
+  {
+    // Unsupported scheme
+    gdWarning( "Unsupported url scheme \"%s\" to download image\n", imageUrl.scheme().toUtf8().data() );
+    return;
+  }
 
-      if ( req->isFinished() && req->dataSize() >= 0 )
-      {
-        // Have data ready, handle it
-        resourceDownloadRequests.push_back( req );
-        resourceDownloadFinished();
-        return;
-      }
-      else
-      if ( !req->isFinished() )
-      {
-        // Queue to be handled when done
-        resourceDownloadRequests.push_back( req );
-        connect( req.get(), SIGNAL( finished() ), this, SLOT( resourceDownloadFinished() ) );
-      }
-      if ( resourceDownloadRequests.empty() ) // No requests were queued
-      {
-        gdWarning( "The referenced resource \"%s\" doesn't exist\n", imageUrl.toString().toUtf8().data() ) ;
-        return;
-      }
-      else
-        resourceDownloadFinished(); // Check any requests finished already
-    }
+  if ( !req.get() )
+  {
+    // Request failed, fail
+    gdWarning( "Can't create request to download image \"%s\"\n", imageUrl.toString().toUtf8().data() );
     return;
   }
-#endif
 
-  // We might want to initiate translation of the selected word
+  if ( req->isFinished() && req->dataSize() >= 0 )
+  {
+    // Have data ready, handle it
+    resourceDownloadRequests.push_back( req );
+    resourceDownloadFinished();
+    return;
+  }
+  else
+  if ( !req->isFinished() )
+  {
+    // Queue to be handled when done
+    resourceDownloadRequests.push_back( req );
+    connect( req.get(), SIGNAL( finished() ), this, SLOT( resourceDownloadFinished() ) );
+  }
+  if ( resourceDownloadRequests.empty() ) // No requests were queued
+  {
+    gdWarning( "The referenced resource \"%s\" doesn't exist\n", imageUrl.toString().toUtf8().data() ) ;
+    return;
+  }
+  else
+    resourceDownloadFinished(); // Check any requests finished already
+}
 
-  if ( cfg.preferences.doubleClickTranslates )
+void ArticleView::translatePossiblyInNewTab( Config::InputPhrase const & phrase )
+{
+  Q_ASSERT( phrase.isValid() );
+
+  Qt::KeyboardModifiers kmod = QApplication::keyboardModifiers();
+  if (kmod & (Qt::ControlModifier | Qt::ShiftModifier))
+  { // open in new tab
+    // TODO: emitting this signal has no effect in the scan popup's view.
+    //       Should showDefinition() be called if popupView is true?
+    emit showDefinitionInNewTab( phrase, getGroup( ui.definition->url() ),
+                                 currentArticle, Contexts() );
+  }
+  else
   {
-    QString selectedText = ui.definition->selectedText();
+    QUrl const & ref = ui.definition->url();
 
-    // Do some checks to make sure there's a sensible selection indeed
-    if ( Folding::applyWhitespaceOnly( gd::toWString( selectedText ) ).size() &&
-         selectedText.size() < 60 )
+    if( Qt4x5::Url::hasQueryItem( ref, "dictionaries" ) )
     {
-      // Initiate translation
-      Qt::KeyboardModifiers kmod = QApplication::keyboardModifiers();
-      if (kmod & (Qt::ControlModifier | Qt::ShiftModifier))
-      { // open in new tab
-        emit showDefinitionInNewTab( selectedText, getGroup( ui.definition->url() ),
-                                     getCurrentArticle(), Contexts() );
-      }
-      else
-      {
-        QUrl const & ref = ui.definition->url();
-
-        if( Qt4x5::Url::hasQueryItem( ref, "dictionaries" ) )
-        {
-          QStringList dictsList = Qt4x5::Url::queryItemValue(ref, "dictionaries" )
-                                              .split( ",", Qt4x5::skipEmptyParts() );
-          showDefinition( selectedText, dictsList, QRegExp(), getGroup( ref ), false );
-        }
-        else
-          showDefinition( selectedText, getGroup( ref ), getCurrentArticle() );
-      }
+      QStringList dictsList = Qt4x5::Url::queryItemValue(ref, "dictionaries" )
+                                          .split( ",", Qt4x5::skipEmptyParts() );
+      showDefinition( phrase, dictsList, QRegExp(), getGroup( ref ), false );
     }
+    else
+      showDefinition( phrase, getGroup( ref ), currentArticle );
   }
 }
 
@@ -2431,23 +3177,16 @@ void ArticleView::performFindOperation( bool restart, bool backwards, bool check
 
   if ( restart || checkHighlight )
   {
+#ifdef USE_QTWEBKIT
     if( restart ) {
       // Anyone knows how we reset the search position?
       // For now we resort to this hack:
       if ( ui.definition->selectedText().size() )
-      {
-        ui.definition->page()->currentFrame()->
-               evaluateJavaScript( "window.getSelection().removeAllRanges();_=0;" );
-      }
+        clearPageSelection();
     }
 
-    QWebPage::FindFlags f;
-
-    if ( ui.searchCaseSensitive->isChecked() )
-      f |= QWebPage::FindCaseSensitively;
-#if QT_VERSION >= 0x040600
+    QWebPage::FindFlags f = caseSensitivityFindFlags( ui.searchCaseSensitive->isChecked() );
     f |= QWebPage::HighlightAllOccurrences;
-#endif
 
     ui.definition->findText( "", f );
 
@@ -2456,23 +3195,80 @@ void ArticleView::performFindOperation( bool restart, bool backwards, bool check
 
     if( checkHighlight )
       return;
-  }
+#else
+    Q_ASSERT_X( !checkHighlight, Q_FUNC_INFO,
+                "Toggling Web Engine page highlighting is not and cannot be implemented." );
+    // Skip UI status update after the special empty-string search to prevent a flashing
+    // of no-results style and status text. When text is empty though, this special
+    // empty-string search is the only one, so the UI status has to be updated then.
+    if( !text.isEmpty() )
+      skipNextFindTextUiStatusUpdate = true;
+    // Searching for an empty string is useful in 3 ways:
+    // 1) clear the search highlight when case sensitivity is toggled;
+    // 2) update the search status text;
+    // 3) search from the beginning of the page rather than from the current match position.
+    ui.definition->findText( QString{}, QWebEnginePage::FindFlags{} );
+    // Clearing the page selection is also necessary to search from the beginning of
+    // the page rather than from the current match position. When text is empty, this
+    // call is also useful: clears the selection of the last active findText() match.
+    clearPageSelection();
+#endif // USE_QTWEBKIT
+  }
+
+  WebPage::FindFlags f = caseSensitivityFindFlags( ui.searchCaseSensitive->isChecked() );
+  if ( backwards )
+    f |= WebPage::FindBackward;
+
+#ifdef USE_QTWEBKIT
+  bool const noResults = !text.isEmpty() && !ui.definition->findText( text, f );
+  updateSearchNoResultsProperty( noResults );
+#else
+  if( !text.isEmpty() )
+    ui.definition->findText( text, f );
+  // findTextFinished() will update the search status text and noResults property asynchronously.
+#endif
+}
 
-  QWebPage::FindFlags f;
+#ifndef USE_QTWEBKIT
+namespace {
+struct FindTextUiStatus
+{
+  QString statusText;
+  bool noResults;
+};
+FindTextUiStatus computeFindTextUiStatus( QString const & searchedText,
+                                          QWebEngineFindTextResult const & result )
+{
+  if( searchedText.isEmpty() )
+    return { QString(), false }; // An empty text is never found. Don't warn about it.
 
-  if ( ui.searchCaseSensitive->isChecked() )
-    f |= QWebPage::FindCaseSensitively;
+  auto const matchCount = result.numberOfMatches();
+  if( matchCount == 0 )
+    return { searchStatusMessageNoMatches(), true };
 
-  if ( backwards )
-    f |= QWebPage::FindBackward;
+  return { searchStatusMessage( result.activeMatch(), matchCount ), false };
+}
 
-  bool setMark = text.size() && !ui.definition->findText( text, f );
+} // unnamed namespace
 
-  if ( ui.searchText->property( "noResults" ).toBool() != setMark )
+void ArticleView::findTextFinished( QWebEngineFindTextResult const & result )
+{
+  if( !searchIsOpened || skipNextFindTextUiStatusUpdate )
   {
-    ui.searchText->setProperty( "noResults", setMark );
+    skipNextFindTextUiStatusUpdate = false;
+    return;
+  }
+  auto const uiStatus = computeFindTextUiStatus( ui.searchText->text(), result );
+  ui.searchStatusLabel->setText( uiStatus.statusText );
+  updateSearchNoResultsProperty( uiStatus.noResults );
+}
+#endif // USE_QTWEBKIT
 
-    // Reload stylesheet
+void ArticleView::updateSearchNoResultsProperty( bool noResults )
+{
+  if( ui.searchText->property( "noResults" ).toBool() != noResults )
+  {
+    ui.searchText->setProperty( "noResults", noResults );
     reloadStyleSheet();
   }
 }
@@ -2489,13 +3285,16 @@ void ArticleView::reloadStyleSheet()
   }
 }
 
-
 bool ArticleView::closeSearch()
 {
   if ( searchIsOpened )
   {
-    ui.searchFrame->hide();
+    // Give focus to the view to enable keyboard navigation on the page.
+    // Transferring the focus before hiding the search frame works around the highlighting of and especially
+    // the scrolling to the first link on the page when searchFrame has focus in the Qt WebEngine version.
     ui.definition->setFocus();
+
+    ui.searchFrame->hide();
     searchIsOpened = false;
 
     return true;
@@ -2511,12 +3310,10 @@ bool ArticleView::closeSearch()
     ui.ftsSearchFrame->hide();
     ui.definition->setFocus();
 
-    QWebPage::FindFlags flags;
-
-  #if QT_VERSION >= 0x040600
+    WebPage::FindFlags flags;
+#ifdef USE_QTWEBKIT
     flags |= QWebPage::HighlightAllOccurrences;
-  #endif
-
+#endif
     ui.definition->findText( "", flags );
 
     return true;
@@ -2563,7 +3360,7 @@ void ArticleView::copyAsText()
 
 void ArticleView::inspect()
 {
-  ui.definition->triggerPageAction( QWebPage::InspectElement );
+  ui.definition->triggerPageAction( WebPage::InspectElement );
 }
 
 void ArticleView::highlightFTSResults()
@@ -2610,17 +3407,52 @@ void ArticleView::highlightFTSResults()
   regexp.setMinimal( true );
 #endif
 
-  sptr< AccentMarkHandler > marksHandler = ignoreDiacritics ?
-                                           new DiacriticsHandler : new AccentMarkHandler;
-
-  // Clear any current selection
+#ifdef USE_QTWEBKIT
+  // Clear any current selection. QWebView::selectedText() is not empty here if the user full-text-searches
+  // for a common word, picks a result with many large articles in the Full-text search dialog, then quickly
+  // selects text in the first article while the page is still loading.
+  // At this point QWebEngineView::selectedText() is equal to the last highlighted word if the user selects
+  // a second result in the Full-text search dialog without clicking on the article view after the previous
+  // FTS result was displayed there. This existing selection is not a problem in the Qt WebEngine version =>
+  // don't waste CPU time and risk bugs by clearing it.
   if ( ui.definition->selectedText().size() )
-  {
-    ui.definition->page()->currentFrame()->
-           evaluateJavaScript( "window.getSelection().removeAllRanges();_=0;" );
-  }
+    clearPageSelection();
 
   QString pageText = ui.definition->page()->currentFrame()->toPlainText();
+  highlightFTSResults( regexp, ignoreDiacritics, pageText );
+#else
+  ui.definition->page()->toPlainText( [ this, url, regexp, ignoreDiacritics ]( QString const & pageText) {
+    if( pageText.isEmpty() )
+      return; // Most likely this callback is being called during page destruction. Return now to prevent a crash.
+    if( ui.definition->url() != url )
+      return; // Anoter URL has been loaded before this callback got invoked => the highlighting is obsolete.
+    highlightFTSResults( regexp, ignoreDiacritics, pageText );
+  } );
+#endif
+}
+
+// TODO (Qt WebEngine): there are multiple issues with the FTS highlighting and result navigation:
+// 1. Only the words equal to the last found result are highlighted, not all FTS matches as in the Qt WebKit version.
+// 2. QWebEngineView::findText() never finds the end-of-line character. Maybe some other characters too.
+//    This breaks FTS result navigation on a page when such characters are matched in the search.
+// Fixing or working around these QWebEngineView::findText() limitations may prove more difficult than
+// implementing finding and highlighting regular expressions on a page via JavaScript.
+// There seems to be no way to overcome these issues even using the Qt WebEngine's upstream Blink API:
+// https://chromium.googlesource.com/chromium/src/+/HEAD/third_party/blink/public/mojom/frame/find_in_page.mojom
+// One more issue affects the Qt WebKit version too: when the regexp matches at word boundaries (in the "Whole words"
+// or the RegExp mode), QWeb[Engine]View::findText() may find extra results, because the plain-text search cannot be
+// limited by boundaries. These extra results can mess up the FTS result navigation if not all elements of allMatches
+// are equal (some matches could be skipped).
+// So reimplementing this functionality in JavaScript could improve the Qt WebKit version too.
+#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
+void ArticleView::highlightFTSResults( QRegularExpression const & regexp,
+#else
+void ArticleView::highlightFTSResults( QRegExp const & regexp,
+#endif
+                                       bool ignoreDiacritics, QString const & pageText )
+{
+  sptr< AccentMarkHandler > const marksHandler = ignoreDiacritics ?
+                                                 new DiacriticsHandler : new AccentMarkHandler;
   marksHandler->setText( pageText );
 
 #if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
@@ -2677,17 +3509,15 @@ void ArticleView::highlightFTSResults()
   }
 #endif
 
-  ftsSearchMatchCase = Qt4x5::Url::hasQueryItem( url, "matchcase" );
+  ftsSearchMatchCase = Qt4x5::Url::hasQueryItem( ui.definition->url(), "matchcase" );
 
-  QWebPage::FindFlags flags;
-
-  if( ftsSearchMatchCase )
-    flags |= QWebPage::FindCaseSensitively;
+  WebPage::FindFlags const flags = caseSensitivityFindFlags( ftsSearchMatchCase );
 
   if( allMatches.isEmpty() )
     ui.ftsSearchStatusLabel->setText( searchStatusMessageNoMatches() );
   else
   {
+#ifdef USE_QTWEBKIT
     highlightAllFtsOccurences( flags );
     if( ui.definition->findText( allMatches.at( 0 ), flags ) )
     {
@@ -2695,6 +3525,9 @@ void ArticleView::highlightFTSResults()
                evaluateJavaScript( QString( "%1=window.getSelection().getRangeAt(0);_=0;" )
                                    .arg( rangeVarName ) );
     }
+#else
+    ui.definition->findText( allMatches.constFirst(), flags );
+#endif
     Q_ASSERT( ftsPosition == 0 );
     ui.ftsSearchStatusLabel->setText( searchStatusMessage( 1, allMatches.size() ) );
   }
@@ -2706,6 +3539,7 @@ void ArticleView::highlightFTSResults()
   ftsSearchIsOpened = true;
 }
 
+#ifdef USE_QTWEBKIT
 void ArticleView::highlightAllFtsOccurences( QWebPage::FindFlags flags )
 {
   flags |= QWebPage::HighlightAllOccurrences;
@@ -2726,6 +3560,7 @@ void ArticleView::highlightAllFtsOccurences( QWebPage::FindFlags flags )
   for( QSet< QString >::const_iterator it = uniqueMatches.constBegin(); it != uniqueMatches.constEnd(); ++it )
     ui.definition->findText( *it, flags );
 }
+#endif // USE_QTWEBKIT
 
 void ArticleView::performFtsFindOperation( bool backwards )
 {
@@ -2740,12 +3575,16 @@ void ArticleView::performFtsFindOperation( bool backwards )
     return;
   }
 
-  QWebPage::FindFlags flags;
-
-  if( ftsSearchMatchCase )
-    flags |= QWebPage::FindCaseSensitively;
+#ifndef USE_QTWEBKIT
+  // QWebEngineView::findText() always wraps around document, but it does not always scroll to the
+  // wrapped-around first or last result (bug?) => "disable" the wraparound by returning early here.
+  if( ( backwards && ftsPosition == 0 ) || ( !backwards && ftsPosition == allMatches.size() - 1 ) )
+    return;
+#endif
 
+  WebPage::FindFlags flags = caseSensitivityFindFlags( ftsSearchMatchCase );
 
+#ifdef USE_QTWEBKIT
   // Restore saved highlighted selection
   ui.definition->page()->currentFrame()->
          evaluateJavaScript( QString( "var sel=window.getSelection();sel.removeAllRanges();sel.addRange(%1);_=0;" )
@@ -2783,12 +3622,30 @@ void ArticleView::performFtsFindOperation( bool backwards )
       ui.ftsSearchPrevious->setEnabled( res );
   }
 
-  ui.ftsSearchStatusLabel->setText( searchStatusMessage( ftsPosition + 1, allMatches.size() ) );
-
   // Store new highlighted selection
   ui.definition->page()->currentFrame()->
          evaluateJavaScript( QString( "%1=window.getSelection().getRangeAt(0);_=0;" )
                              .arg( rangeVarName ) );
+#else
+  // Clearing selection here ensures that the search continues from the last match,
+  // no matter what the user clicked or selected since the last FTS find operation.
+  clearPageSelection();
+
+  if( backwards )
+  {
+    --ftsPosition;
+    flags |= QWebEnginePage::FindBackward;
+  }
+  else
+    ++ftsPosition;
+
+  ui.definition->findText( allMatches.at( ftsPosition ), flags );
+
+  ui.ftsSearchNext->setEnabled( ftsPosition != allMatches.size() - 1 );
+  ui.ftsSearchPrevious->setEnabled( ftsPosition != 0 );
+#endif // USE_QTWEBKIT
+
+  ui.ftsSearchStatusLabel->setText( searchStatusMessage( ftsPosition + 1, allMatches.size() ) );
 }
 
 void ArticleView::on_ftsSearchPrevious_clicked()
@@ -2801,6 +3658,7 @@ void ArticleView::on_ftsSearchNext_clicked()
   performFtsFindOperation( false );
 }
 
+#ifdef USE_QTWEBKIT
 #ifdef Q_OS_WIN32
 
 void ArticleView::readTag( const QString & from, QString & to, int & count )
@@ -3045,7 +3903,8 @@ QString ArticleView::wordAtPoint( int x, int y )
   return word;
 }
 
-#endif
+#endif // Q_OS_WIN32
+#endif // USE_QTWEBKIT
 
 ResourceToSaveHandler::ResourceToSaveHandler(ArticleView * view, QString const & fileName ) :
   QObject( view ),
@@ -3084,6 +3943,8 @@ void ResourceToSaveHandler::downloadFinished()
         vector< char > const & data = (*i)->getFullData();
         resourceData = QByteArray( data.data(), data.size() );
 
+        emit downloaded( fileName, &resourceData );
+
         // Write data to file
 
         if ( !fileName.isEmpty() )
diff --git a/articleview.hh b/articleview.hh
index 489bda0b..aa831f2e 100644
--- a/articleview.hh
+++ b/articleview.hh
@@ -4,7 +4,7 @@
 #ifndef __ARTICLEVIEW_HH_INCLUDED__
 #define __ARTICLEVIEW_HH_INCLUDED__
 
-#include <QWebView>
+#include <QHash>
 #include <QMap>
 #include <QUrl>
 #include <QSet>
@@ -15,6 +15,19 @@
 #include "groupcombobox.hh"
 #include "ui_articleview.h"
 
+#ifdef USE_QTWEBKIT
+#include <QWebView>
+#else
+#include <QDateTime>
+
+#include <functional>
+#include <memory>
+
+class QWebEngineFindTextResult;
+class QWebEngineProfile;
+class QWebEngineScriptCollection;
+#endif
+
 class ArticleViewJsProxy;
 class ResourceToSaveHandler;
 
@@ -35,13 +48,56 @@ class ArticleView: public QFrame
 
   ArticleViewJsProxy * const jsProxy;
 
+  QStringList articleList; ///< All articles currently present in the view as a list of dictionary ids.
+  QHash< QString, QString > audioLinks;
+  QString firstAudioLink;
+  QString currentArticle; ///< Current article in the view, in the form of "gdfrom-xxx"
+                          ///< (scrollTo) id. If empty, there is no current article.
+#ifndef USE_QTWEBKIT
+  // The timestamps are stored here and in JavaScript global variables with "gd" name prefixes.
+  // They prevent timing issues when a current article is passed to/from JavaScript.
+
+  /// The page timestamp is initialized to the current date and time when JavaScript page initialization
+  /// code starts. This timestamp allows JavaScript's gdOnCppActiveArticleChanged() to reject C++'s
+  /// current article updates pertaining to a previously loaded page.
+  QDateTime pageTimestamp;
+  /// currentArticleTimestamp and its JavaScript counterpart are initialized to pageTimestamp. They are
+  /// set to a current date and time when the user activates an article in some way, and are sent to
+  /// the other (JavaScript or C++) side along with the updated current article value. The receiver of
+  /// the current article update message compares the received timestamp value with its own stored
+  /// current article timestamp and rejects the current article change if the stored timestamp is later.
+  QDateTime currentArticleTimestamp;
+#endif
+
   QAction pasteAction, articleUpAction, articleDownAction,
           goBackAction, goForwardAction, selectCurrentArticleAction,
           copyAsTextAction, inspectAction;
   QAction & openSearchAction;
   bool searchIsOpened;
   bool expandOptionalParts;
+  bool isLoading;
+#ifdef USE_QTWEBKIT
+  // The code that uses this variable is not needed in the Qt WebEngine version.
   QString rangeVarName;
+#else
+  /// Depending on how fast a next page is loaded, the blank page is present in or absent from
+  /// web history in the Qt WebEngine version. It is always absent in the Qt WebKit version.
+  /// This cache variable allows to make canGoBack() correct and faster than the alternative -
+  /// an expensive call to QWebEngineHistoryItem::url() and comparing the URL's scheme to "data".
+  bool isBlankPagePresentInWebHistory = false;
+  // The API necessary to implement Search-in-page status is not available in Qt WebKit.
+  bool skipNextFindTextUiStatusUpdate = false;
+  /// Hiding a search frame in showDefinition() results in storing a wrong vertical scroll position in web history.
+  /// Instead, showDefinition() sets this variable to true, and the search frame is hidden later in
+  /// onJsPageInitStarted() - after the previous page stores correct vertical scroll position in web history.
+  bool hideSearchFrameOnceJsSavesStateToWebHistory = false;
+
+  // In the Qt WebKit version ArticleWebView implements the functionality of the following data members.
+  bool isNavigationByMiddleMouseButton = false;
+  class MouseEventInfo;
+  /// @invariant This event info is non-null if and only if "Select word by single click" option is on.
+  std::unique_ptr< MouseEventInfo > lastLeftMouseButtonPressEvent;
+#endif
 
   /// Any resource we've decided to download off the dictionary gets stored here.
   /// Full vector capacity is used for search requests, where we have to make
@@ -63,7 +119,18 @@ class ArticleView: public QFrame
   int ftsPosition;
 
   void highlightFTSResults();
+#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
+  void highlightFTSResults( QRegularExpression const & regexp,
+#else
+  void highlightFTSResults( QRegExp const & regexp,
+#endif
+                            bool ignoreDiacritics, QString const & pageText );
+
+#ifdef USE_QTWEBKIT
+  // The API necessary to highlight all FTS occurrences is not available in Qt WebEngine.
   void highlightAllFtsOccurences( QWebPage::FindFlags flags );
+#endif
+
   void performFtsFindOperation( bool backwards );
 
 public:
@@ -72,11 +139,14 @@ public:
   /// The groups aren't copied -- rather than that, the reference is kept
   ArticleView( QWidget * parent,
                ArticleNetworkAccessManager &,
+#ifndef USE_QTWEBKIT
+               QWebEngineProfile &,
+#endif
                AudioPlayerPtr const &,
                std::vector< sptr< Dictionary::Class > > const & allDictionaries,
                Instances::Groups const &,
                bool popupView,
-               Config::Class const & cfg,
+               Config::Class & cfg_,
                QAction & openSearchAction_,
                QAction * dictionaryBarToggled = 0,
                GroupComboBox const * groupComboBox = 0 );
@@ -90,6 +160,8 @@ public:
 
   ~ArticleView();
 
+  void saveConfigData() const;
+
   typedef QMap< QString, QString > Contexts;
 
   /// Returns "gdfrom-" + dictionaryId.
@@ -104,18 +176,14 @@ public:
   void showDefinition( Config::InputPhrase const & phrase, unsigned group,
                        QString const & scrollTo = QString(),
                        Contexts const & contexts = Contexts() );
-
   void showDefinition( QString const & word, unsigned group,
                        QString const & scrollTo = QString(),
                        Contexts const & contexts = Contexts() );
 
+  void showDefinition( Config::InputPhrase const & phrase, QStringList const & dictIDs,
+                       QRegExp const & searchRegExp, unsigned group, bool ignoreDiacritics );
   void showDefinition( QString const & word, QStringList const & dictIDs,
-                       QRegExp const & searchRegExp, unsigned group,
-                       bool ignoreDiacritics );
-
-  /// Clears the view and sets the application-global waiting cursor,
-  /// which will be restored when some article loads eventually.
-  void showAnticipation();
+                       QRegExp const & searchRegExp, unsigned group, bool ignoreDiacritics );
 
   /// Opens the given link. Supposed to be used in response to
   /// openLinkInNewTab() signal. The link scheme is therefore supposed to be
@@ -131,8 +199,17 @@ public:
   /// The function reloads content if the change affects it.
   void updateMutedContents();
 
-  bool canGoBack();
-  bool canGoForward();
+  bool isPageLoading() const
+  { return isLoading; }
+
+  bool canGoBack() const;
+  bool canGoForward() const;
+
+#ifndef USE_QTWEBKIT
+  static void initProfilePreferences( QWebEngineProfile & profile, Config::Preferences const & preferences );
+  static void updateProfilePreferences( QWebEngineProfile & profile, Config::Preferences const & oldPreferences,
+                                        Config::Preferences const & newPreferences );
+#endif
 
   /// Called when preference changes
   void setSelectionBySingleClick( bool set );
@@ -155,7 +232,7 @@ public:
   void reload();
 
   /// Returns true if there's an audio reference on the page, false otherwise.
-  bool hasSound();
+  bool hasSound() const;
 
   /// Plays the first audio reference on the page, if any.
   void playSound();
@@ -164,10 +241,14 @@ public:
   { ui.definition->setZoomFactor( factor ); }
 
   /// Returns current article's text in .html format
+#ifdef USE_QTWEBKIT
   QString toHtml();
+#else
+  void toHtml( std::function< void( QString const & ) > resultCallback );
+#endif
 
   /// Returns current article's title
-  QString getTitle();
+  QString getTitle() const;
 
   /// Returns the phrase translated by the current article.
   Config::InputPhrase getPhrase() const;
@@ -187,13 +268,12 @@ public:
 
   /// Returns all articles currently present in view, as a list of dictionary
   /// string ids.
-  QStringList getArticlesList();
+  QStringList getArticleList() const;
 
   /// Returns the dictionary id of the currently active article in the view.
   QString getActiveArticleId();
 
-  ResourceToSaveHandler * saveResource( const QUrl & url, const QString & fileName );
-  ResourceToSaveHandler * saveResource( const QUrl & url, const QUrl & ref, const QString & fileName );
+  void saveResource( QUrl const & url, ResourceToSaveHandler & handler );
 
   /// Return group id of the view
   unsigned getViewGroup()
@@ -205,6 +285,13 @@ signals:
 
   void titleChanged( ArticleView *, QString const & title );
 
+  void pageLoadingStateChanged( ArticleView *, bool isLoading );
+
+  /// Is emitted when the return value of canGoBack() or canGoForward() may have changed.
+  void canGoBackForwardChanged( ArticleView * );
+
+  void pageUnloaded( ArticleView * );
+  void articleLoaded( ArticleView *, QString const & id, bool isActive );
   void pageLoaded( ArticleView * );
 
   /// Signals that the following link was requested to be opened in new tab
@@ -212,7 +299,7 @@ signals:
                          QString const & fromArticle,
                          ArticleView::Contexts const & contexts );
   /// Signals that the following definition was requested to be showed in new tab
-  void showDefinitionInNewTab( QString const & word, unsigned group,
+  void showDefinitionInNewTab( Config::InputPhrase const & phrase, unsigned group,
                                QString const & fromArticle,
                                ArticleView::Contexts const & contexts );
 
@@ -255,8 +342,6 @@ public slots:
   void on_searchPrevious_clicked();
   void on_searchNext_clicked();
 
-  void onJsActiveArticleChanged(QString const & id);
-
   /// Handles F3 and Shift+F3 for search navigation
   bool handleF3( QObject * obj, QEvent * ev );
 
@@ -272,9 +357,12 @@ private slots:
   void loadFinished( bool ok );
   void handleTitleChanged( QString const & title );
   void handleUrlChanged( QUrl const & url );
+#ifdef USE_QTWEBKIT
   void attachToJavaScript();
+#endif
   void linkClicked( QUrl const & );
-  void linkHovered( const QString & link, const QString & title, const QString & textContent );
+  void linkHovered( QString const & link, QString const & title = QString(),
+                    QString const & textContent = QString() );
   void contextMenuRequested( QPoint const & );
 
   void resourceDownloadFinished();
@@ -300,8 +388,10 @@ private slots:
   void on_ftsSearchPrevious_clicked();
   void on_ftsSearchNext_clicked();
 
+#ifdef USE_QTWEBKIT
   /// Handles the double-click from the definition.
   void doubleClicked( QPoint pos );
+#endif
 
   /// Handles audio player error message
   void audioPlayerError( QString const & message );
@@ -313,28 +403,79 @@ private slots:
   void inspect();
 
 private:
+  /// <JavaScript interface>
+
+  friend class ArticleViewJsProxy;
+
+#ifdef USE_QTWEBKIT
+  void onJsPageInitStarted();
+
+  void onJsActiveArticleChanged( QString const & id );
+#else
+  /// In the Qt WebEngine version, gdArticleView is not available when a page starts loading. The IDs and the
+  /// audio links of articles loaded before gdArticleView becomes available (if any) are passed to this function.
+  /// @param activeArticleIndex the index of the currently active article ID in @p loadedArticles
+  ///        or -1 if no article is active yet.
+  /// @param hasPageInitFinished true if the page initialization has already finished,
+  ///        in which case onJsPageInitFinished() won't be invoked by this page.
+  void onJsPageInitStarted( QStringList const & loadedArticles, QStringList const & loadedAudioLinks,
+                            int activeArticleIndex, bool hasPageInitFinished, QDateTime const & pageTimestamp_ );
+
+  void onJsPageInitFinished();
+
+  void onJsActiveArticleChanged( QString const & id, QDateTime const & currentArticleTimestamp_ );
+
+  /// Is called on mousedown JavaScript event if it is triggered by the left mouse button and
+  /// the event starts a first click (not a second or a third click in a double- or triple-click)
+  /// and "Select word by single click" option is on (otherwise there is nothing to do).
+  void onJsFirstLeftButtonMouseDown();
+
+  void onJsDoubleClicked( QString const & imageUrl );
+#endif
+
+  void onJsArticleLoaded( QString const & id, QString const & audioLink, bool isActive );
+
+  void onJsLocationHashChanged();
+
+  /// </JavaScript interface>
+
+  /// Handles the article-loaded JavaScript message assuming it is fresh.
+  /// The callers of this function must check timestamps in the Qt WebEngine version.
+  /// This function's single purpose is code reuse. It is not exposed to JavaScript.
+  void onJsArticleLoadedNoTimestamps( QString const & id, QString const & audioLink, bool isActive );
+
+  enum TargetFrame { MainFrame, CurrentFrame };
+  void runJavaScript( TargetFrame targetFrame, QString const & scriptSource );
+
+  /// Clears selection on the current web page. This function can be called to
+  /// reset the start position of the page's findText().
+  void clearPageSelection();
+
+  void downloadImage( QUrl const & imageUrl );
+  void translatePossiblyInNewTab( Config::InputPhrase const & phrase );
 
   /// Deduces group from the url. If there doesn't seem to be any group,
   /// returns 0.
   unsigned getGroup( QUrl const & );
 
-
-  /// Returns current article in the view, in the form of "gdfrom-xxx" id.
-  QString getCurrentArticle();
-
   /// Sets the current article by executing a javascript code.
   /// If moveToIt is true, it moves the focus to it as well.
   /// Returns true in case of success, false otherwise.
   bool setCurrentArticle( QString const &, bool moveToIt = false );
 
-  /// Checks if the given article in form of "gdfrom-xxx" is inside a "website"
-  /// frame.
-  bool isFramedArticle( QString const & );
+  void setValidCurrentArticleNoJs( QString const & id );
 
   /// Checks if the given link is to be opened externally, as opposed to opening
   /// it in-place.
   bool isExternalLink( QUrl const & url );
 
+#ifdef USE_QTWEBKIT
+  // The frame-related functions rely on Qt WebKit API unavailable in Qt WebEngine.
+  // The code is useful only for website dictionaries.
+
+  /// Checks if the given article in form of "gdfrom-xxx" is inside a "website" frame.
+  bool isFramedArticle( QString const & );
+
   /// Sees if the last clicked link is from a website frame. If so, changes url
   /// to point to url text translation instead, and saves the original
   /// url to the appropriate "contexts" entry.
@@ -343,6 +484,18 @@ private:
   /// Use the known information about the current frame to update the current
   /// article's value.
   void updateCurrentArticleFromCurrentFrame( QWebFrame * frame = 0 );
+#endif
+
+#ifdef USE_QTWEBKIT
+  void initCurrentArticleAndScroll();
+#else
+  static void updateSourceCodeOfInjectedScript( QWebEngineScriptCollection & scripts,
+                                                QString const & name, QString const & sourceCode );
+
+  /// Injects into JavaScript the current article ID and whether to scroll to it when reloading page.
+  /// Should be called before an action that can be interpreted as page reloading by JavaScript code.
+  void updateInjectedPageReloadingScript( bool scrollToCurrentArticle );
+#endif
 
   /// Saves current article and scroll position for the current history item.
   /// Should be used when leaving the page.
@@ -351,24 +504,37 @@ private:
   /// Loads a page at @p url into view.
   void load( QUrl const & url );
 
+  void openLinkWithFragment( QUrl const & url, QString const & scrollTo );
+
+  void showDefinition( Config::InputPhrase const & phrase, QUrl const & url );
+
   /// Attempts removing last temporary file created.
   void cleanupTemp();
 
   bool eventFilter( QObject * obj, QEvent * ev );
 
   void performFindOperation( bool restart, bool backwards, bool checkHighlight = false );
+#ifndef USE_QTWEBKIT
+  // The API necessary to implement Search-in-page status is not available in Qt WebKit.
+  void findTextFinished( QWebEngineFindTextResult const & result );
+#endif
 
+  void updateSearchNoResultsProperty( bool noResults );
   void reloadStyleSheet();
 
   /// Returns the comma-separated list of dictionary ids which should be muted
   /// for the given group. If there are none, returns empty string.
   QString getMutedForGroup( unsigned group );
 
+  void saveResource( QUrl const & url, QUrl const & ref, ResourceToSaveHandler * handler );
+
 protected:
 
   // We need this to hide the search bar when we're showed
   void showEvent( QShowEvent * );
 
+// TODO (Qt WebEngine): port if this code is useful in the Qt WebEngine version.
+#ifdef USE_QTWEBKIT
 #ifdef Q_OS_WIN32
 
   /// Search inside web page for word under cursor
@@ -380,9 +546,11 @@ private:
 public:
   QString wordAtPoint( int x, int y );
 #endif
-
+#endif // USE_QTWEBKIT
 };
 
+/// Downloads the specified resource and saves it to a file at the specified path.
+/// Emits done() and destroys itself using deleteLater() when finished.
 class ResourceToSaveHandler: public QObject
 {
   Q_OBJECT
@@ -394,6 +562,9 @@ public:
   { return downloadRequests.empty(); }
 
 signals:
+  /// Is emitted when the resource is downloaded. Allows to modify the resource data before it is saved to a file.
+  /// Connect via Qt::DirectConnection, because with Qt::QueuedConnection @p resourceData would be a dangling pointer.
+  void downloaded( QString const & fileName, QByteArray * resourceData );
   void done();
   void statusBarMessage( QString const & message, int timeout = 0, QPixmap const & pixmap = QPixmap() );
 
diff --git a/articleview.ui b/articleview.ui
index 25f55e89..17f3af95 100644
--- a/articleview.ui
+++ b/articleview.ui
@@ -48,13 +48,7 @@
        <number>0</number>
       </property>
       <item>
-       <widget class="ArticleWebView" name="definition" native="true">
-        <property name="url" stdset="0">
-         <url>
-          <string>about:blank</string>
-         </url>
-        </property>
-       </widget>
+       <widget class="ArticleWebView" name="definition" native="true"/>
       </item>
      </layout>
     </widget>
@@ -224,6 +218,9 @@
           </property>
          </widget>
         </item>
+        <item>
+         <widget class="QLabel" name="searchStatusLabel"/>
+        </item>
         <item>
          <spacer name="horizontalSpacer">
           <property name="orientation">
diff --git a/articlewebpage.cc b/articlewebpage.cc
new file mode 100644
index 00000000..9c3fd041
--- /dev/null
+++ b/articlewebpage.cc
@@ -0,0 +1,180 @@
+/* This file is (c) 2022 Igor Kushnir <igorkuo@gmail.com>
+ * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */
+
+#include "articlewebpage.hh"
+#ifndef USE_QTWEBKIT
+#include "articleview.hh"
+#include "config.hh"
+#include "folding.hh"
+#endif
+#include "gddebug.hh"
+
+namespace {
+
+#ifndef USE_QTWEBKIT
+char const * messageLevelToString( QWebEnginePage::JavaScriptConsoleMessageLevel level )
+{
+  switch( level )
+  {
+    case QWebEnginePage::InfoMessageLevel:
+      return "info";
+    case QWebEnginePage::WarningMessageLevel:
+      return "warning";
+    case QWebEnginePage::ErrorMessageLevel:
+      return "error";
+  }
+  return "unknown";
+}
+#endif
+
+} // unnamed namespace
+
+#ifdef USE_QTWEBKIT
+ArticleWebPage::ArticleWebPage( QObject * parent ):
+  WebPage( parent )
+{
+}
+
+void ArticleWebPage::javaScriptConsoleMessage( QString const & message, int lineNumber, QString const & sourceID )
+{
+  gdWarning( "JS: %s (at %s:%d)", message.toUtf8().constData(), sourceID.toUtf8().constData(), lineNumber );
+}
+#else
+ArticleWebPage::ArticleWebPage( ArticleView const & articleView_, Config::Class & cfg_,
+                                QWebEngineProfile * profile, QObject * parent ):
+  QWebEnginePage( profile, parent ), articleView( articleView_ ), cfg( cfg_ )
+{
+}
+
+void ArticleWebPage::javaScriptConsoleMessage( JavaScriptConsoleMessageLevel level, QString const & message,
+                                               int lineNumber, QString const & sourceID )
+{
+  gdWarning( "JS %s: %s (at %s:%d)", messageLevelToString( level ),
+             qUtf8Printable( message ), qUtf8Printable( sourceID ), lineNumber );
+}
+
+bool ArticleWebPage::acceptNavigationRequest( QUrl const & url, NavigationType type, bool isMainFrame )
+{
+  Q_UNUSED( isMainFrame )
+  if( type != NavigationTypeLinkClicked )
+    return true;
+
+  // TODO (Qt WebEngine): when a link that does not load a new page is clicked before the current page is fully loaded,
+  // the view stops updating because of QTBUG-106580. And then only the beginning of the last displayed article may be
+  // visible, a few bottommost articles may be altogether missing from the page. A possible workaround is to replace the
+  // anchor element (<a>) of each such link with a button (possibly image button) and pass the link's URL to ArticleView
+  // via Qt WebChannel: onclick="gdArticleView.onJsLinkClicked('<url>');". Such a replacement is very time-consuming for
+  // a workaround: each audio, video, other resource or external link in every dictionary format has to be replaced.
+  // One more downside of this workaround is that the buttons won't work in saved articles (this in turn can be worked
+  // around by falling back to assigning the URL to window.location.href if gdArticleView is falsy in a new
+  // gdLinkClicked(url) helper function). Clicking a link <a href="javascript: gdLinkClicked('<url>'); void(0);"> also
+  // does not stop web view updates. This alternative javascript link replacement workaround is just as time-consuming
+  // to implement as the button workaround, but does not change the appearance of the links, provided
+  // ArticleView::linkHovered() is adjusted accordingly.
+  emit linkClicked( url );
+  return false;
+}
+
+namespace {
+
+/// Creates a dev tools view and starts inspecting @p inspectedPage in it.
+/// @p geometry a dev tools view geometry to restore.
+/// @return the created dev tools view.
+QWidget * createDevToolsView( QWebEnginePage & inspectedPage, QByteArray const & geometry )
+{
+  // Making inspectedPage->view() the parent of devToolsView embeds devToolsView into
+  // inspectedPage->view() => delete devToolsView in inspectedPage's destructor instead.
+  auto * const devToolsView = new QWebEngineView();
+
+  // Destroy devToolsView when closed, because otherwise the cursor over the inspected page remains
+  // a circle, hovering over links does not show a tooltip, selecting text is impossible. Furthermore,
+  // if closing devToolsView does not destroy it, there is no way for the user to free up the resources
+  // it uses, other than destroy the inspected page (e.g. close the tab that contains it).
+  devToolsView->setAttribute( Qt::WA_DeleteOnClose, true );
+
+  devToolsView->restoreGeometry( geometry );
+
+  // Use the inspected page's QWebEngineProfile. This might improve performance. On the other hand,
+  // if the article profile is customized further in the future, this sharing could cause issues. In that
+  // case, an off-the-record profile should be used instead (probably shared between all dev tools pages).
+  auto * const devToolsPage = new QWebEnginePage( inspectedPage.profile(), devToolsView );
+  devToolsView->setPage( devToolsPage );
+
+  inspectedPage.setDevToolsPage( devToolsPage );
+
+  return devToolsView;
+}
+
+/// Unminimizes, raises and gives focus to @p devToolsView.
+void resumeWebPageInspection( QWidget & devToolsView )
+{
+  Q_ASSERT( devToolsView.isVisible() ); // a dev tools view is destroyed when closed
+  devToolsView.activateWindow();
+  devToolsView.raise();
+}
+
+void setDevToolsViewTitle( QWidget & devToolsView, QString inspectedPageTitle )
+{
+  Folding::prepareToEmbedRTL( inspectedPageTitle );
+  // Don't mention "GoldenDict" in the window title and rely on the GoldenDict icon for recognition.
+  devToolsView.setWindowTitle( ArticleWebPage::tr( "Developer Tools: %1" ).arg( inspectedPageTitle ) );
+}
+
+void bindDevToolsViewTitle( QWidget & devToolsView, ArticleView const & articleView )
+{
+  // Connect to &ArticleView::titleChanged instead of &QWebEnginePage::titleChanged, because the former
+  // filters out transitory title changes and thus prevents flashing of devToolsView's title.
+  QObject::connect( &articleView, &ArticleView::titleChanged,
+                    &devToolsView, [ &devToolsView ]( ArticleView *, QString const & title ) {
+    setDevToolsViewTitle( devToolsView, title );
+  } );
+  setDevToolsViewTitle( devToolsView, articleView.getTitle() );
+}
+
+} // unnamed namespace
+
+ArticleWebPage::~ArticleWebPage()
+{
+  // Calling deleteLater() in place of delete here prints the following error message on GoldenDict exit:
+  // Release of profile requested but WebEnginePage still not deleted. Expect troubles !
+  delete devToolsView();
+}
+
+void ArticleWebPage::saveConfigData() const
+{
+  if( auto const * view = devToolsView() )
+    cfg.inspectorGeometry = view->saveGeometry();
+}
+
+void ArticleWebPage::triggerAction( WebAction action, bool checked )
+{
+  if( action == InspectElement )
+  {
+    if( auto * view = devToolsView() )
+      resumeWebPageInspection( *view );
+    else
+    {
+      QWidget * const devToolsView = createDevToolsView( *this, cfg.inspectorGeometry );
+
+      // Connecting &ArticleWebPage::saveConfigData to &QWidget::destroyed leads to a crash in saveConfigData(), because
+      // the dev tools page and the the dev tools view are no longer bound and page->view() returns nullptr then.
+      connect( devToolsView, &QWidget::destroyed, this, [ devToolsView, this ] {
+        cfg.inspectorGeometry = devToolsView->saveGeometry();
+      } );
+
+      bindDevToolsViewTitle( *devToolsView, articleView );
+
+      devToolsView->show();
+    }
+  }
+
+  QWebEnginePage::triggerAction( action, checked );
+}
+
+QWidget * ArticleWebPage::devToolsView() const
+{
+  if( auto const * page = devToolsPage() )
+    return page->view();
+  return nullptr;
+}
+#endif
diff --git a/articlewebpage.hh b/articlewebpage.hh
new file mode 100644
index 00000000..b77341c2
--- /dev/null
+++ b/articlewebpage.hh
@@ -0,0 +1,53 @@
+/* This file is (c) 2022 Igor Kushnir <igorkuo@gmail.com>
+ * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */
+
+#ifndef ARTICLEWEBPAGE_HH_INCLUDED
+#define ARTICLEWEBPAGE_HH_INCLUDED
+
+#include "webkit_or_webengine.hh"
+
+#ifndef USE_QTWEBKIT
+class ArticleView;
+namespace Config {
+class Class;
+}
+#endif
+
+/// Note: this class always delegates all links in the Qt WebEngine version.
+class ArticleWebPage: public WebPage
+{
+  Q_OBJECT
+public:
+#ifdef USE_QTWEBKIT
+  explicit ArticleWebPage( QObject * parent = 0 );
+#else
+  explicit ArticleWebPage( ArticleView const &, Config::Class &,
+                           QWebEngineProfile * profile, QObject * parent = nullptr );
+  ~ArticleWebPage();
+
+  void saveConfigData() const;
+
+  void triggerAction( WebAction action, bool checked = false ) override;
+
+signals:
+  /// This signal is emitted whenever the user clicks on a link.
+  void linkClicked( QUrl const & url );
+#endif
+
+protected:
+#ifdef USE_QTWEBKIT
+  virtual void javaScriptConsoleMessage( QString const & message, int lineNumber, QString const & sourceID );
+#else
+  void javaScriptConsoleMessage( JavaScriptConsoleMessageLevel level, QString const & message,
+                                 int lineNumber, QString const & sourceID ) override;
+  bool acceptNavigationRequest( QUrl const & url, NavigationType type, bool isMainFrame ) override;
+
+private:
+  QWidget * devToolsView() const;
+
+  ArticleView const & articleView;
+  Config::Class & cfg;
+#endif
+};
+
+#endif // ARTICLEWEBPAGE_HH_INCLUDED
diff --git a/articlewebview.cc b/articlewebview.cc
index d3498110..f66c03ab 100644
--- a/articlewebview.cc
+++ b/articlewebview.cc
@@ -2,21 +2,23 @@
  * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */
 
 #include "articlewebview.hh"
-#include <QMouseEvent>
-#include <QWebFrame>
-#include <QApplication>
+
+#ifdef USE_QTWEBKIT
+
 #include "articleinspector.hh"
 #include "qt4x5.hh"
 
+#include <QMouseEvent>
+#include <QApplication>
+#include <QWebFrame>
+
 #ifdef Q_OS_WIN32
 #include <qt_windows.h>
 #endif
 
 ArticleWebView::ArticleWebView( QWidget *parent ):
   QWebView( parent ),
-#if QT_VERSION >= 0x040600
   inspector( NULL ),
-#endif
   midButtonPressed( false ),
   selectionBySingleClick( false ),
   showInspectorDirectly( true )
@@ -25,10 +27,8 @@ ArticleWebView::ArticleWebView( QWidget *parent ):
 
 ArticleWebView::~ArticleWebView()
 {
-#if QT_VERSION >= 0x040600
   if ( inspector )
     inspector->deleteLater();
-#endif
 }
 
 void ArticleWebView::setUp( Config::Class * cfg )
@@ -36,9 +36,14 @@ void ArticleWebView::setUp( Config::Class * cfg )
   this->cfg = cfg;
 }
 
+void ArticleWebView::saveConfigData() const
+{
+  if( inspector )
+    cfg->inspectorGeometry = inspector->saveGeometry();
+}
+
 void ArticleWebView::triggerPageAction( QWebPage::WebAction action, bool checked )
 {
-#if QT_VERSION >= 0x040600
   if ( action == QWebPage::InspectElement )
   {
     // Get or create inspector instance for current view.
@@ -59,7 +64,6 @@ void ArticleWebView::triggerPageAction( QWebPage::WebAction action, bool checked
       return;
     }
   }
-#endif
 
   QWebView::triggerPageAction( action, checked );
 }
@@ -91,7 +95,7 @@ void ArticleWebView::mousePressEvent( QMouseEvent * event )
 
   QWebView::mousePressEvent( event );
 
-  if ( selectionBySingleClick && ( event->buttons() & Qt::LeftButton ) )
+  if( selectionBySingleClick && ( event->buttons() & Qt::LeftButton ) && !isOnScrollBar( *event ) )
   {
     findText(""); // clear the selection first, if any
     QMouseEvent ev( QEvent::MouseButtonDblClick, event->pos(), Qt::LeftButton, Qt::LeftButton, event->modifiers() );
@@ -101,34 +105,24 @@ void ArticleWebView::mousePressEvent( QMouseEvent * event )
 
 void ArticleWebView::mouseReleaseEvent( QMouseEvent * event )
 {
-  bool noMidButton = !( event->buttons() & Qt4x5::middleButton() );
-
   QWebView::mouseReleaseEvent( event );
 
-  if ( midButtonPressed & noMidButton )
+  // QWebPage::linkClicked() signal is emitted during the above call to QWebView::mouseReleaseEvent(),
+  // so midButtonPressed has been used already and can be unset now.
+  if( midButtonPressed && !( event->buttons() & Qt4x5::middleButton() ) )
     midButtonPressed = false;
 }
 
 void ArticleWebView::mouseDoubleClickEvent( QMouseEvent * event )
 {
   QWebView::mouseDoubleClickEvent( event );
-#if QT_VERSION >= 0x040600
-  int scrollBarWidth = page()->mainFrame()->scrollBarGeometry( Qt::Vertical ).width();
-  int scrollBarHeight = page()->mainFrame()->scrollBarGeometry( Qt::Horizontal ).height();
-#else
-  int scrollBarWidth = 0;
-  int scrollBarHeight = 0;
-#endif
 
   // emit the signal only if we are not double-clicking on scrollbars
-  if ( ( event->x() < width() - scrollBarWidth ) &&
-       ( event->y() < height() - scrollBarHeight ) )
-  {
+  if( !isOnScrollBar( *event ) )
     emit doubleClicked( event->pos() );
-  }
-
 }
 
+// TODO (Qt WebEngine): port if this code is useful in the Qt WebEngine version.
 void ArticleWebView::focusInEvent( QFocusEvent * event )
 {
   QWebView::focusInEvent( event );
@@ -150,6 +144,7 @@ void ArticleWebView::wheelEvent( QWheelEvent *ev )
 {
 #ifdef Q_OS_WIN32
 
+  // TODO (Qt WebEngine): port if this code is useful in the Qt WebEngine version.
   // Avoid wrong mouse wheel handling in QWebView
   // if system preferences is set to "scroll by page"
 
@@ -179,3 +174,105 @@ void ArticleWebView::wheelEvent( QWheelEvent *ev )
   }
 
 }
+
+bool ArticleWebView::isOnScrollBar( QMouseEvent const & event ) const
+{
+  int const scrollBarWidth = page()->mainFrame()->scrollBarGeometry( Qt::Vertical ).width();
+  int const scrollBarHeight = page()->mainFrame()->scrollBarGeometry( Qt::Horizontal ).height();
+
+  return event.x() >= width() - scrollBarWidth || event.y() >= height() - scrollBarHeight;
+}
+
+#else // USE_QTWEBKIT
+
+#include "gddebug.hh"
+
+#include <QChildEvent>
+#include <QQuickWidget>
+
+namespace {
+QWidget * toChildWidget( QObject * object )
+{
+  // We are interested only in the QQuickWidget child of QWebEngineView.
+  return qobject_cast< QQuickWidget * >( object );
+}
+}
+
+void ArticleWebView::setEventFilter( QObject * filterObject )
+{
+  eventFilterObject = filterObject;
+}
+
+bool ArticleWebView::isWatched( QObject * object ) const
+{
+  return object->parent() == this && object->isWidgetType() && toChildWidget( object );
+}
+
+QCursor ArticleWebView::cursor() const
+{
+  return childWidget ? childWidget->cursor() : QCursor{};
+}
+
+void ArticleWebView::setCursor( QCursor const & cursor )
+{
+  if( childWidget )
+    childWidget->setCursor( cursor );
+}
+
+void ArticleWebView::unsetCursor()
+{
+  if( childWidget )
+    childWidget->unsetCursor();
+}
+
+void ArticleWebView::childEvent( QChildEvent * event )
+{
+  auto * const child = event->child();
+  if( child->isWidgetType() )
+  {
+    // Empirical observation: in Qt 5.15 QWebEngineView has a single QQuickWidget child, which is added
+    // soon after construction and is never removed. Remove the event filter from a removed child
+    // anyway in case this occurs under some circumstances or in a future Qt version.
+    switch( event->type() )
+    {
+      // Handle ChildPolished event, which occurs soon after ChildAdded event we are really interested in. Cannot handle
+      // the ChildAdded event directly, because child is not fully constructed and is only a QWidget then. ChildPolished
+      // event occurs before a lambda invocation queued in ChildAdded event, and thus is preferable to that alternative.
+      case QEvent::ChildPolished:
+      {
+        if( child == childWidget )
+          return; // repeated polishing => nothing to do
+        auto * const childAsWidget = toChildWidget( child );
+        if( !childAsWidget )
+          return; // this must be a non-quick widget child we are not interested in
+
+        // Theoretically eventFilterObject can be installed multiple times on the same quick widget child
+        // in case of multiple ChildPolished events and a childWidget replacement. This is not a problem,
+        // because QObject::installEventFilter() removes the event filter if present before installing it
+        // (guards against a single event filter object installed twice).
+        child->installEventFilter( eventFilterObject );
+
+        if( childWidget )
+          gdWarning( "A second quick widget child is added to an article web view. Replacing the first one." );
+        childWidget = childAsWidget;
+        break;
+      }
+      case QEvent::ChildRemoved:
+        // If child is being destroyed and is no longer a QQuickWidget, removing the event filter is unnecessary,
+        // because when an object is destroyed, all event filters installed on it are automatically removed.
+        if( toChildWidget( child ) )
+          child->removeEventFilter( eventFilterObject );
+
+        if( childWidget == child )
+          childWidget = nullptr;
+        break;
+
+      default:
+        break;
+    }
+  }
+
+  return QWebEngineView::childEvent( event );
+}
+
+#endif // USE_QTWEBKIT
diff --git a/articlewebview.hh b/articlewebview.hh
index 1c3c832b..52ea4a36 100644
--- a/articlewebview.hh
+++ b/articlewebview.hh
@@ -4,8 +4,10 @@
 #ifndef __ARTICLEWEBVIEW_HH_INCLUDED__
 #define __ARTICLEWEBVIEW_HH_INCLUDED__
 
-#include <QWebView>
+#ifdef USE_QTWEBKIT
+
 #include "config.hh"
+#include <QWebView>
 
 class ArticleInspector;
 
@@ -28,6 +30,8 @@ public:
 
   void setUp( Config::Class * cfg );
 
+  void saveConfigData() const;
+
   bool isMidButtonPressed() const
   { return midButtonPressed; }
   void setSelectionBySingleClick( bool set )
@@ -54,6 +58,8 @@ protected:
 
 private:
 
+  bool isOnScrollBar( QMouseEvent const & event ) const;
+
   Config::Class * cfg;
   ArticleInspector * inspector;
 
@@ -62,4 +68,40 @@ private:
   bool showInspectorDirectly;
 };
 
-#endif
+#else // USE_QTWEBKIT
+
+#include <QWebEngineView>
+
+/// A thin wrapper around QWebEngineView that works around QTBUG-43602 by installing
+/// an event filter on the QQuickWidget child of QWebEngineView, which swallows mouse events.
+/// In the Qt WebEngine version, ArticleView implements most features ArticleWebView provides in the Qt WebKit version.
+class ArticleWebView: public QWebEngineView
+{
+  Q_OBJECT
+public:
+  using QWebEngineView::QWebEngineView;
+
+  /// This function supersedes installEventFilter(), which doesn't work as expected because of QTBUG-43602.
+  /// Call this function once and immediately after constructing this view. Otherwise, it will have no effect.
+  /// Removing or replacing the event filter is currently unneeded and thus unsupported.
+  void setEventFilter( QObject * filterObject );
+
+  /// @return whether the argument to a timely setEventFilter() call was installed as event filter on @p object.
+  bool isWatched( QObject * object ) const;
+
+  // Use the following member functions, not QWidget's equivalents they hide.
+  QCursor cursor() const;
+  void setCursor( QCursor const & );
+  void unsetCursor();
+
+protected:
+  void childEvent( QChildEvent * event ) override;
+
+private:
+  QObject * eventFilterObject = nullptr;
+  QWidget * childWidget = nullptr;
+};
+
+#endif // USE_QTWEBKIT
+
+#endif // __ARTICLEWEBVIEW_HH_INCLUDED__
diff --git a/audiolink.cc b/audiolink.cc
index 480d41be..87711c69 100644
--- a/audiolink.cc
+++ b/audiolink.cc
@@ -3,16 +3,14 @@
 
 #include "audiolink.hh"
 
-std::string addAudioLink( std::string const & url,
-                          std::string const & dictionaryId )
+std::string addAudioLink( std::string const & url)
 {
-    return std::string( "<script type=\"text/javascript\">" +
-                        makeAudioLinkScript( url, dictionaryId ) +
+    return std::string( "<script>" +
+                        makeAudioLinkScript( url ) +
                         "</script>" );
 }
 
-std::string makeAudioLinkScript( std::string const & url,
-                                 std::string const & dictionaryId )
+std::string makeAudioLinkScript( std::string const & url)
 {
   /// Convert "'" to "\'" - this char broke autoplay of audiolinks
 
@@ -33,7 +31,8 @@ std::string makeAudioLinkScript( std::string const & url,
     escaped = ( ch == '\\' );
   }
 
-  std::string audioLinkForDict = "gdAudioLinks['" + dictionaryId + "']";
-  return "gdAudioLinks.first = gdAudioLinks.first || " + ref + ";" +
-         audioLinkForDict + " = " + audioLinkForDict + " || " + ref + ";";
+  // Assign the first audio link of each article to gdJustLoadedAudioLink JavaScript variable.
+  // Once an article finishes loading, the value of gdJustLoadedAudioLink is stored away
+  // and the variable is set to null, before the next article starts loading.
+  return "gdJustLoadedAudioLink = gdJustLoadedAudioLink || " + ref + ';';
 }
diff --git a/audiolink.hh b/audiolink.hh
index 51f673b4..a884e8d7 100644
--- a/audiolink.hh
+++ b/audiolink.hh
@@ -11,11 +11,8 @@
 /// javascript variable. Embed this into article's html to enable the
 /// 'say sound' functionality.
 /// The url should be escaped and surrounded by quotes.
-/// The dictionary id is used to make active dictionary feature work.
-std::string addAudioLink( std::string const & url,
-                          std::string const & dictionaryId );
+std::string addAudioLink( std::string const & url );
 
-std::string makeAudioLinkScript( std::string const & url,
-                                 std::string const & dictionaryId );
+std::string makeAudioLinkScript( std::string const & url );
 
 #endif
diff --git a/config.cc b/config.cc
index 148cb62e..e79ac834 100644
--- a/config.cc
+++ b/config.cc
@@ -91,6 +91,18 @@ namespace
     return result;
   }
 
+#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
+  QString getDataDirPath()
+  {
+    return isPortableVersion() ? portableHomeDirPath()
+#ifdef XDG_BASE_DIRECTORY_COMPLIANCE
+                               : getDataDir().path();
+#else
+                               : QStandardPaths::writableLocation( QStandardPaths::DataLocation );
+#endif
+  }
+#endif // QT_VERSION
+
 }
 
 ProxyServer::ProxyServer(): enabled( false ), useSystemProxy( false ), type( Socks5 ), port( 3128 )
@@ -257,6 +269,7 @@ Preferences::Preferences():
   hideGoldenDictHeader( false ),
   maxNetworkCacheSize( 50 ),
   clearNetworkCacheOnExit( true ),
+  offTheRecordWebProfile( true ),
   zoomFactor( 1 ),
   helpZoomFactor( 1 ),
   wordsZoomLevel( 0 ),
@@ -961,6 +974,9 @@ Class load() THROW_SPEC( exError )
     if ( !preferences.namedItem( "clearNetworkCacheOnExit" ).isNull() )
       c.preferences.clearNetworkCacheOnExit = ( preferences.namedItem( "clearNetworkCacheOnExit" ).toElement().text() == "1" );
 
+    if ( !preferences.namedItem( "offTheRecordWebProfile" ).isNull() )
+      c.preferences.offTheRecordWebProfile = ( preferences.namedItem( "offTheRecordWebProfile" ).toElement().text() == "1" );
+
     if ( !preferences.namedItem( "maxStringsInHistory" ).isNull() )
       c.preferences.maxStringsInHistory = preferences.namedItem( "maxStringsInHistory" ).toElement().text().toUInt() ;
 
@@ -1940,6 +1956,10 @@ void save( Class const & c ) THROW_SPEC( exError )
     opt.appendChild( dd.createTextNode( c.preferences.clearNetworkCacheOnExit ? "1" : "0" ) );
     preferences.appendChild( opt );
 
+    opt = dd.createElement( "offTheRecordWebProfile" );
+    opt.appendChild( dd.createTextNode( c.preferences.offTheRecordWebProfile ? "1" : "0" ) );
+    preferences.appendChild( opt );
+
     opt = dd.createElement( "maxStringsInHistory" );
     opt.appendChild( dd.createTextNode( QString::number( c.preferences.maxStringsInHistory ) ) );
     preferences.appendChild( opt );
@@ -2411,4 +2431,34 @@ QString getNetworkCacheDir() throw()
   return getCacheDir() + "/network";
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
+
+static bool replaceLocationIn( QString & path, QString const & location, QString const & replacement )
+{
+  if( !path.startsWith( location ) )
+  {
+    gdWarning( "The path %s does not start with the expected location %s",
+               path.toUtf8().constData(), replacement.toUtf8().constData() );
+    return false;
+  }
+
+  if( replacement == location )
+    return false; // nothing to do
+
+  path.replace( 0, location.size(), replacement );
+  return true;
+}
+
+bool replaceWritableCacheLocationIn( QString & path )
+{
+  return replaceLocationIn( path, QStandardPaths::writableLocation( QStandardPaths::CacheLocation ), getCacheDir() );
+}
+
+bool replaceWritableDataLocationIn( QString & path )
+{
+  return replaceLocationIn( path, QStandardPaths::writableLocation( QStandardPaths::DataLocation ), getDataDirPath() );
+}
+
+#endif // QT_VERSION
+
 }
diff --git a/config.hh b/config.hh
index b38a91b4..db3a5a95 100644
--- a/config.hh
+++ b/config.hh
@@ -337,6 +337,7 @@ struct Preferences
   bool hideGoldenDictHeader;
   int maxNetworkCacheSize;
   bool clearNetworkCacheOnExit;
+  bool offTheRecordWebProfile;
 
   qreal zoomFactor;
   qreal helpZoomFactor;
@@ -676,7 +677,7 @@ struct Class
   QByteArray popupWindowState; // Binary state saved by QMainWindow
   QByteArray popupWindowGeometry; // Geometry saved by QMainWindow
   QByteArray dictInfoGeometry; // Geometry of "Dictionary info" window
-  QByteArray inspectorGeometry; // Geometry of WebKit inspector window
+  QByteArray inspectorGeometry; // Geometry of WebKit inspector window or WebEngine dev tools view
   QByteArray dictionariesDialogGeometry; // Geometry of Dictionaries dialog
   QByteArray printPreviewDialogGeometry; // Geometry of Print Preview dialog
   QByteArray helpWindowGeometry; // Geometry of help window
@@ -836,6 +837,17 @@ QString getCacheDir() throw();
 /// Returns the article network disk cache directory.
 QString getNetworkCacheDir() throw();
 
+#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
+/// Replaces QStandardPaths::writableLocation( QStandardPaths::CacheLocation )
+/// at the beginning of @p path with the path to GoldenDict's cache directory.
+/// @return true if @p path was changed, false otherwise.
+bool replaceWritableCacheLocationIn( QString & path );
+/// Replaces QStandardPaths::writableLocation( QStandardPaths::DataLocation )
+/// at the beginning of @p path with the path to GoldenDict's data directory.
+/// @return true if @p path was changed, false otherwise.
+bool replaceWritableDataLocationIn( QString & path );
+#endif
+
 }
 
 Q_DECLARE_METATYPE( Config::InputPhrase )
diff --git a/dsl.cc b/dsl.cc
index 223d3f37..c2c517ad 100644
--- a/dsl.cc
+++ b/dsl.cc
@@ -906,10 +906,10 @@ string DslDictionary::nodeToHtml( ArticleDom::Node const & node )
 
       string ref = string( "\"" ) + url.toEncoded().data() + "\"";
 
-      result += addAudioLink( ref, getId() );
+      result += addAudioLink( ref );
 
       result += "<span class=\"dsl_s_wav\"><a href=" + ref
-         + "><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" align=\"absmiddle\" alt=\"Play\"/></a></span>";
+         + "><img src=\"qrc:///icons/playsound.png\" border=\"0\" align=\"absmiddle\" alt=\"Play\"/></a></span>";
     }
     else
     if ( Filetype::isNameOfPicture( filename ) )
@@ -1820,7 +1820,7 @@ void DslArticleRequest::run()
         string prefix = "O" + dict.getId().substr( 0, 7 ) + "_" + QString::number( dict.articleNom ).toStdString();
         string id1 = prefix + "_expand";
         string id2 = prefix + "_opt_";
-        string button = " <img src=\"qrcx://localhost/icons/expand_opt.png\" class=\"hidden_expand_opt\" id=\"" + id1 +
+        string button = " <img src=\"qrc:///icons/expand_opt.png\" class=\"hidden_expand_opt\" id=\"" + id1 +
                         "\" onclick=\"gdExpandOptPart('" + id1 + "','" + id2 +"')\" alt=\"[+]\"/>";
         if( articleText.compare( articleText.size() - 4, 4, "</p>" ) == 0 )
           articleText.insert( articleText.size() - 4, " " + button );
diff --git a/epwing_book.cc b/epwing_book.cc
index 778866b4..e20b802c 100644
--- a/epwing_book.cc
+++ b/epwing_book.cc
@@ -1454,7 +1454,7 @@ QByteArray EpwingBook::handleWave( EB_Hook_Code code, const unsigned int * argv
 {
 
   if( code == EB_HOOK_END_WAVE )
-    return QByteArray( "<img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" align=\"absmiddle\" alt=\"Play\"/></a></span>" );
+    return QByteArray( "<img src=\"qrc:///icons/playsound.png\" border=\"0\" align=\"absmiddle\" alt=\"Play\"/></a></span>" );
 
   // Handle EB_HOOK_BEGIN_WAVE
 
@@ -1481,7 +1481,7 @@ QByteArray EpwingBook::handleWave( EB_Hook_Code code, const unsigned int * argv
   url.setPath( Qt4x5::Url::ensureLeadingSlash( name ) );
 
   string ref = string( "\"" )+ url.toEncoded().data() + "\"";
-  QByteArray result = addAudioLink( ref , dictID.toUtf8().data() ).c_str();
+  QByteArray result = addAudioLink( ref ).c_str();
 
   result += QByteArray( "<span class=\"epwing_wav\"><a href=" ) + ref.c_str() + ">";
 
diff --git a/extlineedit.cc b/extlineedit.cc
index a3752596..71a00592 100644
--- a/extlineedit.cc
+++ b/extlineedit.cc
@@ -9,8 +9,13 @@
 #include <QPropertyAnimation>
 #endif
 
+QPixmap ExtLineEdit::scaledForButtonPixmap( QPixmap const & pixmap )
+{
+  return pixmap.scaled( 18, 18, Qt::KeepAspectRatio, Qt::SmoothTransformation );
+}
+
 ExtLineEdit::ExtLineEdit(QWidget *parent) :
-    QLineEdit(parent)
+    QLineEdit(parent), altLeftPixmapVisible( false )
 {
 
   for (int i = 0; i < 2; ++i) {
@@ -60,6 +65,34 @@ void ExtLineEdit::setButtonAutoHide(Side side, bool autohide)
     }
 }
 
+void ExtLineEdit::setAlternativeLeftPixmap( QPixmap const & pixmap )
+{
+  Q_ASSERT( pixmap.size() == iconButtons[ Left ]->pixmap().size() );
+
+  if( altLeftPixmapVisible )
+  {
+    // altLeftPixmap is currently swapped with the left button pixmap => set as the left button pixmap.
+    // No need to update margins or button positions because the pixmap size is unchanged.
+    iconButtons[ Left ]->setPixmap( pixmap );
+  }
+  else
+    altLeftPixmap = pixmap;
+}
+
+void ExtLineEdit::setAlternativeLeftPixmapVisible( bool visible )
+{
+  Q_ASSERT( !altLeftPixmap.isNull() );
+
+  if( altLeftPixmapVisible == visible )
+    return; // no change
+  altLeftPixmapVisible = visible;
+
+  // Swap altLeftPixmap and the left button pixmap.
+  QPixmap tmp = iconButtons[ Left ]->pixmap();
+  iconButtons[ Left ]->setPixmap( altLeftPixmap );
+  altLeftPixmap.swap( tmp );
+}
+
 void ExtLineEdit::updateButtons(QString text)
 {
   if ( oldText.isEmpty() || text.isEmpty() ) {
@@ -129,17 +162,21 @@ void ExtLineEdit::resizeEvent(QResizeEvent *)
 
 void ExtLineEdit::setButtonPixmap(Side side, const QPixmap &buttonPixmap)
 {
+  Q_ASSERT( side == Right || altLeftPixmap.isNull() || buttonPixmap.size() == altLeftPixmap.size() );
+
+  if( altLeftPixmapVisible && side == Left )
+  {
+    // altLeftPixmap is currently swapped with the left button pixmap => assign to altLeftPixmap.
+    altLeftPixmap = buttonPixmap;
+    return;
+  }
+
     iconButtons[side]->setPixmap(buttonPixmap);
     updateMargins();
     updateButtonPositions();
     update();
 }
 
-QPixmap ExtLineEdit::buttonPixmap(Side side) const
-{
-    return pixmaps[side];
-}
-
 void ExtLineEdit::setButtonToolTip(Side side, const QString &tip)
 {
     iconButtons[side]->setToolTip(tip);
diff --git a/extlineedit.hh b/extlineedit.hh
index 15adfdff..10532605 100644
--- a/extlineedit.hh
+++ b/extlineedit.hh
@@ -39,12 +39,13 @@ class ExtLineEdit : public QLineEdit
     Q_ENUMS(Side)
 
 public:
+    static QPixmap scaledForButtonPixmap( QPixmap const & pixmap );
+
     enum Side { Left = 0, Right = 1 };
 
     explicit ExtLineEdit(QWidget * parent = 0);
     ~ExtLineEdit();
 
-    QPixmap buttonPixmap(Side side) const;
     void setButtonPixmap(Side side, const QPixmap &pixmap);
 
     void setButtonVisible(Side side, bool visible);
@@ -55,6 +56,15 @@ public:
 
     void setButtonAutoHide(Side side, bool autohide);
 
+    /// @param pixmap a pixmap that may be intermittently displayed in place of the left button pixmap.
+    /// @pre pixmap.size() equals the size of the left button pixmap.
+    /// @warning Do not change the size of the left button pixmap after setting an alternative left pixmap.
+    void setAlternativeLeftPixmap( QPixmap const & pixmap );
+    /// Shows the alternative left pixmap in place of the left button pixmap if @p visible;
+    /// shows the left button pixmap in its own place (the default until this function is called) otherwise.
+    /// @pre The alternative left pixmap has been set and is not null.
+    void setAlternativeLeftPixmapVisible( bool visible );
+
 signals:
     void leftButtonClicked();
     void rightButtonClicked();
@@ -69,9 +79,10 @@ protected:
 private:
     void updateMargins();
     void updateButtonPositions();
-    QPixmap pixmaps[2];
     IconButton * iconButtons[2];
     bool iconEnabled[2];
+    bool altLeftPixmapVisible;
+    QPixmap altLeftPixmap;
     QString oldText;
 };
 
diff --git a/folding.cc b/folding.cc
index 6f8f8c28..1c14f888 100644
--- a/folding.cc
+++ b/folding.cc
@@ -688,6 +688,15 @@ QString unescapeWildcardSymbols( const QString & str )
   return unescaped;
 }
 
+void prepareToEmbedRTL( QString & str )
+{
+  if( str.isRightToLeft() )
+  {
+    str.insert( 0, (ushort)0x202E ); // RLE, Right-to-Left Embedding
+    str.append( (ushort)0x202C ); // PDF, POP DIRECTIONAL FORMATTING
+  }
+}
+
 wchar foldedDiacritic( wchar const * in, size_t size, size_t & consumed )
 {
   return foldDiacritic( in, size, consumed );
diff --git a/folding.hh b/folding.hh
index c9282128..fed5f655 100644
--- a/folding.hh
+++ b/folding.hh
@@ -85,6 +85,9 @@ QString unescapeWildcardSymbols( QString const & );
 /// Escape all wildcard symbols (for place word to input line)
 QString escapeWildcardSymbols( QString const & );
 
+/// Prepare a possibly right-to-left string @p str to be embedded into another, possibly left-to-right string.
+void prepareToEmbedRTL( QString & str );
+
 /// Return result of foldDiacritic() from "inc_diacritic_folding.hh"
 wchar foldedDiacritic( wchar const * in, size_t size, size_t & consumed );
 
diff --git a/forvo.cc b/forvo.cc
index 3fb7ffa2..8a6a1665 100644
--- a/forvo.cc
+++ b/forvo.cc
@@ -86,8 +86,7 @@ sptr< DataRequest > ForvoDictionary::getArticle( wstring const & word,
     return new DataRequestInstant( false );
   }
   else
-    return new ForvoArticleRequest( word, alts, apiKey, languageCode, getId(),
-                                    netMgr );
+    return new ForvoArticleRequest( word, alts, apiKey, languageCode, netMgr );
 }
 
 void ForvoDictionary::loadIcon() throw()
@@ -135,10 +134,8 @@ ForvoArticleRequest::ForvoArticleRequest( wstring const & str,
                                           vector< wstring > const & alts,
                                           QString const & apiKey_,
                                           QString const & languageCode_,
-                                          string const & dictionaryId_,
                                           QNetworkAccessManager & mgr ):
-  apiKey( apiKey_ ), languageCode( languageCode_ ),
-  dictionaryId( dictionaryId_ )
+  apiKey( apiKey_ ), languageCode( languageCode_ )
 {
   connect( &mgr, SIGNAL( finished( QNetworkReply * ) ),
            this, SLOT( requestFinished( QNetworkReply * ) ),
@@ -263,7 +260,7 @@ void ForvoArticleRequest::requestFinished( QNetworkReply * r )
 
                 string ref = string( "\"" ) + url.toEncoded().data() + "\"";
 
-                articleBody += addAudioLink( ref, dictionaryId ).c_str();
+                articleBody += addAudioLink( ref ).c_str();
 
                 bool isMale = ( item.namedItem( "sex" ).toElement().text().toLower() != "f" );
 
@@ -304,7 +301,7 @@ void ForvoArticleRequest::requestFinished( QNetworkReply * r )
                 string addTime =
                     tr( "Added %1" ).arg( item.namedItem( "addtime" ).toElement().text() ).toUtf8().data();
 
-                articleBody += "<td><a href=" + ref + " title=\"" + Html::escape( addTime ) + "\"><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
+                articleBody += "<td><a href=" + ref + " title=\"" + Html::escape( addTime ) + "\"><img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
                 articleBody += string( "<td>" ) + tr( "by" ).toUtf8().data() + " <a class='forvo_user' href='"
                                + userProfile + "'>"
                                + Html::escape( user.toUtf8().data() )
@@ -313,7 +310,7 @@ void ForvoArticleRequest::requestFinished( QNetworkReply * r )
                                + " "
                                + tr( "from" ).toUtf8().data()
                                + " "
-                               + "<img src='qrcx://localhost/flags/" + Country::englishNametoIso2( country ).toUtf8().data()
+                               + "<img src='qrc:///flags/" + Country::englishNametoIso2( country ).toUtf8().data()
                                + ".png'/> "
                                + Html::escape( country.toUtf8().data() )
                                + ")</span>"
diff --git a/forvo.hh b/forvo.hh
index c9588ed6..5163a02e 100644
--- a/forvo.hh
+++ b/forvo.hh
@@ -42,14 +42,12 @@ class ForvoArticleRequest: public Dictionary::DataRequest
   typedef std::list< NetReply > NetReplies;
   NetReplies netReplies;
   QString apiKey, languageCode;
-  string dictionaryId;
 
 public:
 
   ForvoArticleRequest( wstring const & word, vector< wstring > const & alts,
                        QString const & apiKey_,
                        QString const & languageCode_,
-                       string const & dictionaryId_,
                        QNetworkAccessManager & mgr );
 
   virtual void cancel();
diff --git a/gls.cc b/gls.cc
index 02b7096d..febe318f 100644
--- a/gls.cc
+++ b/gls.cc
@@ -824,14 +824,14 @@ void GlsDictionary::loadArticle( uint32_t address,
 QString & GlsDictionary::filterResource( QString & article )
 {
 #if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
-  QRegularExpression imgRe( "(<\\s*img\\s+[^>]*src\\s*=\\s*[\"']+)(?!(?:data|https?|ftp|qrcx):)",
+  QRegularExpression imgRe( "(<\\s*img\\s+[^>]*src\\s*=\\s*[\"']+)(?!(?:data|https?|ftp|qrcx?):)",
                             QRegularExpression::CaseInsensitiveOption
                             | QRegularExpression::InvertedGreedinessOption );
   QRegularExpression linkRe( "(<\\s*link\\s+[^>]*href\\s*=\\s*[\"']+)(?!(?:data|https?|ftp):)",
                              QRegularExpression::CaseInsensitiveOption
                              | QRegularExpression::InvertedGreedinessOption );
 #else
-  QRegExp imgRe( "(<\\s*img\\s+[^>]*src\\s*=\\s*[\"']+)(?!(?:data|https?|ftp|qrcx):)", Qt::CaseInsensitive );
+  QRegExp imgRe( "(<\\s*img\\s+[^>]*src\\s*=\\s*[\"']+)(?!(?:data|https?|ftp|qrcx?):)", Qt::CaseInsensitive );
   imgRe.setMinimal( true );
   QRegExp linkRe( "(<\\s*link\\s+[^>]*href\\s*=\\s*[\"']+)(?!(?:data|https?|ftp):)", Qt::CaseInsensitive );
   linkRe.setMinimal( true );
@@ -963,18 +963,18 @@ QString & GlsDictionary::filterResource( QString & article )
     else
     {
       std::string href = "\"gdau://" + getId() + "/" + src.toUtf8().data() + "\"";
-      QString newTag = QString::fromUtf8( ( addAudioLink( href, getId() ) + "<span class=\"gls_wav\"><a href=" + href + ">" ).c_str() );
+      QString newTag = QString::fromUtf8( ( addAudioLink( href ) + "<span class=\"gls_wav\"><a href=" + href + ">" ).c_str() );
 #if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
       newTag += match.captured( 4 );
       if( match.captured( 4 ).indexOf( "<img " ) < 0 )
-        newTag += " <img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\">";
+        newTag += " <img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\">";
       newTag += "</a></span>";
 
       articleNewText += newTag;
 #else
       newTag += audioRe.cap( 4 );
       if( audioRe.cap( 4 ).indexOf( "<img " ) < 0 )
-        newTag += " <img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\">";
+        newTag += " <img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\">";
       newTag += "</a></span>";
 
       article.replace( pos, audioRe.cap( 0 ).length(), newTag );
diff --git a/goldendict.pro b/goldendict.pro
index ea2a5e1c..5b9a5420 100644
--- a/goldendict.pro
+++ b/goldendict.pro
@@ -36,8 +36,26 @@ QT += core \
       svg
 
 greaterThan(QT_MAJOR_VERSION, 4) {
+    # TODO: make Qt WebEngine the default for supported Qt versions once the Qt WebEngine
+    # GoldenDict version works well enough. `CONFIG += use_qtwebkit` will override the default then.
+    CONFIG( use_qtwebengine ) {
+      # Qt 5.15.2 introduces API that facilitates porting to Qt 6, so requiring it can be useful.
+      REQUIRED_QT_VERSION = 5.15.2
+      !versionAtLeast( QT_VERSION, $${REQUIRED_QT_VERSION} ) {
+        error( "Cannot use Qt version $${QT_VERSION}." \
+               "The Qt WebEngine version of GoldenDict requires Qt $${REQUIRED_QT_VERSION} or newer." )
+      }
+
+      QT += quickwidgets \
+            webchannel \
+            webenginewidgets
+      CONFIG += c++14
+    } else {
+      QT += webkitwidgets
+      DEFINES += USE_QTWEBKIT
+    }
+
     QT += widgets \
-          webkitwidgets \
           printsupport \
           help
 
@@ -48,6 +66,7 @@ greaterThan(QT_MAJOR_VERSION, 4) {
     }
 } else {
     QT += webkit
+    DEFINES += USE_QTWEBKIT
     CONFIG += help
 }
 
@@ -276,6 +295,7 @@ HEADERS += folding.hh \
     bgl.hh \
     initializing.hh \
     article_netmgr.hh \
+    article_urlschemehandler.hh \
     dictzip.h \
     btreeidx.hh \
     stardict.hh \
@@ -332,6 +352,8 @@ HEADERS += folding.hh \
     broken_xrecord.hh \
     history.hh \
     atomic_rename.hh \
+    webkit_or_webengine.hh \
+    articlewebpage.hh \
     articlewebview.hh \
     zipfile.hh \
     indexedzip.hh \
@@ -356,6 +378,7 @@ HEADERS += folding.hh \
     dictinfo.hh \
     zipsounds.hh \
     stylescombobox.hh \
+    square_label.hh \
     extlineedit.hh \
     translatebox.hh \
     historypanewidget.hh \
@@ -413,6 +436,7 @@ SOURCES += folding.cc \
     bgl.cc \
     initializing.cc \
     article_netmgr.cc \
+    article_urlschemehandler.cc \
     dictzip.c \
     btreeidx.cc \
     stardict.cc \
@@ -466,6 +490,7 @@ SOURCES += folding.cc \
     broken_xrecord.cc \
     history.cc \
     atomic_rename.cc \
+    articlewebpage.cc \
     articlewebview.cc \
     zipfile.cc \
     indexedzip.cc \
@@ -603,6 +628,7 @@ CONFIG( old_hunspell ) {
 }
 
 RESOURCES += resources.qrc \
+    scripts/scripts.qrc \
     flags.qrc
 TRANSLATIONS += locale/ru_RU.ts \
     locale/zh_CN.ts \
diff --git a/groups_widgets.cc b/groups_widgets.cc
index 1aa5bba7..52617b61 100644
--- a/groups_widgets.cc
+++ b/groups_widgets.cc
@@ -1027,8 +1027,7 @@ QuickFilterLine::QuickFilterLine( QWidget * parent ): ExtLineEdit( parent ), m_f
   connect( &m_focusAction, SIGNAL( triggered() ),
            this, SLOT( focusFilterLine() ) );
 
-  QPixmap image(":/icons/system-search.png");
-  setButtonPixmap(ExtLineEdit::Left, image.scaled(18, 18, Qt::KeepAspectRatio, Qt::SmoothTransformation));
+  setButtonPixmap( ExtLineEdit::Left, scaledForButtonPixmap( QPixmap( ":/icons/system-search.png" ) ) );
   setButtonToolTip(ExtLineEdit::Left, tr("Quick Search"));
   setButtonVisible(ExtLineEdit::Left, true);
 
diff --git a/icons/loading.gif b/icons/loading.gif
new file mode 100644
index 00000000..b0a6556f
Binary files /dev/null and b/icons/loading.gif differ
diff --git a/lsa.cc b/lsa.cc
index b0812741..cc11d1a0 100644
--- a/lsa.cc
+++ b/lsa.cc
@@ -284,9 +284,9 @@ sptr< Dictionary::DataRequest > LsaDictionary::getArticle( wstring const & word,
 
     string ref = string( "\"" ) + url.toEncoded().data() + "\"";
 
-    result += addAudioLink( ref, getId() );
+    result += addAudioLink( ref );
 
-    result += "<td><a href=" + ref + "><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
+    result += "<td><a href=" + ref + "><img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
     result += "<td><a href=" + ref + ">" + i->second + "</a></td>";
     result += "</tr>";
   }
@@ -302,9 +302,9 @@ sptr< Dictionary::DataRequest > LsaDictionary::getArticle( wstring const & word,
 
     string ref = string( "\"" ) + url.toEncoded().data() + "\"";
 
-    result += addAudioLink( ref, getId() );
+    result += addAudioLink( ref );
 
-    result += "<td><a href=" + ref + "><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
+    result += "<td><a href=" + ref + "><img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
     result += "<td><a href=" + ref + ">" + i->second + "</a></td>";
     result += "</tr>";
   }
diff --git a/main.cc b/main.cc
index 68daeed3..ec4b2cfd 100644
--- a/main.cc
+++ b/main.cc
@@ -4,6 +4,7 @@
 #include <stdio.h>
 #include <QIcon>
 #include "gdappstyle.hh"
+#include "article_urlschemehandler.hh"
 #include "mainwindow.hh"
 #include "config.hh"
 
@@ -28,7 +29,6 @@
 #include "termination.hh"
 #include "atomic_rename.hh"
 
-#include <QWebSecurityOrigin>
 #include <QMessageBox>
 #include <QDebug>
 #include <QFile>
@@ -39,6 +39,10 @@
 
 #include "gddebug.hh"
 
+#ifdef USE_QTWEBKIT
+#include <QWebSecurityOrigin>
+#endif
+
 #if defined( Q_OS_MAC ) && QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
 #include "lionsupport.h"
 #endif
@@ -355,6 +359,10 @@ int main( int argc, char ** argv )
 
 #endif
 
+#ifndef USE_QTWEBKIT
+  registerArticleUrlSchemes();
+#endif
+
   QHotkeyApplication app( "GoldenDict", argc, argv );
   LogFilePtrGuard logFilePtrGuard;
 
@@ -543,10 +551,11 @@ int main( int argc, char ** argv )
   // and with the main window closed.
   app.setQuitOnLastWindowClosed( false );
 
-#if QT_VERSION >= 0x040600
-  // Add the dictionary scheme we use as local, so that the file:// links would
-  // work in the articles. The function was introduced in Qt 4.6.
+#ifdef USE_QTWEBKIT
+  // registerArticleUrlSchemes() is responsible for similar configuration in the Qt WebEngine version.
+  // Add the dictionary schemes we use as local to make file:// and qrc:// links work in articles.
   QWebSecurityOrigin::addLocalScheme( "gdlookup" );
+  QWebSecurityOrigin::addLocalScheme( "gdpicture" );
 #endif
 
   MainWindow m( cfg );
diff --git a/mainwindow.cc b/mainwindow.cc
index 3009d297..d107e924 100644
--- a/mainwindow.cc
+++ b/mainwindow.cc
@@ -10,6 +10,7 @@
 #include "loaddictionaries.hh"
 #include "preferences.hh"
 #include "about.hh"
+#include "article_urlschemehandler.hh"
 #include "mruqmenu.hh"
 #include "gestures.hh"
 #include "dictheadwords.hh"
@@ -21,23 +22,22 @@
 #include <QMessageBox>
 #include <QIcon>
 #include <QList>
+#include <QSet>
 #include <QToolBar>
 #include <QCloseEvent>
 #include <QDesktopServices>
 #include <QProcess>
-#include <QCryptographicHash>
 #include <QFileDialog>
 #include <QPrinter>
 #include <QPageSetupDialog>
 #include <QPrintPreviewDialog>
 #include <QPrintDialog>
+#include <QProgressDialog>
 #include <QRunnable>
 #include <QThreadPool>
 #include <QSslConfiguration>
 
 #include <limits.h>
-#include <set>
-#include <map>
 #include "gddebug.hh"
 
 #include "dictinfo.hh"
@@ -47,6 +47,13 @@
 #include <QDesktopWidget>
 #include "ui_authentication.h"
 
+#ifndef USE_QTWEBKIT
+#include <QPointer>
+#include <QVersionNumber>
+#include <QWebEngineProfile>
+#include <QWebEngineSettings>
+#endif
+
 #ifdef Q_OS_MAC
 #include "lionsupport.h"
 #include "macmouseover.hh"
@@ -71,10 +78,7 @@
 
 #define MIN_THREAD_COUNT 4
 
-using std::set;
 using std::wstring;
-using std::map;
-using std::pair;
 
 namespace {
 
@@ -94,6 +98,99 @@ public:
 };
 #endif
 
+#ifndef USE_QTWEBKIT
+/// Both compile-time and run-time Qt WebEngine versions may and often do differ from the corresponding
+/// Qt versions. That's because building Qt WebEngine with earlier Qt versions is officially supported.
+/// Patch releases of Qt WebEngine are available as free software and are packaged by GNU/Linux
+/// distributions a year before the patch releases of the corresponding LTS (e.g. 5.15.x) Qt versions.
+QVersionNumber runTimeQtWebEngineVersion( QWebEngineProfile const & webEngineProfile )
+{
+#if QT_VERSION >= QT_VERSION_CHECK( 6, 2, 0 )
+  Q_UNUSED( webEngineProfile )
+  return QVersionNumber::fromString( QLatin1String{ qWebEngineVersion() } );
+#else
+  QString const httpUserAgent = webEngineProfile.httpUserAgent();
+  // httpUserAgent should contain a substring like "QtWebEngine/5.15.10 ". The "5.15.10" part
+  // equals the run-time version of Qt WebEngine. The code below extracts this version.
+
+  QLatin1String const prefix( "QtWebEngine/" );
+  auto webEngineVersionIndex = httpUserAgent.indexOf( prefix );
+  if( webEngineVersionIndex == -1 )
+  {
+    gdWarning( "Failed to parse the Qt WebEngine profile's HTTP User-Agent string: %s",
+               qUtf8Printable( httpUserAgent ) );
+    return QVersionNumber();
+  }
+  webEngineVersionIndex += prefix.size();
+
+  return QVersionNumber::fromString( QStringView{ httpUserAgent }.mid( webEngineVersionIndex ) );
+#endif
+}
+
+StreamingDeviceWorkarounds computeStreamingDeviceWorkarounds( QWebEngineProfile const & webEngineProfile )
+{
+  auto const webEngineVersion = runTimeQtWebEngineVersion( webEngineProfile );
+  if( webEngineVersion.isNull() )
+    return StreamingDeviceWorkarounds::None; // This must be a future version => probably no need for the workarounds.
+
+#if QT_VERSION >= QT_VERSION_CHECK( 6, 0, 0 )
+  if( webEngineVersion >= QVersionNumber( 6, 4, 1 ) )
+    return StreamingDeviceWorkarounds::None;
+  if( webEngineVersion >= QVersionNumber( 6, 4, 0 ) )
+    return StreamingDeviceWorkarounds::AtEndOnly;
+#else
+  if( webEngineVersion >= QVersionNumber( 5, 15, 11 ) )
+    return StreamingDeviceWorkarounds::AtEndOnly;
+#endif
+  return StreamingDeviceWorkarounds::AtEndAndReadData;
+}
+
+void setWebEngineProfilePaths( QWebEngineProfile & webEngineProfile )
+{
+  Q_ASSERT( !webEngineProfile.isOffTheRecord() );
+
+  QString cachePath = webEngineProfile.cachePath();
+  if( Config::replaceWritableCacheLocationIn( cachePath ) )
+    webEngineProfile.setCachePath( cachePath );
+
+  QString persistentStoragePath = webEngineProfile.persistentStoragePath();
+  if( Config::replaceWritableDataLocationIn( persistentStoragePath ) )
+    webEngineProfile.setPersistentStoragePath( persistentStoragePath );
+}
+
+void setupWebEngineProfile( QWebEngineProfile & webEngineProfile, ArticleNetworkAccessManager & articleNetMgr )
+{
+  // TODO (Qt WebEngine): should the maximum size of the HTTP cache and whether
+  // it is cleared on exit be configurable similarly to the network cache?
+
+  // TODO (Qt WebEngine): in the Qt WebEngine version articleNetMgr's cache is useful only for downloaded files,
+  // because the page itself is stored separately in the Qt WebEngine profile's cache. In the interest of
+  // reusing the Qt WebEngine profile's cache for both loading pages and downloading files,
+  // Dictionary::WebMultimediaDownload could call QWebEnginePage::download() instead of
+  // QNetworkAccessManager::get() to retrieve files from network. articleNetMgr's cache would become
+  // practically useless then and could be restricted to the Qt WebKit version along with its configuration UI.
+  // QWebEnginePage::download() always stores the downloaded data in a file. A QNetworkReply returned by
+  // QNetworkAccessManager::get() stores the downloaded data in a buffer. This cache reuse requires substantial
+  // refactoring to avoid the overhead of unnecessary reading from and writing to a file, because the users of
+  // WebMultimediaDownload access the data via the DataRequest interface and store it into a file, except for
+  // pronouncing of an external audio link, which passes DataRequest::data to AudioPlayerInterface::play().
+  // This refactoring should eliminate existing code duplication between ArticleView::resourceDownloadFinished()
+  // and ResourceToSaveHandler::downloadFinished() as well as fix minor issues in these functions along the way.
+
+  // TODO (Qt WebEngine): should the configuration UI allow disabling persistent cookies?
+  // Cookies are never stored on disk in the Qt WebKit version according to the documentation for QNetworkCookieJar:
+  // > QNetworkCookieJar does not implement permanent storage: it only keeps the cookies in memory. Once the
+  // > QNetworkCookieJar object is deleted, all cookies it held will be discarded as well. If you want to save the
+  // > cookies, you should derive from this class and implement the saving to disk to your own storage format.
+  // Should the persistent cookies be disabled by default in the Qt WebEngine version too?
+
+  articleNetMgr.setStreamingDeviceWorkarounds( computeStreamingDeviceWorkarounds( webEngineProfile ) );
+
+  auto * const handler = new ArticleUrlSchemeHandler( articleNetMgr );
+  handler->install( webEngineProfile );
+}
+#endif // USE_QTWEBKIT
+
 } // unnamed namespace
 
 #ifndef QT_NO_OPENSSL
@@ -133,8 +230,7 @@ MainWindow::MainWindow( Config::Class & cfg_ ):
   cfg( cfg_ ),
   history( History::Load(), cfg_.preferences.maxStringsInHistory, cfg_.maxHeadwordSize ),
   dictionaryBar( this, configEvents, cfg.editDictionaryCommandLine, cfg.preferences.maxDictionaryRefsInContextMenu ),
-  articleMaker( dictionaries, groupInstances, cfg.preferences.displayStyle,
-                cfg.preferences.addonStyle ),
+  articleMaker( dictionaries, groupInstances, cfg.preferences.displayStyle, cfg.preferences.addonStyle, this ),
   articleNetMgr( this, dictionaries, articleMaker,
                  cfg.preferences.disallowContentFromOtherSites, cfg.preferences.hideGoldenDictHeader ),
   dictNetMgr( this ),
@@ -315,6 +411,9 @@ MainWindow::MainWindow( Config::Class & cfg_ ):
   connect( ui.searchPane->toggleViewAction(), SIGNAL( triggered( bool ) ),
            this, SLOT( updateSearchPaneAndBar( bool ) ) );
 
+  // Bind the loading indicator's height to the translate line's height to prevent UI shifts on loading state changes.
+  ui.loadingIndicatorLabel->setSameHeightWidget( ui.translateLine );
+
   if ( cfg.preferences.searchInDock )
   {
     groupList = groupListInDock;
@@ -782,7 +881,6 @@ MainWindow::MainWindow( Config::Class & cfg_ ):
   ui.searchPane->setVisible( cfg.preferences.searchInDock );
 
   applyProxySettings();
-  applyWebSettings();
 
   connect( &dictNetMgr, SIGNAL( proxyAuthenticationRequired( QNetworkProxy, QAuthenticator * ) ),
            this, SLOT( proxyAuthentication( QNetworkProxy, QAuthenticator * ) ) );
@@ -792,6 +890,20 @@ MainWindow::MainWindow( Config::Class & cfg_ ):
 
   setupNetworkCache( cfg.preferences.maxNetworkCacheSize );
 
+#ifndef USE_QTWEBKIT
+  if( cfg.preferences.offTheRecordWebProfile )
+    webEngineProfile.reset( new QWebEngineProfile{} );
+  else
+  {
+    webEngineProfile.reset( new QWebEngineProfile{ QStringLiteral( "Article" ) } );
+    setWebEngineProfilePaths( *webEngineProfile );
+  }
+  setupWebEngineProfile( *webEngineProfile, articleNetMgr );
+  ArticleView::initProfilePreferences( *webEngineProfile, cfg.preferences );
+#endif
+
+  applyWebSettings();
+
   makeDictionaries();
 
   // After we have dictionaries and groups, we can populate history
@@ -995,6 +1107,7 @@ void MainWindow::updateSearchPaneAndBar( bool searchInDock )
 
   updateGroupList();
   applyWordsZoomLevel();
+  updateIsPageLoading();
 
   setTranslateBoxTextAndKeepSuffix( text, WildcardsAreAlreadyEscaped, DisablePopup );
   focusTranslateLine();
@@ -1120,6 +1233,9 @@ void MainWindow::commitData()
     if( scanPopup.get() )
       scanPopup->saveConfigData();
 
+    for( int i = 0, count = ui.tabWidget->count(); i < count; ++i )
+      qobject_cast< ArticleView const * >( ui.tabWidget->widget( i ) )->saveConfigData();
+
     // Save any changes in last chosen groups etc
     try
     {
@@ -1337,9 +1453,14 @@ void MainWindow::applyProxySettings()
 
 void MainWindow::applyWebSettings()
 {
+#ifdef USE_QTWEBKIT
   QWebSettings *defaultSettings = QWebSettings::globalSettings();
   defaultSettings->setAttribute(QWebSettings::PluginsEnabled, cfg.preferences.enableWebPlugins);
   defaultSettings->setAttribute( QWebSettings::DeveloperExtrasEnabled, true );
+#else
+  auto * const settings = webEngineProfile->settings();
+  settings->setAttribute( QWebEngineSettings::PluginsEnabled, cfg.preferences.enableWebPlugins );
+#endif
 }
 
 void MainWindow::setupNetworkCache( int maxSize )
@@ -1506,7 +1627,11 @@ void MainWindow::makeScanPopup()
        !cfg.preferences.enableClipboardHotkey )
     return;
 
-  scanPopup = new ScanPopup( 0, cfg, articleNetMgr, audioPlayerFactory.player(),
+  scanPopup = new ScanPopup( 0, cfg, articleNetMgr,
+#ifndef USE_QTWEBKIT
+                             *webEngineProfile,
+#endif
+                             audioPlayerFactory.player(),
                              dictionaries, groupInstances, history );
 
   scanPopup->setStyleSheet( styleSheet() );
@@ -1663,7 +1788,11 @@ void MainWindow::addNewTab()
 ArticleView * MainWindow::createNewTab( bool switchToIt,
                                         QString const & name )
 {
-  ArticleView * view = new ArticleView( this, articleNetMgr, audioPlayerFactory.player(),
+  ArticleView * view = new ArticleView( this, articleNetMgr,
+#ifndef USE_QTWEBKIT
+                                        *webEngineProfile,
+#endif
+                                        audioPlayerFactory.player(),
                                         dictionaries, groupInstances, false, cfg,
                                         *ui.searchInPageAction,
                                         dictionaryBar.toggleViewAction(),
@@ -1675,14 +1804,26 @@ ArticleView * MainWindow::createNewTab( bool switchToIt,
   connect( view, SIGNAL( iconChanged( ArticleView *, QIcon const & ) ),
            this, SLOT( iconChanged( ArticleView *, QIcon const & ) ) );
 
+  connect( view, SIGNAL( pageLoadingStateChanged( ArticleView *, bool ) ),
+           this, SLOT( pageLoadingStateChanged( ArticleView *, bool ) ) );
+
+  connect( view, SIGNAL( canGoBackForwardChanged( ArticleView * ) ),
+           this, SLOT( canGoBackForwardChanged( ArticleView * ) ) );
+
+  connect( view, SIGNAL( pageUnloaded( ArticleView * ) ),
+           this, SLOT( pageUnloaded( ArticleView * ) ) );
+
+  connect( view, SIGNAL( articleLoaded( ArticleView *, QString const &, bool ) ),
+           this, SLOT( articleLoaded( ArticleView *, QString const &, bool ) ) );
+
   connect( view, SIGNAL( pageLoaded( ArticleView * ) ),
            this, SLOT( pageLoaded( ArticleView * ) ) );
 
   connect( view, SIGNAL( openLinkInNewTab( QUrl const &, QUrl const &, QString const &, ArticleView::Contexts const & ) ),
            this, SLOT( openLinkInNewTab( QUrl const &, QUrl const &, QString const &, ArticleView::Contexts const & ) ) );
 
-  connect( view, SIGNAL( showDefinitionInNewTab( QString const &, unsigned, QString const &, ArticleView::Contexts const & ) ),
-           this, SLOT( showDefinitionInNewTab( QString const &, unsigned, QString const &, ArticleView::Contexts const & ) ) );
+  connect( view, SIGNAL( showDefinitionInNewTab( Config::InputPhrase const &, unsigned, QString const &, ArticleView::Contexts const & ) ),
+           this, SLOT( showDefinitionInNewTab( Config::InputPhrase const &, unsigned, QString const &, ArticleView::Contexts const & ) ) );
 
   connect( view, SIGNAL( typingEvent( QString const & ) ),
            this, SLOT( typingEvent( QString const & ) ) );
@@ -1865,12 +2006,7 @@ void MainWindow::titleChanged( ArticleView * view, QString const & title )
 {
   QString escaped = title;
   escaped.replace( "&", "&&" );
-
-  if( escaped.isRightToLeft() )
-  {
-    escaped.insert( 0, (ushort)0x202E ); // RLE, Right-to-Left Embedding
-    escaped.append( (ushort)0x202C ); // PDF, POP DIRECTIONAL FORMATTING
-  }
+  Folding::prepareToEmbedRTL( escaped );
 
   int index = ui.tabWidget->indexOf( view );
   ui.tabWidget->setTabText( index, escaped );
@@ -1913,31 +2049,59 @@ void MainWindow::updateWindowTitle()
     QString str = view->getTitle();
     if( !str.isEmpty() )
     {
-      if( str.isRightToLeft() )
+      if( blockUpdateWindowTitle )
       {
-        str.insert( 0, (ushort)0x202E ); // RLE, Right-to-Left Embedding
-        str.append( (ushort)0x202C ); // PDF, POP DIRECTIONAL FORMATTING
+        blockUpdateWindowTitle = false;
+        return;
       }
-      if( !blockUpdateWindowTitle )
-        setWindowTitle( tr( "%1 - %2" ).arg( str, "GoldenDict" ) );
-      blockUpdateWindowTitle = false;
+
+      Folding::prepareToEmbedRTL( str );
+      setWindowTitle( tr( "%1 - %2" ).arg( str, "GoldenDict" ) );
     }
   }
 }
 
-void MainWindow::pageLoaded( ArticleView * view )
+void MainWindow::pageLoadingStateChanged( ArticleView * view, bool isLoading )
+{
+  if( view == getCurrentArticleView() )
+    setIsPageLoading( isLoading );
+  // else: ignore this change in a non-active tab
+}
+
+void MainWindow::canGoBackForwardChanged( ArticleView * view )
+{
+  if( view == getCurrentArticleView() )
+    updateBackForwardButtons( view );
+  // else: ignore this change in a non-active tab
+}
+
+void MainWindow::pageUnloaded( ArticleView * view )
 {
   if( view != getCurrentArticleView() )
     return; // It was background action
 
-  updateBackForwardButtons();
+  navPronounce->setEnabled( false );
+  if( ui.dictsList->isVisible() )
+    ui.dictsList->clear();
+}
 
-  updatePronounceAvailability();
+void MainWindow::articleLoaded( ArticleView * view, QString const & id, bool isActive )
+{
+  if( view != getCurrentArticleView() )
+    return; // It was background action
+
+  navPronounce->setEnabled( view->hasSound() );
+  if( ui.dictsList->isVisible() )
+    appendToFoundInDictsList( id, isActive );
+}
+
+void MainWindow::pageLoaded( ArticleView * view )
+{
+  if( view != getCurrentArticleView() )
+    return; // It was background action
 
   if ( cfg.preferences.pronounceOnLoadMain )
     pronounce( view );
-
-  updateFoundInDictsList();
 }
 
 void MainWindow::showStatusBarMessage( QString const & message, int timeout, QPixmap const & icon )
@@ -1951,6 +2115,7 @@ void MainWindow::showStatusBarMessage( QString const & message, int timeout, QPi
 void MainWindow::tabSwitched( int )
 {
   translateBox->setPopupEnabled( false );
+  updateIsPageLoading();
   updateBackForwardButtons();
   updatePronounceAvailability();
   updateFoundInDictsList();
@@ -2024,6 +2189,30 @@ void MainWindow::dictsPaneVisibilityChanged( bool visible )
   }
 }
 
+void MainWindow::appendToFoundInDictsList( QString const & id, bool isActive )
+{
+  QByteArray const idUtf8 = id.toUtf8();
+  for( unsigned x = dictionaries.size(); x--; )
+  {
+    sptr< Dictionary::Class > & dictionary = dictionaries[ x ];
+    if( dictionary->getId() != idUtf8.constData() )
+      continue;
+
+    QString const dictName = QString::fromUtf8( dictionary->getName().c_str() );
+    QListWidgetItem * const item =
+        new QListWidgetItem(
+          dictionary->getIcon().pixmap( 32 ).scaledToHeight( 21, Qt::SmoothTransformation ),
+          dictName, ui.dictsList, QListWidgetItem::Type );
+    item->setData( Qt::UserRole, id );
+    item->setToolTip( dictName );
+
+    ui.dictsList->addItem( item );
+    if( isActive )
+      ui.dictsList->setCurrentItem( item );
+    break;
+  }
+}
+
 void MainWindow::updateFoundInDictsList()
 {
   if (!ui.dictsList->isVisible())
@@ -2038,48 +2227,43 @@ void MainWindow::updateFoundInDictsList()
 
   if ( view )
   {
-    QStringList ids = view->getArticlesList();
+    QStringList const ids = view->getArticleList();
     QString activeId = view->getActiveArticleId();
 
     for( QStringList::const_iterator i = ids.constBegin(); i != ids.constEnd(); ++i)
-    {
-      // Find this dictionary
-
-      for( unsigned x = dictionaries.size(); x--; )
-      {
-        if ( dictionaries[ x ]->getId() == i->toUtf8().data() )
-        {
-          QString dictName = QString::fromUtf8( dictionaries[ x ]->getName().c_str() );
-          QString dictId = QString::fromUtf8( dictionaries[ x ]->getId().c_str() );
-          QListWidgetItem * item =
-              new QListWidgetItem(
-                dictionaries[ x ]->getIcon().pixmap(32).scaledToHeight( 21, Qt::SmoothTransformation ),
-                dictName,
-                ui.dictsList, QListWidgetItem::Type );
-          item->setData(Qt::UserRole, QVariant( dictId ) );
-          item->setToolTip(dictName);
-
-          ui.dictsList->addItem( item );
-          if (dictId == activeId)
-          {
-            ui.dictsList->setCurrentItem(item);
-          }
-          break;
-        }
-      }
-    }
+      appendToFoundInDictsList( *i, *i == activeId );
   }
 }
 
+void MainWindow::updateIsPageLoading()
+{
+  if( ArticleView const * view = getCurrentArticleView() )
+    setIsPageLoading( view->isPageLoading() );
+}
+
+void MainWindow::setIsPageLoading( bool isLoading )
+{
+  if( cfg.preferences.searchInDock )
+    ui.loadingIndicatorLabel->setVisible( isLoading );
+  else
+    translateBox->setIsPageLoading( isLoading );
+}
+
 void MainWindow::updateBackForwardButtons()
 {
   ArticleView *view = getCurrentArticleView();
 
   if ( view )
-  {
-    navBack->setEnabled(view->canGoBack());
-    navForward->setEnabled(view->canGoForward());
-  }
+    updateBackForwardButtons( view );
+}
+
+void MainWindow::updateBackForwardButtons( ArticleView * view )
+{
+  Q_ASSERT( view );
+  Q_ASSERT( view == getCurrentArticleView() );
+
+  navBack->setEnabled( view->canGoBack() );
+  navForward->setEnabled( view->canGoForward() );
 }
 
 void MainWindow::updatePronounceAvailability()
@@ -2241,6 +2425,10 @@ void MainWindow::editPreferences()
     if( cfg.preferences.helpLanguage != p.helpLanguage )
       closeGDHelp();
 
+#ifndef USE_QTWEBKIT
+    ArticleView::updateProfilePreferences( *webEngineProfile, cfg.preferences, p );
+#endif
+
     for( int x = 0; x < ui.tabWidget->count(); ++x )
     {
       ArticleView & view =
@@ -2820,13 +3008,13 @@ void MainWindow::openLinkInNewTab( QUrl const & url,
       openLink( url, referrer, fromArticle, contexts );
 }
 
-void MainWindow::showDefinitionInNewTab( QString const & word,
+void MainWindow::showDefinitionInNewTab( Config::InputPhrase const & phrase,
                                          unsigned group,
                                          QString const & fromArticle,
                                          ArticleView::Contexts const & contexts )
 {
-  createNewTab( !cfg.preferences.newTabsOpenInBackground, word )->
-      showDefinition( word, group, fromArticle, contexts );
+  createNewTab( !cfg.preferences.newTabsOpenInBackground, phrase.phrase )->
+      showDefinition( phrase, group, fromArticle, contexts );
 }
 
 void MainWindow::activeArticleChanged( ArticleView const * view, QString const & id )
@@ -3599,50 +3787,313 @@ void MainWindow::printPreviewPaintRequested( QPrinter * printer )
   view->print( printer );
 }
 
-static void filterAndCollectResources( QString & html, QRegExp & rx, const QString & sep,
-                                       const QString & folder, set< QByteArray > & resourceIncluded,
-                                       vector< pair< QUrl, QString > > & downloadResources )
+/// This dialog displays the progress of saving an article. It supports increasing expected
+/// number of operations at any time and ensures that the progress bar never moves back.
+/// The dialog destroys itself when all operations complete or when canceled.
+class ArticleSaveProgressDialog: public QProgressDialog
 {
-  int pos = 0;
-  int queryNom = 1;
+  Q_OBJECT
+public:
+  explicit ArticleSaveProgressDialog( QWidget * parent = 0 ):
+    QProgressDialog( parent ),
+    progressStepCount( 100 ),
+    operationCount( 1 ), // the first operation is processing and saving the main HTML file
+    completedOperationCount( 0 )
+  {
+    setLabelText( tr( "Saving article..." ) );
+
+    setAutoReset( false );
+    setAutoClose( false );
+
+    // Once this modal progress dialog is dismissed, the current tab can be closed and thus the article view destroyed.
+    // Destroy the dialog and its child resource saver when canceled to avoid referencing the view and prevent a crash.
+    // Also the article view is the parent of ResourceToSaveHandler objects. If a ResourceToSaveHandler object is
+    // destroyed along with the view before finishing, it never emits the done() signal. Then completedOperationCount
+    // never reaches operationCount, so the progress dialog and its child resource saver are leaked.
+    connect( this, SIGNAL( canceled() ), this, SLOT( deleteLater() ) );
+
+    setRange( 0, progressStepCount );
+    setValue( 0 );
+  }
 
-  while ( ( pos = rx.indexIn( html, pos ) ) != -1 )
+  void addOperations( int count )
   {
-    QUrl url( rx.cap( 1 ) );
-    QString host = url.host();
-    QString resourcePath = Qt4x5::Url::fullPath( url );
+    Q_ASSERT( count > 0 );
+    // Forget about already completed operations to reset progress velocity and prevent jumping backwards.
+    // This slows progress down, which harms user experience. Can this be improved while keeping the code simple?
+    operationCount = operationCount - completedOperationCount + count;
+    completedOperationCount = 0;
+    progressStepCount = maximum() - value();
+  }
 
-    if ( !host.startsWith( '/' ) )
-      host.insert( 0, '/' );
-    if ( !resourcePath.startsWith( '/' ) )
-      resourcePath.insert( 0, '/' );
+public slots:
+  void operationCompleted()
+  {
+    if( wasCanceled() )
+      return; // Changing the progress value shows the dialog again. Prevent this by returning early here.
 
-    // Replase query part of url (if exist)
-    int n = resourcePath.indexOf( QLatin1Char( '?' ) );
-    if( n >= 0 )
+    Q_ASSERT( completedOperationCount < operationCount );
+    ++completedOperationCount;
+
+    // Round progress down so that 100% is reached only when all operations complete.
+    int const progress = progressStepCount * completedOperationCount / operationCount;
+    setValue( maximum() - progressStepCount + progress );
+
+    if( completedOperationCount == operationCount )
     {
-      QString q_str = QString( "_q%1" ).arg( queryNom );
-      resourcePath.replace( n, resourcePath.length() - n, q_str );
-      queryNom += 1;
+      close();
+      deleteLater();
     }
+  }
+
+private:
+  int progressStepCount; ///< The number of available progress steps.
+  int operationCount; ///< The number of operations represented by @a progressStepCount.
+  int completedOperationCount; ///< The number of completed operations, less or equal to @a operationCount.
+};
+
+namespace {
 
-    QCryptographicHash hash( QCryptographicHash::Md5 );
-    hash.addData( rx.cap().toUtf8() );
+/// Finds custom resource links in an article's HTML, downloads the resources and saves them in the specified resource
+/// destination directory. Finds custom resorce links within downloaded code resources recursively, downloads and saves
+/// them as well. Replaces each custom resource URL with the relative path to the corresponding saved resource file
+/// within the in/out parameter html and within recursively downloaded code resources. Reports progress via the progress
+/// dialog argument. The progress dialog becomes the parent of the ArticleResourceSaver object. Thus both the dialog and
+/// the ArticleResourceSaver object are destroyed once the article's HTML and all referenced resources are saved or
+/// when the dialog is canceled.
+class ArticleResourceSaver: public QObject
+{
+  Q_OBJECT
+public:
+  explicit ArticleResourceSaver( QString & html, QString const & pathFromHtmlToDestinationDir_,
+                                 QString const & resourceDestinationDir_, ArticleView & view_,
+                                 ArticleSaveProgressDialog & progressDialog_ ):
+    QObject( &progressDialog_ ),
+    pathFromHtmlToDestinationDir( pathFromHtmlToDestinationDir_ ),
+    resourceDestinationDir( resourceDestinationDir_ ),
+    view( view_ ),
+    progressDialog( progressDialog_ )
+  {
+    Q_ASSERT( pathFromHtmlToDestinationDir.isEmpty() || pathFromHtmlToDestinationDir.endsWith( QLatin1Char( '/' ) ) );
+    Q_ASSERT( resourceDestinationDir.endsWith( QLatin1Char( '/' ) ) );
 
-    if ( resourceIncluded.insert( hash.result() ).second )
+    processLinkSource( html, pathFromHtmlToDestinationDir );
+  }
+
+private slots:
+  void resourceDownloaded( QString const & fileName, QByteArray * resourceData )
+  {
+    Q_ASSERT( resourceData );
+
+    if( progressDialog.wasCanceled() )
+      return; // don't start new downloads after cancelation
+
+    QString pathFromLinkSourceToDestinationDir;
+    if( !isLinkSource( fileName, pathFromLinkSourceToDestinationDir ) )
+      return; // nothing to do
+
+    QString linkSource = QString::fromUtf8( *resourceData );
+    // If the link source is modified, update the resource data before it is saved to a file.
+    if( processLinkSource( linkSource, pathFromLinkSourceToDestinationDir ) )
+      *resourceData = linkSource.toUtf8();
+  }
+
+private:
+  QString relativePathFromResourceToDestinationDir( QString const & resourceFileName ) const
+  {
+    Q_ASSERT( resourceFileName.startsWith( resourceDestinationDir ) );
+    int const depthInDestinationDir = resourceFileName.mid( resourceDestinationDir.size() ).count( '/' );
+
+    QString pathToDestinationDir;
+    for( int i = 0; i < depthInDestinationDir; ++i )
+      pathToDestinationDir += QLatin1String( "../" );
+    return pathToDestinationDir;
+  }
+
+  bool isLinkSource( QString const & fileName, QString & pathFromLinkSourceToDestinationDir ) const
+  {
+    if( fileName.endsWith( QLatin1String( ".js" ) ) )
+    {
+      // Links in JavaScript code replace HTML attribute values, and so are relative to the HTML file location.
+      pathFromLinkSourceToDestinationDir = pathFromHtmlToDestinationDir;
+      return true;
+    }
+
+    if( fileName.endsWith( QLatin1String( ".css" ) ) )
     {
-      // Gather resource information (url, filename) to be download later
-      downloadResources.push_back( pair<QUrl, QString>( url, folder + host + resourcePath ) );
+      // Links in a style sheet are relative to the CSS file they are in.
+      pathFromLinkSourceToDestinationDir = relativePathFromResourceToDestinationDir( fileName );
+      return true;
     }
 
-    // Modify original url, set to the native one
-    resourcePath = QString::fromLatin1( QUrl::toPercentEncoding( resourcePath, "/" ) );
-    QString newUrl = sep + QDir( folder ).dirName() + host + resourcePath + sep;
-    html.replace( pos, rx.cap().length(), newUrl );
-    pos += newUrl.length();
+    return false;
+  }
+
+  struct Resource
+  {
+    explicit Resource( QUrl const & url_, QString const & destinationFilePath_ ):
+      url( url_ ), destinationFilePath( destinationFilePath_ )
+    {}
+
+    QUrl url;
+    QString destinationFilePath;
+  };
+
+  /// Finds custom resource links within @p linkSource, determines where the resources should be saved and stores each
+  /// unique original resource URL and the corresponding destination path in @p resourcesToDownload. Replaces each
+  /// custom resource URL with the corresponding relative destination path within the in/out parameter @p linkSource.
+  /// @param rx a regular expression that matches a custom resource URL enclosed in quotes.
+  /// @return whether @p linkSource was modified by this function call.
+  bool filterAndCollectResources( QString & linkSource, vector< Resource > & resourcesToDownload,
+                                  QRegExp const & rx, QString const & pathFromLinkSourceToDestinationDir )
+  {
+    bool modified = false;
+    int pos = 0;
+    int queryNom = 1;
+
+    while( ( pos = rx.indexIn( linkSource, pos ) ) != -1 )
+    {
+      QString urlString = rx.cap();
+      Q_ASSERT( urlString.size() > 2 );
+      // Remove the enclosing quotes from the match.
+      urlString.chop( 1 );
+      urlString.remove( 0, 1 );
+
+      QUrl url( urlString );
+      if( url.scheme() == QLatin1String( "gdpicture" ) )
+        url.setScheme( "bres" );
+
+      QString host = url.host();
+      QString resourcePath = Qt4x5::Url::fullPath( url );
+
+#ifdef Q_OS_WIN32
+      // Remove the volume separator ':' to make resourcePath a valid subpath.
+      if( url.scheme() == QLatin1String( "file" ) && resourcePath.size() > 2
+          && resourcePath.at( 0 ) == QLatin1Char( '/' ) && resourcePath.at( 2 ) == QLatin1Char( ':' ) )
+      {
+        resourcePath.remove( 2, 1 );
+      }
+#endif
+
+      // Ensure single slash between path components.
+      Q_ASSERT( !host.startsWith( QLatin1Char( '/' ) ) );
+      Q_ASSERT( !host.endsWith( QLatin1Char( '/' ) ) );
+      if( host.isEmpty() )
+      {
+        if( resourcePath.startsWith( QLatin1Char( '/' ) ) )
+          resourcePath.remove( 0, 1 );
+      }
+      else
+      if( !resourcePath.startsWith( '/' ) )
+        resourcePath.insert( 0, '/' );
+
+      // Replase query part of url (if exist)
+      int n = resourcePath.indexOf( QLatin1Char( '?' ) );
+      if( n >= 0 )
+      {
+        QString q_str = QString( "_q%1" ).arg( queryNom );
+        resourcePath.replace( n, resourcePath.length() - n, q_str );
+        queryNom += 1;
+      }
+
+      QString const pathInDestinationDir = host + resourcePath;
+      // Avoid double lookup in encounteredResources.
+      int const oldResourceCount = encounteredResources.size();
+      encounteredResources.insert( pathInDestinationDir );
+      if( encounteredResources.size() != oldResourceCount )
+      {
+        // This resource was not encountered before => store it in resourcesToDownload.
+        resourcesToDownload.push_back( Resource( url, resourceDestinationDir + pathInDestinationDir ) );
+      }
+
+      // Modify original url, set to the native one
+      resourcePath = QString::fromLatin1( QUrl::toPercentEncoding( resourcePath, "/" ) );
+      QString const newUrl = pathFromLinkSourceToDestinationDir + host + resourcePath;
+      linkSource.replace( pos + 1, urlString.size(), newUrl ); // keep the enclosing quotes
+      modified = true;
+
+      pos += 1 + newUrl.size() + 1; // skip newUrl and the enclosing quotes
+    }
+
+    return modified;
+  }
+
+  /// See the documentation for the other overload called from this one.
+  bool filterAndCollectResources( QString & linkSource, vector< Resource > & resourcesToDownload,
+                                  QString const & pathFromLinkSourceToDestinationDir )
+  {
+    static QRegExp const rx1( "'(?:bres|gdpicture|gico|gdau|gdvideo|qrcx?|file)://[^']+'" );
+    static QRegExp const rx2( rx1.pattern().replace( '\'', '"' ) );
+
+    bool const modified1 = filterAndCollectResources( linkSource, resourcesToDownload, rx1,
+                                                      pathFromLinkSourceToDestinationDir );
+    bool const modified2 = filterAndCollectResources( linkSource, resourcesToDownload, rx2,
+                                                      pathFromLinkSourceToDestinationDir );
+
+    return modified1 || modified2;
+  }
+
+  /// @return whether @p linkSource was modified by this function call.
+  bool processLinkSource( QString & linkSource, QString const & pathFromLinkSourceToDestinationDir )
+  {
+    vector< Resource > resourcesToDownload;
+    bool const modified = filterAndCollectResources( linkSource, resourcesToDownload,
+                                                     pathFromLinkSourceToDestinationDir );
+    int asyncSavedResources = 0;
+
+    // Pull and save resources to files
+    for( vector< Resource >::const_iterator it = resourcesToDownload.begin(); it != resourcesToDownload.end(); ++it )
+    {
+      ResourceToSaveHandler * const handler = new ResourceToSaveHandler( &view, it->destinationFilePath );
+
+      // handler may emit downloaded() synchronously from ArticleView::saveResource() => connect to it now.
+      connect( handler, SIGNAL( downloaded( QString, QByteArray * ) ),
+               this, SLOT( resourceDownloaded( QString, QByteArray * ) ) );
+
+      view.saveResource( it->url, *handler );
+      if( !handler->isEmpty() )
+      {
+        ++asyncSavedResources;
+        connect( handler, SIGNAL( done() ), &progressDialog, SLOT( operationCompleted() ) );
+      }
+      // else: the resource was downloaded and saved synchronously => it should not affect the progress dialog.
+    }
+
+    if( asyncSavedResources != 0)
+      progressDialog.addOperations( asyncSavedResources );
+
+    return modified;
+  }
+
+  QString const pathFromHtmlToDestinationDir;
+  QString const resourceDestinationDir;
+  ArticleView & view;
+  ArticleSaveProgressDialog & progressDialog;
+
+  QSet< QString > encounteredResources; ///< Contains destination subpaths of all encountered custom resource files.
+};
+
+void insertSavedArticleScript( QString & html )
+{
+  QLatin1String const insertBeforeString( "<script" );
+  int const pos = html.indexOf( insertBeforeString );
+  if( pos == -1 )
+  {
+    gdWarning( "Couldn't find \"%s\" in an article's HTML code.", insertBeforeString.latin1() );
+    return;
   }
+
+#ifdef USE_QTWEBKIT
+#define w "webkit"
+#else
+#define w "webengine"
+#endif
+  html.insert( pos, QLatin1String( "<script src='qrc:///scripts/" w "_saved_article.js'></script>" ) );
+#undef w
 }
 
+} // unnamed namespace
+
 void MainWindow::on_saveArticle_triggered()
 {
   ArticleView *view = getCurrentArticleView();
@@ -3680,89 +4131,98 @@ void MainWindow::on_saveArticle_triggered()
   // The " (*.html)" part of filters[i] is absent from selectedFilter in Qt 5.
   bool const complete = filters.at( 0 ).startsWith( selectedFilter );
 
-  if ( !fileName.isEmpty() )
-  {
+  if( fileName.isEmpty() )
+    return;
 
-    QFile file( fileName );
+#ifdef USE_QTWEBKIT
+  QString html = view->toHtml();
+  saveArticleAs( *view, html, fileName, complete, rxName, 0 );
+#else
+  // QWebEnginePage::save() doesn't even save qrc resources, not to mention custom URL scheme resources.
+  // Our custom page-saving implementation saves a complete web page correctly.
+
+  auto * const progressDialog = new ArticleSaveProgressDialog( this );
+  progressDialog->show();
 
-    if ( !file.open( QIODevice::WriteOnly ) )
+  view->toHtml( [ this, view, fileName, complete, rxName,
+                  progressDialog = QPointer< ArticleSaveProgressDialog >{ progressDialog } ]( QString const & result ) {
+    if( result.isEmpty() || !progressDialog || progressDialog->wasCanceled() )
     {
-      QMessageBox::critical( this, tr( "Error" ),
-                             tr( "Can't save article: %1" ).arg( file.errorString() ) );
+      // This callback is being called during page destruction or the user canceled the saving of the page.
+      return; // return now to prevent a crash
     }
-    else
+    QString html = result;
+    saveArticleAs( *view, html, fileName, complete, rxName, progressDialog );
+  } );
+#endif
+}
+
+void MainWindow::saveArticleAs( ArticleView & view, QString & html, QString const & fileName, bool complete,
+                                QRegExp const & rxName, ArticleSaveProgressDialog * progressDialog )
+{
+  QFile file( fileName );
+  if ( !file.open( QIODevice::WriteOnly ) )
+  {
+    QMessageBox::critical( this, tr( "Error" ),
+                           tr( "Can't save article: %1" ).arg( file.errorString() ) );
+    return;
+  }
+
+  QFileInfo fi( fileName );
+  cfg.articleSavePath = QDir::toNativeSeparators( fi.absoluteDir().absolutePath() );
+
+  // Convert internal links
+
+  QRegExp rx3( "href=\"(bword:|gdlookup://localhost/)([^\"]+)\"" );
+  int pos = 0;
+  while ( ( pos = rx3.indexIn( html, pos ) ) != -1 )
+  {
+    QString name = QUrl::fromPercentEncoding( rx3.cap( 2 ).simplified().toLatin1() );
+    QString anchor;
+    name.replace( "?gdanchor=", "#" );
+    int n = name.indexOf( '#' );
+    if( n > 0 )
     {
-      QString html = view->toHtml();
-      QFileInfo fi( fileName );
-      cfg.articleSavePath = QDir::toNativeSeparators( fi.absoluteDir().absolutePath() );
+      anchor = name.mid( n );
+      name.truncate( n );
+      anchor.replace( QRegExp( "(g[0-9a-f]{32}_)[0-9a-f]+_" ), "\\1" ); // MDict anchors
+    }
+    name.replace( rxName, "_" );
+    name = QString( "href=\"" ) + QUrl::toPercentEncoding( name ) + ".html" + anchor + "\"";
+    html.replace( pos, rx3.cap().length(), name );
+    pos += name.length();
+  }
 
-      // Convert internal links
+  // MDict anchors
+  QRegExp anchorLinkRe( "(<\\s*a\\s+[^>]*\\b(?:name|id)\\b\\s*=\\s*[\"']*g[0-9a-f]{32}_)([0-9a-f]+_)(?=[^\"'])", Qt::CaseInsensitive );
+  html.replace( anchorLinkRe, "\\1" );
 
-      QRegExp rx3( "href=\"(bword:|gdlookup://localhost/)([^\"]+)\"" );
-      int pos = 0;
-      while ( ( pos = rx3.indexIn( html, pos ) ) != -1 )
-      {
-        QString name = QUrl::fromPercentEncoding( rx3.cap( 2 ).simplified().toLatin1() );
-        QString anchor;
-        name.replace( "?gdanchor=", "#" );
-        int n = name.indexOf( '#' );
-        if( n > 0 )
-        {
-          anchor = name.mid( n );
-          name.truncate( n );
-          anchor.replace( QRegExp( "(g[0-9a-f]{32}_)[0-9a-f]+_" ), "\\1" ); // MDict anchors
-        }
-        name.replace( rxName, "_" );
-        name = QString( "href=\"" ) + QUrl::toPercentEncoding( name ) + ".html" + anchor + "\"";
-        html.replace( pos, rx3.cap().length(), name );
-        pos += name.length();
-      }
+#ifdef USE_QTWEBKIT
+  Q_ASSERT( !progressDialog );
 
-      // MDict anchors
-      QRegExp anchorLinkRe( "(<\\s*a\\s+[^>]*\\b(?:name|id)\\b\\s*=\\s*[\"']*g[0-9a-f]{32}_)([0-9a-f]+_)(?=[^\"'])", Qt::CaseInsensitive );
-      html.replace( anchorLinkRe, "\\1" );
+  if( !complete )
+  {
+    file.write( html.toUtf8() );
+    return;
+  }
 
-      if ( complete )
-      {
-        QString folder = fi.absoluteDir().absolutePath() + "/" + fi.baseName() + "_files";
-        QRegExp rx1( "\"((?:bres|gico|gdau|qrcx|gdvideo)://[^\"]+)\"" );
-        QRegExp rx2( "'((?:bres|gico|gdau|qrcx|gdvideo)://[^']+)'" );
-        set< QByteArray > resourceIncluded;
-        vector< pair< QUrl, QString > > downloadResources;
-
-        filterAndCollectResources( html, rx1, "\"", folder, resourceIncluded, downloadResources );
-        filterAndCollectResources( html, rx2, "'", folder, resourceIncluded, downloadResources );
-
-        ArticleSaveProgressDialog * progressDialog = new ArticleSaveProgressDialog( this );
-        // reserve '1' for saving main html file
-        int maxVal = 1;
-
-        // Pull and save resources to files
-        for ( vector< pair< QUrl, QString > >::const_iterator i = downloadResources.begin();
-              i != downloadResources.end(); ++i )
-        {
-          ResourceToSaveHandler * handler = view->saveResource( i->first, i->second );
-          if( !handler->isEmpty() )
-          {
-            maxVal += 1;
-            connect( handler, SIGNAL( done() ), progressDialog, SLOT( perform() ) );
-          }
-        }
+  progressDialog = new ArticleSaveProgressDialog( this );
+  progressDialog->show();
+#else
+  Q_ASSERT( progressDialog );
 
-        progressDialog->setLabelText( tr("Saving article...") );
-        progressDialog->setRange( 0, maxVal );
-        progressDialog->setValue( 0 );
-        progressDialog->show();
+  if( complete )
+#endif
+  {
+    insertSavedArticleScript( html );
 
-        file.write( html.toUtf8() );
-        progressDialog->setValue( 1 );
-      }
-      else
-      {
-        file.write( html.toUtf8() );
-      }
-    }
+    QString pathFromHtmlToDestinationDir = fi.baseName() + "_files/";
+    QString resourceDestinationDir = fi.absoluteDir().absolutePath() + '/' + pathFromHtmlToDestinationDir;
+    new ArticleResourceSaver( html, pathFromHtmlToDestinationDir, resourceDestinationDir, view, *progressDialog );
   }
+
+  file.write( html.toUtf8() );
+  progressDialog->operationCompleted();
 }
 
 void MainWindow::on_rescanFiles_triggered()
@@ -3853,7 +4313,7 @@ void MainWindow::applyZoomFactor()
   // triggered() signal is no longer emitted, which in turn improves performance.
   adjustCurrentZoomFactor();
 
-#if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
+#if defined( USE_QTWEBKIT ) && QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
   // Scaling article views asynchronously dramatically improves performance when
   // a zoom action is triggered repeatedly while many or large articles are open
   // in the main window or in scan popup.
@@ -3862,26 +4322,43 @@ void MainWindow::applyZoomFactor()
   // so all of them except for the first one don't change anything and run very fast.
   // In effect, some intermediate zoom factors are skipped when scaling is slow.
   // The slower the scaling, the more steps are skipped.
+
+  // Unfortunately this optimization does not work in the Qt WebEngine version, where
+  // the UI does not completely freeze (e.g. scrolling the page still works) and events
+  // keep being delivered even as the page is being scaled in a separate process.
+  // This issue must have been fixed upstream in Qt 6.4.0 or earlier, because repeated zooming is slow in
+  // Qt WebEngine Widgets Simple Browser Example version 5.15.10 and fast in the same example version 6.4.0.
+
   QTimer::singleShot( 0, this, SLOT( scaleArticlesByCurrentZoomFactor() ) );
 #else
+  // The timer trick above does not help in unfixed Qt WebEngine versions and is not needed in fixed ones.
+
   // The timer trick above usually doesn't improve performance with Qt4
   // due to a different ordering of keyboard and timer events.
   // Sometimes, unpredictably, it does work like with Qt5.
   // Scale article views synchronously to avoid inconsistent or unexpected behavior.
+
   scaleArticlesByCurrentZoomFactor();
 #endif
 }
 
 void MainWindow::adjustCurrentZoomFactor()
 {
-  if ( cfg.preferences.zoomFactor >= 5 )
-    cfg.preferences.zoomFactor = 5;
-  else if ( cfg.preferences.zoomFactor <= 0.1 )
-    cfg.preferences.zoomFactor = 0.1;
+  // Valid values of QWebEngineView's zoom factor are within the range from 0.25 to 5.0. The default factor is 1.0.
+  // zoomin() and zoomout() adjust zoomFactor by the step 0.1. The difference between the maximum and the default
+  // zoom factors, as well as between the default and the minimum zoom factors, should be divisible by this step to
+  // avoid different intermediate factors depending on the starting point (default, minimum or maximum).
+  qreal const minZoomFactor = 0.3;
+  qreal const maxZoomFactor = 5.0;
+
+  if( cfg.preferences.zoomFactor < minZoomFactor )
+    cfg.preferences.zoomFactor = minZoomFactor;
+  else if( cfg.preferences.zoomFactor > maxZoomFactor )
+    cfg.preferences.zoomFactor = maxZoomFactor;
 
-  zoomIn->setEnabled( cfg.preferences.zoomFactor < 5 );
-  zoomOut->setEnabled( cfg.preferences.zoomFactor > 0.1 );
-  zoomBase->setEnabled( cfg.preferences.zoomFactor != 1.0 );
+  zoomIn->setEnabled( !qFuzzyCompare( cfg.preferences.zoomFactor, maxZoomFactor )  );
+  zoomOut->setEnabled( !qFuzzyCompare( cfg.preferences.zoomFactor, minZoomFactor ) );
+  zoomBase->setEnabled( !qFuzzyCompare( cfg.preferences.zoomFactor, 1.0 ) );
 }
 
 void MainWindow::scaleArticlesByCurrentZoomFactor()
@@ -3952,7 +4429,15 @@ void MainWindow::applyWordsZoomLevel()
   }
 
   if ( translateLine->font().pointSize() != ps )
+  {
     translateLine->setFont( font );
+    if( cfg.preferences.searchInDock )
+    {
+      // loadingIndicatorLabel's size hint is bound to ui.translateLine->height(), which depends on the font.
+      // Update the label's geometry to resize it immediately rather than after it is hidden and shown again.
+      ui.loadingIndicatorLabel->updateGeometry();
+    }
+  }
 
   font = groupListDefaultFont;
 
@@ -5021,6 +5506,8 @@ bool MainWindow::handleGDMessage( MSG * message, long * result )
     return false;
   *result = 0;
 
+  // TODO (Qt WebEngine): re-enable this code if ArticleView::wordAtPoint() is ported.
+#ifdef USE_QTWEBKIT
   if( !isGoldenDictWindow( message->hwnd ) )
     return true;
 
@@ -5037,6 +5524,7 @@ bool MainWindow::handleGDMessage( MSG * message, long * result )
   str.toWCharArray( lpdata->cwData );
 
   *result = 1;
+#endif // USE_QTWEBKIT
   return true;
 }
 
@@ -5047,6 +5535,4 @@ bool MainWindow::isGoldenDictWindow( HWND hwnd )
 
 #endif
 
-#ifdef X11_MAIN_WINDOW_FOCUS_WORKAROUNDS
 #include "mainwindow.moc"
-#endif
diff --git a/mainwindow.hh b/mainwindow.hh
index 36433ff3..4b146620 100644
--- a/mainwindow.hh
+++ b/mainwindow.hh
@@ -9,7 +9,6 @@
 #include <QToolButton>
 #include <QSystemTrayIcon>
 #include <QNetworkAccessManager>
-#include <QProgressDialog>
 #include "ui_mainwindow.h"
 #include "folding.hh"
 #include "config.hh"
@@ -36,6 +35,12 @@
 #include <fixx11h.h>
 #endif
 
+#ifndef USE_QTWEBKIT
+#include <memory>
+
+class QWebEngineProfile;
+#endif
+
 #ifdef HAVE_X11
   // TODO: implement startup notification support and remove these workarounds
   // (see investigation comments on #781).
@@ -45,6 +50,8 @@
 using std::string;
 using std::vector;
 
+class ArticleSaveProgressDialog;
+
 class ExpandableToolBar : public QToolBar
 {
   Q_OBJECT
@@ -163,6 +170,11 @@ private:
   QNetworkAccessManager dictNetMgr; // We give dictionaries a separate manager,
                                     // since their requests can be destroyed
                                     // in a separate thread
+
+#ifndef USE_QTWEBKIT
+  std::unique_ptr< QWebEngineProfile > webEngineProfile;
+#endif
+
   AudioPlayerFactory audioPlayerFactory;
 
   WordList * wordList;
@@ -220,9 +232,14 @@ private:
 
   void updatePronounceAvailability();
 
+  void appendToFoundInDictsList( QString const & id, bool isActive );
   void updateFoundInDictsList();
 
+  void updateIsPageLoading();
+  void setIsPageLoading( bool isLoading );
+
   void updateBackForwardButtons();
+  void updateBackForwardButtons( ArticleView * view );
 
   void updateWindowTitle();
 
@@ -261,6 +278,9 @@ private:
   ArticleView * getCurrentArticleView();
   void ctrlTabPressed();
 
+  void saveArticleAs( ArticleView & view, QString & html, QString const & fileName, bool complete,
+                      QRegExp const & rxName, ArticleSaveProgressDialog * progressDialog );
+
   void fillWordListFromHistory();
 
   void showDictionaryHeadwords( QWidget * owner, Dictionary::Class * dict );
@@ -355,6 +375,11 @@ private slots:
   /// ArticleView's icon has changed
   void iconChanged( ArticleView *, QIcon const & );
 
+  void pageLoadingStateChanged( ArticleView *, bool isLoading );
+  void canGoBackForwardChanged( ArticleView * );
+
+  void pageUnloaded( ArticleView * );
+  void articleLoaded( ArticleView *, QString const & id, bool isActive );
   void pageLoaded( ArticleView * );
   void tabSwitched( int );
   void tabMenuRequested(QPoint pos);
@@ -413,7 +438,7 @@ private slots:
 
   void openLinkInNewTab( QUrl const &, QUrl const &, QString const &,
                          ArticleView::Contexts const & contexts );
-  void showDefinitionInNewTab( QString const & word, unsigned group,
+  void showDefinitionInNewTab( Config::InputPhrase const & phrase, unsigned group,
                                QString const & fromArticle,
                                ArticleView::Contexts const & contexts );
   void typingEvent( QString const & );
@@ -529,29 +554,4 @@ private slots:
 #endif
 };
 
-class ArticleSaveProgressDialog : public QProgressDialog
-{
-Q_OBJECT
-
-public:
-  explicit ArticleSaveProgressDialog( QWidget * parent = 0,  Qt::WindowFlags f = Qt::WindowFlags() ):
-    QProgressDialog( parent, f )
-  {
-    setAutoReset( false );
-    setAutoClose( false );
-  }
-
-public slots:
-  void perform()
-  {
-    int progress = value() + 1;
-    if ( progress == maximum() )
-    {
-      emit close();
-      deleteLater();
-    }
-    setValue( progress );
-  }
-};
-
 #endif
diff --git a/mainwindow.ui b/mainwindow.ui
index 25ac51da..cdfda079 100644
--- a/mainwindow.ui
+++ b/mainwindow.ui
@@ -185,60 +185,74 @@
       <number>1</number>
      </property>
      <item>
-      <widget class="QLineEdit" name="translateLine">
-       <property name="minimumSize">
-        <size>
-         <width>200</width>
-         <height>0</height>
-        </size>
-       </property>
-       <property name="baseSize">
-        <size>
-         <width>0</width>
-         <height>0</height>
-        </size>
-       </property>
-       <property name="palette">
-        <palette>
-         <active>
-          <colorrole role="Base">
-           <brush brushstyle="SolidPattern">
-            <color alpha="255">
-             <red>254</red>
-             <green>253</green>
-             <blue>235</blue>
-            </color>
-           </brush>
-          </colorrole>
-         </active>
-         <inactive>
-          <colorrole role="Base">
-           <brush brushstyle="SolidPattern">
-            <color alpha="255">
-             <red>254</red>
-             <green>253</green>
-             <blue>235</blue>
-            </color>
-           </brush>
-          </colorrole>
-         </inactive>
-         <disabled>
-          <colorrole role="Base">
-           <brush brushstyle="SolidPattern">
-            <color alpha="255">
-             <red>255</red>
-             <green>255</green>
-             <blue>255</blue>
-            </color>
-           </brush>
-          </colorrole>
-         </disabled>
-        </palette>
-       </property>
-       <property name="frame">
-        <bool>true</bool>
-       </property>
-      </widget>
+      <layout class="QHBoxLayout" name="horizontalLayout">
+       <item>
+        <widget class="QLineEdit" name="translateLine">
+         <property name="minimumSize">
+          <size>
+           <width>200</width>
+           <height>0</height>
+          </size>
+         </property>
+         <property name="baseSize">
+          <size>
+           <width>0</width>
+           <height>0</height>
+          </size>
+         </property>
+         <property name="palette">
+          <palette>
+           <active>
+            <colorrole role="Base">
+             <brush brushstyle="SolidPattern">
+              <color alpha="255">
+               <red>254</red>
+               <green>253</green>
+               <blue>235</blue>
+              </color>
+             </brush>
+            </colorrole>
+           </active>
+           <inactive>
+            <colorrole role="Base">
+             <brush brushstyle="SolidPattern">
+              <color alpha="255">
+               <red>254</red>
+               <green>253</green>
+               <blue>235</blue>
+              </color>
+             </brush>
+            </colorrole>
+           </inactive>
+           <disabled>
+            <colorrole role="Base">
+             <brush brushstyle="SolidPattern">
+              <color alpha="255">
+               <red>255</red>
+               <green>255</green>
+               <blue>255</blue>
+              </color>
+             </brush>
+            </colorrole>
+           </disabled>
+          </palette>
+         </property>
+         <property name="frame">
+          <bool>true</bool>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="SquareLabel" name="loadingIndicatorLabel">
+         <property name="pixmap">
+          <pixmap resource="resources.qrc">:/icons/loading.gif</pixmap>
+         </property>
+         <property name="scaledContents">
+          <bool>true</bool>
+         </property>
+        </widget>
+       </item>
+      </layout>
      </item>
      <item>
       <widget class="WordList" name="wordList">
@@ -709,6 +723,11 @@
    <extends>QTreeView</extends>
    <header>treeview.hh</header>
   </customwidget>
+  <customwidget>
+   <class>SquareLabel</class>
+   <extends>QLabel</extends>
+   <header>square_label.hh</header>
+  </customwidget>
  </customwidgets>
  <tabstops>
   <tabstop>translateLine</tabstop>
diff --git a/mdx.cc b/mdx.cc
index 8595d59d..ff9ca4e2 100644
--- a/mdx.cc
+++ b/mdx.cc
@@ -205,7 +205,9 @@ class MdxDictionary: public BtreeIndexing::BtreeDictionary
   QSemaphore deferredInitRunnableExited;
 
   string initError;
+#ifdef USE_QTWEBKIT
   QString cacheDirName;
+#endif
 
 public:
 
@@ -273,7 +275,9 @@ public:
               && ( fts.maxDictionarySize == 0 || getArticleCount() <= fts.maxDictionarySize );
   }
 
+#ifdef USE_QTWEBKIT
   QString getCachedFileName( QString name );
+#endif
 
 protected:
 
@@ -290,7 +294,9 @@ private:
   /// Process resource links (images, audios, etc)
   QString & filterResource( QString const & articleId, QString & article );
 
+#ifdef USE_QTWEBKIT
   void removeDirectory( QString const & directory );
+#endif
 
   friend class MdxHeadwordsRequest;
   friend class MdxArticleRequest;
@@ -338,9 +344,11 @@ MdxDictionary::MdxDictionary( string const & id, string const & indexFile,
       && !FtsHelpers::ftsIndexIsOldOrBad( ftsIdxName, this ) )
     FTS_index_completed.ref();
 
+#ifdef USE_QTWEBKIT
   cacheDirName = QDir::tempPath() + QDir::separator()
                  + QString::fromUtf8( getId().c_str() )
                  + ".cache";
+#endif
 }
 
 MdxDictionary::~MdxDictionary()
@@ -353,7 +361,9 @@ MdxDictionary::~MdxDictionary()
 
   dictFile.close();
 
+#ifdef USE_QTWEBKIT
   removeDirectory( cacheDirName );
+#endif
 }
 
 //////// MdxDictionary::deferredInit()
@@ -1054,7 +1064,11 @@ QString & MdxDictionary::filterResource( QString const & articleId, QString & ar
   QString id = QString::fromStdString( getId() );
   QString uniquePrefix = QString::fromLatin1( "g" ) + id + "_" + articleId + "_";
 
+#ifdef USE_QTWEBKIT
   QRegularExpression allLinksRe( "(?:<\\s*(a(?:rea)?|img|link|script|source)(?:\\s+[^>]+|\\s*)>)",
+#else
+  QRegularExpression allLinksRe( "(?:<\\s*(a(?:rea)?|img|link|script|source|audio|video)(?:\\s+[^>]+|\\s*)>)",
+#endif
                                  QRegularExpression::CaseInsensitiveOption );
   QRegularExpression wordCrossLink( "([\\s\"']href\\s*=)\\s*([\"'])entry://([^>#]*?)((?:#[^>]*?)?)\\2",
                                     QRegularExpression::CaseInsensitiveOption );
@@ -1117,7 +1131,7 @@ QString & MdxDictionary::filterResource( QString const & articleId, QString & ar
         QString newTxt = match.captured( 1 ) + match.captured( 2 )
                          + "gdau://" + id + "/"
                          + match.captured( 3 ) + match.captured( 2 );
-        newLink = QString::fromUtf8( addAudioLink( "\"gdau://" + getId() + "/" + match.captured( 3 ).toUtf8().data() + "\"", getId() ).c_str() )
+        newLink = QString::fromUtf8( addAudioLink( "\"gdau://" + getId() + "/" + match.captured( 3 ).toUtf8().data() + "\"" ).c_str() )
                   + newLink.replace( match.capturedStart(), match.capturedLength(), newTxt );
       }
 
@@ -1178,11 +1192,39 @@ QString & MdxDictionary::filterResource( QString const & articleId, QString & ar
           QString newText;
           if( linkType.at( 1 ) == 'o' ) // "source" tag
           {
+            // Quote from https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source:
+            //   The <source> HTML element specifies multiple media resources for
+            //   the <picture>, the <audio> element, or the <video> element.
+
             QString filename = match.captured( 3 );
+#ifdef USE_QTWEBKIT
+            // Store the file in a temporary cache directory and reference it in the link,
+            // because gdvideo:// links don't work in the Qt WebKit version for some reason.
+            // TODO (Qt WebKit): this workaround is applied to all <source> elements,
+            // including those nested in <audio> and <picture> elements. Are such elements
+            // present in any MDict dictionaries? If yes, is the workaround needed for them?
             QString newName = getCachedFileName( filename );
             newName.replace( '\\', '/' );
             newText = match.captured( 1 ) + match.captured( 2 )
                       + "file:///" + newName + match.captured( 2 );
+#else
+            QLatin1String scheme;
+            auto const filenameStd = filename.toStdString();
+            if( Filetype::isNameOfSound( filenameStd ) )
+              scheme = QLatin1String{ "gdau" };
+            else
+            if( Filetype::isNameOfVideo( filenameStd ) )
+              scheme = QLatin1String{ "gdvideo" };
+            else
+              scheme = QLatin1String{ "bres" };
+
+            auto const quote = match.capturedView( 2 );
+            // Use % in place of +, because operator+ is missing for QStringView.
+            // TODO: consider whether defining QT_USE_QSTRINGBUILDER in goldendict.pro
+            // to improve performance everywhere is safe enough (see QString documentation).
+            newText = match.capturedView( 1 ) % quote % scheme % QLatin1String{ "://" }
+                      % id % QLatin1Char{ '/' } % filename % quote;
+#endif
           }
           else
           {
@@ -1197,6 +1239,31 @@ QString & MdxDictionary::filterResource( QString const & articleId, QString & ar
                                      "\\1\"bres://" + id + "/\\2\"" );
       }
     }
+// The getCachedFileName() workaround in the Qt WebKit version eliminates the preload attribute value requirement.
+#ifndef USE_QTWEBKIT
+    else
+    {
+      Q_ASSERT( linkType == QLatin1String{ "audio" } || linkType == QLatin1String{ "video" } );
+      // If the preload attribute value is not "auto", the video is unplayable
+      // and the following errors appear in GoldenDict's output:
+      // QIODevice::seek (ArticleResourceReply): Cannot call seek on a sequential device
+      // [...:ERROR:batching_media_log.cc(38)] MediaEvent: {"error":"FFmpegDemuxer: open context failed"}
+      // [...:ERROR:batching_media_log.cc(35)] MediaEvent: {"pipeline_error":12}
+      // TODO (Qt WebEngine): is forcing the preload attribute value needed for <audio> elements?
+
+      // Remove all existing preload attributes.
+      static QRegularExpression const preloadRe( QStringLiteral( R"(\spreload\s*=\s*(["'])\w*\1)" ),
+                                                 QRegularExpression::CaseInsensitiveOption );
+      linkTxt.remove( preloadRe );
+
+      // Insert the necessary preload attribute value at the end of the tag.
+      Q_ASSERT( linkTxt.at( linkTxt.size() - 1 ) == QLatin1Char{ '>' } );
+      linkTxt.insert( linkTxt.size() - 1, QLatin1String{ " preload=\"auto\"" } );
+
+      newLink = linkTxt;
+    }
+#endif
+
     if( !newLink.isEmpty() )
     {
       articleNewText += newLink;
@@ -1272,7 +1339,7 @@ QString & MdxDictionary::filterResource( QString const & articleId, QString & ar
         QString newTxt = audioRe.cap( 1 ) + audioRe.cap( 2 )
                          + "gdau://" + id + "/"
                          + audioRe.cap( 3 ) + audioRe.cap( 2 );
-        newLink = QString::fromUtf8( addAudioLink( "\"gdau://" + getId() + "/" + audioRe.cap( 3 ).toUtf8().data() + "\"", getId() ).c_str() )
+        newLink = QString::fromUtf8( addAudioLink( "\"gdau://" + getId() + "/" + audioRe.cap( 3 ).toUtf8().data() + "\"" ).c_str() )
                   + newLink.replace( pos, audioRe.cap().length(), newTxt );
       }
 
@@ -1360,6 +1427,7 @@ QString & MdxDictionary::filterResource( QString const & articleId, QString & ar
 }
 #endif
 
+#ifdef USE_QTWEBKIT
 QString MdxDictionary::getCachedFileName( QString filename )
 {
   QDir dir;
@@ -1506,6 +1574,7 @@ void MdxDictionary::removeDirectory( QString const & directory )
 
   dir.rmdir( directory );
 }
+#endif // USE_QTWEBKIT
 
 static void addEntryToIndex( QString const & word, uint32_t offset, IndexedWords & indexedWords )
 {
diff --git a/mediawiki.cc b/mediawiki.cc
index 6dbb89e2..405f508f 100644
--- a/mediawiki.cc
+++ b/mediawiki.cc
@@ -616,7 +616,7 @@ void MediaWikiArticleRequest::requestFinished( QNetworkReply * r )
               {
                 QString ref = match2.captured( 1 );
                 QString audio_url = "<a href=\"" + ref
-                                    + "\"><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" align=\"absmiddle\" alt=\"Play\"/></a>";
+                                    + "\"><img src=\"qrc:///icons/playsound.png\" border=\"0\" align=\"absmiddle\" alt=\"Play\"/></a>";
                 articleNewString += audio_url;
               }
               else
@@ -643,7 +643,7 @@ void MediaWikiArticleRequest::requestFinished( QNetworkReply * r )
                 {
                   QString ref = reg2.cap( 1 );
                   QString audio_url = "<a href=\"" + ref
-                                      + "\"><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" align=\"absmiddle\" alt=\"Play\"/></a>";
+                                      + "\"><img src=\"qrc:///icons/playsound.png\" border=\"0\" align=\"absmiddle\" alt=\"Play\"/></a>";
                   articleString.replace( pos, tag.length(), audio_url );
                 }
                 pos += 1;
@@ -658,8 +658,8 @@ void MediaWikiArticleRequest::requestFinished( QNetworkReply * r )
 #else
             articleString.replace( QRegExp( "<a\\s+href=\"(//upload\\.wikimedia\\.org/wikipedia/[^\"'&]*\\.og[ga](?:\\.mp3|))\"" ),
 #endif
-                                   QString::fromStdString( addAudioLink( string( "\"" ) + wikiUrl.scheme().toStdString() + ":\\1\"",
-                                                                         this->dictPtr->getId() ) + "<a href=\"" + wikiUrl.scheme().toStdString() + ":\\1\"" ) );
+                                   QString::fromStdString( addAudioLink( string( "\"" ) + wikiUrl.scheme().toStdString() + ":\\1\"" )
+                                                           + "<a href=\"" + wikiUrl.scheme().toStdString() + ":\\1\"" ) );
 
             // Add url scheme to image source urls
             articleString.replace( " src=\"//", " src=\"" + wikiUrl.scheme() + "://" );
diff --git a/mutex.hh b/mutex.hh
index 8df8d1b7..be93538b 100644
--- a/mutex.hh
+++ b/mutex.hh
@@ -13,11 +13,28 @@
 class Mutex: public QMutex
 {
 public:
+
+// Only the MdxDictionary::getCachedFileName() workaround, which is restricted to the Qt WebKit version, relies on
+// the recursiveness of Mutex. Keep Mutex nonrecursive in the Qt WebEngine version to avoid performance penalty.
+#ifdef USE_QTWEBKIT
+   // `#pragma GCC diagnostic push` and `#pragma GCC diagnostic pop` were introduced in GCC 4.6.
+#  if __GNUC__ > 4 || ( __GNUC__ == 4 && __GNUC_MINOR__ >= 6 )
+#    pragma GCC diagnostic push
+     // QMutex::Recursive is deprecated in Qt 5.15 and absent from Qt 6.0+. It is used only in the Qt WebKit version.
+     // Qt WebKit has not been properly ported to Qt 6. So this deprecation warning is not a problem and can be ignored.
+#    pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+#  endif
+
   Mutex() : QMutex( Recursive )
   {}
   ~Mutex()
   {}
 
+#  if __GNUC__ > 4 || ( __GNUC__ == 4 && __GNUC_MINOR__ >= 6 )
+#    pragma GCC diagnostic pop
+#  endif
+#endif // USE_QTWEBKIT
+
   /// Locks the given mutex on construction and unlocks on destruction
   class Lock
   {
diff --git a/preferences.cc b/preferences.cc
index 05b5bca8..246ecb93 100644
--- a/preferences.cc
+++ b/preferences.cc
@@ -39,7 +39,7 @@ void orderAndAddItems( QComboBox & comboBox, std::vector< ComboBoxItem > & items
 } // unnamed namespace
 
 Preferences::Preferences( QWidget * parent, Config::Class & cfg_ ):
-  QDialog( parent ), prevInterfaceLanguage( 0 )
+  QDialog( parent ), prevInterfaceLanguage( 0 ), prevOffTheRecordWebProfile( false )
 , helpWindow( 0 )
 , cfg( cfg_ )
 , helpAction( this )
@@ -280,6 +280,12 @@ Preferences::Preferences( QWidget * parent, Config::Class & cfg_ ):
   ui.ignoreOwnClipboardChanges->hide();
 #endif
 
+#ifdef USE_QTWEBKIT
+  ui.networkTabLayout->removeItem( ui.offTheRecordVerticalSpacer );
+  delete ui.offTheRecordVerticalSpacer;
+  ui.offTheRecordWebProfile->hide();
+#endif
+
   // Sound
 
   ui.pronounceOnLoadMain->setChecked( p.pronounceOnLoadMain );
@@ -352,6 +358,8 @@ Preferences::Preferences( QWidget * parent, Config::Class & cfg_ ):
   ui.hideGoldenDictHeader->setChecked( p.hideGoldenDictHeader );
   ui.maxNetworkCacheSize->setValue( p.maxNetworkCacheSize );
   ui.clearNetworkCacheOnExit->setChecked( p.clearNetworkCacheOnExit );
+  ui.offTheRecordWebProfile->setChecked( p.offTheRecordWebProfile );
+  prevOffTheRecordWebProfile = p.offTheRecordWebProfile;
 
   // Add-on styles
   ui.addonStylesLabel->setVisible( ui.addonStyles->count() > 1 );
@@ -484,6 +492,7 @@ Config::Preferences Preferences::getPreferences()
   p.hideGoldenDictHeader = ui.hideGoldenDictHeader->isChecked();
   p.maxNetworkCacheSize = ui.maxNetworkCacheSize->value();
   p.clearNetworkCacheOnExit = ui.clearNetworkCacheOnExit->isChecked();
+  p.offTheRecordWebProfile = ui.offTheRecordWebProfile->isChecked();
 
   p.addonStyle = ui.addonStyles->getCurrentStyle();
 
@@ -660,6 +669,12 @@ void Preferences::on_buttonBox_accepted()
   if ( prevInterfaceLanguage != ui.interfaceLanguage->currentIndex() )
     QMessageBox::information( this, tr( "Changing Language" ),
                               tr( "Restart the program to apply the language change." ) );
+
+  if( prevOffTheRecordWebProfile != ui.offTheRecordWebProfile->isChecked() )
+  {
+    QMessageBox::information( this, tr( "Changing off-the-record" ),
+                              tr( "Restart the program to apply the off-the-record web profile change." ) );
+  }
 }
 
 void Preferences::on_useExternalPlayer_toggled( bool enabled )
diff --git a/preferences.hh b/preferences.hh
index 71142091..8a44c460 100644
--- a/preferences.hh
+++ b/preferences.hh
@@ -12,6 +12,7 @@ class Preferences: public QDialog
   Q_OBJECT
 
   int prevInterfaceLanguage;
+  bool prevOffTheRecordWebProfile;
 
   Help::HelpWindow * helpWindow;
   Config::Class & cfg;
diff --git a/preferences.ui b/preferences.ui
index 073fad17..899907e8 100644
--- a/preferences.ui
+++ b/preferences.ui
@@ -976,7 +976,7 @@ p, li { white-space: pre-wrap; }
       <attribute name="title">
        <string>&amp;Network</string>
       </attribute>
-      <layout class="QVBoxLayout" name="verticalLayout_9">
+      <layout class="QVBoxLayout" name="networkTabLayout">
        <item>
         <spacer name="verticalSpacer_5">
          <property name="orientation">
@@ -1205,6 +1205,33 @@ clears its network cache from disk during exit.</string>
          </item>
         </layout>
        </item>
+       <item>
+        <spacer name="offTheRecordVerticalSpacer">
+         <property name="orientation">
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeType">
+          <enum>QSizePolicy::Fixed</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>20</width>
+           <height>10</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+       <item>
+        <widget class="QCheckBox" name="offTheRecordWebProfile">
+         <property name="toolTip">
+          <string>An off-the-record profile leaves no record on the local machine,
+and has no persistent data or cache.</string>
+         </property>
+         <property name="text">
+          <string>Use off-the-record web profile</string>
+         </property>
+        </widget>
+       </item>
        <item>
         <spacer name="verticalSpacer_10">
          <property name="orientation">
diff --git a/programs.cc b/programs.cc
index 4505e58b..eec29d6f 100644
--- a/programs.cc
+++ b/programs.cc
@@ -94,9 +94,9 @@ sptr< Dictionary::DataRequest > ProgramsDictionary::getArticle(
 
       string ref = string( "\"" ) + url.toEncoded().data() + "\"";
 
-      result += addAudioLink( ref, getId() );
+      result += addAudioLink( ref );
 
-      result += "<td><a href=" + ref + "><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
+      result += "<td><a href=" + ref + "><img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
       result += "<td><a href=" + ref + ">" +
                 Html::escape( wordUtf8 ) + "</a></td>";
       result += "</tr></table>";
diff --git a/resources.qrc b/resources.qrc
index 774cf53c..eee138af 100644
--- a/resources.qrc
+++ b/resources.qrc
@@ -18,6 +18,7 @@
         <file>icons/wizard.png</file>
         <file>icons/warning.png</file>
         <file>article-style.css</file>
+        <file>article-style-expand-optional-parts.css</file>
         <file>article-style-print.css</file>
         <file>qt-style.css</file>
         <file>icons/icon32_dsl.png</file>
@@ -84,5 +85,6 @@
         <file>icons/star_blue.png</file>
         <file>icons/folder.png</file>
         <file>icons/ontop.png</file>
+        <file>icons/loading.gif</file>
     </qresource>
 </RCC>
diff --git a/scanpopup.cc b/scanpopup.cc
index 38870e02..349fe329 100644
--- a/scanpopup.cc
+++ b/scanpopup.cc
@@ -69,6 +69,9 @@ static bool ownsClipboardMode( QClipboard::Mode mode )
 ScanPopup::ScanPopup( QWidget * parent,
                       Config::Class & cfg_,
                       ArticleNetworkAccessManager & articleNetMgr,
+#ifndef USE_QTWEBKIT
+                      QWebEngineProfile & webEngineProfile,
+#endif
                       AudioPlayerPtr const & audioPlayer_,
                       std::vector< sptr< Dictionary::Class > > const & allDictionaries_,
                       Instances::Groups const & groups_,
@@ -106,7 +109,11 @@ ScanPopup::ScanPopup( QWidget * parent,
 
   ui.queryError->hide();
 
-  definition = new ArticleView( ui.outerFrame, articleNetMgr, audioPlayer_,
+  definition = new ArticleView( ui.outerFrame, articleNetMgr,
+#ifndef USE_QTWEBKIT
+                                webEngineProfile,
+#endif
+                                audioPlayer_,
                                 allDictionaries, groups, true, cfg,
                                 openSearchAction,
                                 dictionaryBar.toggleViewAction()
@@ -266,6 +273,18 @@ ScanPopup::ScanPopup( QWidget * parent,
   connect( ui.pinButton, SIGNAL( clicked( bool ) ),
            this, SLOT( pinButtonClicked( bool ) ) );
 
+  connect( definition, SIGNAL( pageLoadingStateChanged( ArticleView *, bool ) ),
+           this, SLOT( pageLoadingStateChanged( ArticleView *, bool ) ) );
+
+  connect( definition, SIGNAL( canGoBackForwardChanged( ArticleView * ) ),
+           this, SLOT( updateBackForwardButtons() ) );
+
+  connect( definition, SIGNAL( pageUnloaded( ArticleView * ) ),
+           this, SLOT( pageUnloaded() ) );
+
+  connect( definition, SIGNAL( articleLoaded( ArticleView *, QString const &, bool ) ),
+           this, SLOT( articleLoaded() ) );
+
   connect( definition, SIGNAL( pageLoaded( ArticleView * ) ),
            this, SLOT( pageLoaded( ArticleView * ) ) );
 
@@ -362,6 +381,8 @@ ScanPopup::~ScanPopup()
 
 void ScanPopup::saveConfigData()
 {
+  definition->saveConfigData();
+
   // Save state, geometry and pin status
   cfg.popupWindowState = saveState( 1 );
   cfg.popupWindowGeometry = saveGeometry();
@@ -1188,12 +1209,18 @@ void ScanPopup::altModePoll()
   }
 }
 
-void ScanPopup::pageLoaded( ArticleView * )
+void ScanPopup::pageUnloaded()
 {
-  ui.pronounceButton->setVisible( definition->hasSound() );
+  ui.pronounceButton->hide();
+}
 
-  updateBackForwardButtons();
+void ScanPopup::articleLoaded()
+{
+  ui.pronounceButton->setVisible( definition->hasSound() );
+}
 
+void ScanPopup::pageLoaded( ArticleView * )
+{
   if ( cfg.preferences.pronounceOnLoadPopup )
     definition->playSound();
 }
@@ -1312,6 +1339,11 @@ void ScanPopup::switchExpandOptionalPartsMode()
     emit switchExpandMode();
 }
 
+void ScanPopup::pageLoadingStateChanged( ArticleView *, bool isLoading )
+{
+  ui.translateBox->setIsPageLoading( isLoading );
+}
+
 void ScanPopup::updateBackForwardButtons()
 {
   ui.goBackButton->setEnabled(definition->canGoBack());
diff --git a/scanpopup.hh b/scanpopup.hh
index e3751eb2..7039780a 100644
--- a/scanpopup.hh
+++ b/scanpopup.hh
@@ -19,6 +19,10 @@
 #include "scanflag.hh"
 #endif
 
+#ifndef USE_QTWEBKIT
+class QWebEngineProfile;
+#endif
+
 /// This is a popup dialog to show translations when clipboard scanning mode
 /// is enabled.
 class ScanPopup: public QMainWindow, KeyboardState
@@ -30,6 +34,9 @@ public:
   ScanPopup( QWidget * parent,
              Config::Class & cfg,
              ArticleNetworkAccessManager &,
+#ifndef USE_QTWEBKIT
+             QWebEngineProfile &,
+#endif
              AudioPlayerPtr const &,
              std::vector< sptr< Dictionary::Class > > const & allDictionaries,
              Instances::Groups const &,
@@ -185,8 +192,6 @@ private:
   /// Returns inputWord, chopped with appended ... if it's too long/
   QString elideInputWord();
 
-  void updateBackForwardButtons();
-
   void showTranslationFor( Config::InputPhrase const & inputPhrase );
 
   void updateSuggestionList();
@@ -217,6 +222,8 @@ private slots:
   /// polling stops.
   void mouseGrabPoll();
 
+  void pageUnloaded();
+  void articleLoaded();
   void pageLoaded( ArticleView * );
 
   void escapePressed();
@@ -225,6 +232,9 @@ private slots:
 
   void switchExpandOptionalPartsMode();
 
+  void pageLoadingStateChanged( ArticleView *, bool isLoading );
+  void updateBackForwardButtons();
+
   void translateInputChanged(QString const & text);
   void translateInputFinished();
   void wordListItemActivated( QListWidgetItem * );
diff --git a/scripts/blocking.js b/scripts/blocking.js
new file mode 100644
index 00000000..8b9e17e6
--- /dev/null
+++ b/scripts/blocking.js
@@ -0,0 +1,133 @@
+// This file contains variables and functions, loading and evaluating which blocks parsing.
+// This parser blocking is not much of a problem because the scripts are local and
+// instantly available. Furthermore, article requests are running in parallel to this
+// script and usually take more time.
+
+// Objects that are referenced by JavaScript code embedded in the page must be defined here.
+// Functions that can be called from C++ code at any time should be defined here to make the
+// functionality work (more or less) and prevent ReferenceError while the page is being loaded.
+
+var gdWasCurrentArticleSetExplicitly = false;
+
+// This variable is temporary and almost always undefined or null.
+var gdJustLoadedAudioLink;
+
+function gdSetActiveArticle(articleId) {
+    gdWasCurrentArticleSetExplicitly = true;
+    if (gdCurrentArticle !== articleId) {
+        var el = document.getElementById(gdCurrentArticle);
+        if (el)
+            el.className = el.className.replace(' gdactivearticle', '');
+        el = document.getElementById(articleId);
+        el.className = el.className + ' gdactivearticle';
+        gdCurrentArticle = articleId;
+        return true;
+    }
+    return false;
+}
+
+function gdOnCppActiveArticleChangedNoTimestamps(articleId, moveToIt) {
+    if (moveToIt)
+        document.getElementById(articleId).scrollIntoView(true);
+    gdSetActiveArticle(articleId);
+}
+
+function gdSelectCurrentArticle() {
+    var el;
+    if (gdCurrentArticle) {
+        el = document.getElementById(gdCurrentArticle);
+        if (!el) {
+            console.warn("Current article is not yet available, so cannot select it");
+            return;
+        }
+    } else {
+        // Special pages such as the initial Welcome! page or a not-found page have
+        // no dictionary articles, and so gdCurrentArticle is undefined. In this case
+        // consider the entire page to be a single article and select it all.
+        el = document.body;
+    }
+
+    const range = document.createRange();
+    range.selectNodeContents(el);
+
+    const selection = window.getSelection();
+    selection.removeAllRanges();
+    selection.addRange(range);
+}
+
+var gdOverIframeId = null;
+
+function gdProcessIframeMouseOut() {
+    gdOverIframeId = null;
+    top.focus();
+}
+
+function gdProcessIframeMouseOver(newId) {
+    gdOverIframeId = newId;
+}
+
+function gdProcessIframeClick() {
+    if (gdOverIframeId != null) {
+        gdOverIframeId = gdOverIframeId.replace('gdexpandframe-', '');
+        gdMakeArticleActive(gdOverIframeId);
+    }
+}
+
+function gdInit() {
+    window.addEventListener('blur', gdProcessIframeClick, false);
+}
+window.addEventListener('load', gdInit, false);
+
+function gdExpandOptPart(expanderId, optionalId) {
+    const d1 = document.getElementById(expanderId);
+
+    function gdToggleExpanded(alt, iconFilePath, display) {
+        d1.alt = alt;
+        d1.src = iconFilePath;
+        for (var i = 0;; i++) {
+            const d2 = document.getElementById(optionalId + i);
+            if (!d2)
+                break;
+            d2.style.display = display;
+        }
+    }
+
+    if (d1.alt === '[+]')
+        gdToggleExpanded('[-]', 'qrc:///icons/collapse_opt.png', 'inline');
+    else
+        gdToggleExpanded('[+]', 'qrc:///icons/expand_opt.png', 'none');
+}
+
+function gdExpandArticle(id) {
+    const elem = document.getElementById('gdarticlefrom-' + id);
+    const ico = document.getElementById('expandicon-' + id);
+    const art = document.getElementById('gdfrom-' + id);
+    const ev = window.event;
+    var t = null;
+    if (ev)
+        t = ev.target || ev.srcElement;
+    if (elem.style.display === 'inline' && t === ico) {
+        elem.style.display = 'none';
+        ico.className = 'gdexpandicon';
+        art.className = art.className + ' gdcollapsedarticle';
+        const nm = document.getElementById('gddictname-' + id);
+        nm.style.cursor = 'pointer';
+        if (ev)
+            ev.stopPropagation();
+        ico.title = '';
+        nm.title = gdExpandArticleTitle;
+    } else if (elem.style.display === 'none') {
+        elem.style.display = 'inline';
+        ico.className = 'gdcollapseicon';
+        art.className = art.className.replace(' gdcollapsedarticle', '');
+        const nm = document.getElementById('gddictname-' + id);
+        nm.style.cursor = 'default';
+        nm.title = '';
+        ico.title = gdCollapseArticleTitle;
+    }
+}
+
+window.addEventListener('hashchange', function(event) {
+    if (gdArticleView)
+        gdArticleView.onJsLocationHashChanged();
+});
diff --git a/scripts/deferred.js b/scripts/deferred.js
new file mode 100644
index 00000000..8d29814f
--- /dev/null
+++ b/scripts/deferred.js
@@ -0,0 +1,13 @@
+// This file contains code to be evaluated after the document has been parsed.
+
+// Expand collapsed article if only one loaded:
+(function() {
+    const elems = document.getElementsByClassName('gddictname');
+    if (elems.length === 1) {
+        var el = elems.item(0);
+        const s = el.id.replace('gddictname-', '');
+        el = document.getElementById('gdfrom-' + s);
+        if (el && el.className.search('gdcollapsedarticle') > 0)
+            gdExpandArticle(s);
+    }
+})();
diff --git a/scripts/scripts.qrc b/scripts/scripts.qrc
new file mode 100644
index 00000000..5a4b1d5a
--- /dev/null
+++ b/scripts/scripts.qrc
@@ -0,0 +1,11 @@
+<RCC>
+    <qresource prefix="/scripts">
+        <file>blocking.js</file>
+        <file>deferred.js</file>
+        <file>webengine_blocking.js</file>
+        <file>webengine_deferred.js</file>
+        <file>webengine_saved_article.js</file>
+        <file>webkit_blocking.js</file>
+        <file>webkit_saved_article.js</file>
+    </qresource>
+</RCC>
diff --git a/scripts/webengine_blocking.js b/scripts/webengine_blocking.js
new file mode 100644
index 00000000..1ae2acda
--- /dev/null
+++ b/scripts/webengine_blocking.js
@@ -0,0 +1,219 @@
+// See the comment at the top of blocking.js.
+
+let gdArticleView;
+
+let gdCurrentArticle;
+
+// The topmost article on the page or undefined if there are no articles (yet).
+let gdFirstArticle;
+
+// If truthy, contains a fragment string that points to an element within gdCurrentArticle.
+// This fragment string is appended to location.href once gdCurrentArticle is loaded.
+let gdCurrentArticleHash;
+
+// The timestamps prevent timing issues when a current article is passed to/from C++.
+// More details in the comment above the corresponding ArticleView's timestamp data members.
+const gdPageTimestamp = new Date();
+let gdCurrentArticleTimestamp = gdPageTimestamp;
+
+// These 3 variables are temporary and are permanently set to null once gdArticleView becomes available.
+let gdPendingArticles = [];
+let gdPendingAudioLinks = [];
+let gdHasPageInitFinished = false;
+
+// Name the unused gdWebChannel variable to silence Qt Creator's M127 Warning:
+// Expression statements should be assignments, calls or delete expressions only
+const gdWebChannel = new QWebChannel(qt.webChannelTransport, function(channel) {
+    gdArticleView = channel.objects.gdArticleView;
+
+    gdArticleView.onJsPageInitStarted(gdPendingArticles, gdPendingAudioLinks,
+        gdPendingArticles.indexOf(gdCurrentArticle), gdHasPageInitFinished, gdPageTimestamp);
+    gdPendingArticles = null;
+    gdPendingAudioLinks = null;
+    gdHasPageInitFinished = null;
+});
+
+// Save the current article in web history before leaving the page. The current article
+// is restored when the user navigates to a page that has been visited before.
+window.addEventListener('pagehide', function(event) {
+    history.replaceState(gdCurrentArticle, '');
+});
+
+// 1. Initialize gdCurrentArticle. 2. Set gdCurrentArticleHash or add a scrolling event listener.
+(function() {
+    // Returns true if this page is being reloaded; false otherwise.
+    function isPageReloading() {
+        return performance.getEntriesByType('navigation').some(nav => nav.type === 'reload');
+    }
+
+    // The pagehide event occurs just fine when a page starts reloading. However, for some reason
+    // the current article saved in web history cannot be restored in this function upon page reloading
+    // - either history.state is null, or, if the current article has been stored the previous
+    // time this page was loaded, history.state contains an out-of-date current article value.
+    // To work this issue around, the C++ side injects two variables on document creation:
+    // 1) the current article to be restored when the page is reloaded - gdCurrentArticleBeforePageReloading;
+    // 2) whether to scroll to this restored current article - gdScrollToCurrentArticleAfterPageReloading.
+    if (gdCurrentArticleBeforePageReloading && isPageReloading()) {
+        gdCurrentArticle = gdCurrentArticleBeforePageReloading;
+        if (gdScrollToCurrentArticleAfterPageReloading) {
+            // Only scrolling after (not even on) the load event overrides the web engine's
+            // automatic window position restoration, which the C++ side declared undesirable
+            // by setting gdScrollToCurrentArticleAfterPageReloading to true.
+            window.addEventListener('load', function() {
+                setTimeout(function() {
+                    if (!gdWasCurrentArticleSetExplicitly)
+                        document.getElementById(gdCurrentArticle).scrollIntoView();
+                    // else: the user has managed to activate an article already => don't scroll to it.
+                }, 0);
+            });
+        }
+        return;
+    }
+
+    gdCurrentArticle = history.state;
+    if (gdCurrentArticle) {
+        // Restored current article from web history. The web engine will restore the window position automatically.
+        // Scrolling the mouse wheel before the page is fully loaded prevents this window position restoration.
+        // Note: the web engine's automatic vertical scroll position restoration is unreliable. Some positions are
+        // stable and get restored correctly, others shift slightly when restored. This is not much of a problem though.
+        // Should probably be left as is, because manual scroll restoration comes with its own set of problems:
+        // 1) scroll restoration for fragment navigation on the same page has to be handled separately (also manually);
+        // 2) automatic scroll restoration occurs as soon as the necessary amount of content is loaded, while manual
+        //    scroll restoration has to be done at some fixed point of time. If that point is before a 'load' event
+        //    handler (in a deferred script), sometimes a wrong position is restored. A 'load' event handler can be
+        //    invoked much later than the automatic scroll restoration, which decreases perceived responsiveness.
+        return;
+    }
+
+    const searchParams = new URLSearchParams(location.search);
+
+    // Initialize gdCurrentArticle to the scrollto query item value of the page's URL.
+    gdCurrentArticle = searchParams.get('scrollto');
+
+    if (location.hash && location.hash !== '#') {
+        // The page's URL has a non-empty fragment, which overrides scrolling to scrollto or gdanchor.
+
+        // Leaving location.hash as is scrolls to it only after the entire page is loaded.
+        // Furthermore, the scrolling cannot be canceled if the user activates an article
+        // before the page is loaded. Remove the fragment for now; restore it (unless canceled)
+        // when the current article, which contains the element with the fragment id, is loaded.
+
+        // Replacing location.hash with an empty string in location has no effect.
+        // So location.hash has to be replaced with '#' to (almost) clear the fragment.
+        gdCurrentArticleHash = location.hash.substring(1); // exclude the '#' character
+        const urlWithoutFragment = location.href.replace(location.hash, '#');
+        location.replace(urlWithoutFragment);
+        // Now location.href ends with '#', gdCurrentArticleHash does not start with '#'
+        // => there is a single '#' character in (location.href + gdCurrentArticleHash).
+        return;
+    }
+
+    // TODO (Qt WebEngine): port MDict gdanchor pattern support from Qt WebKit's scrollToGdAnchor() to JavaScript.
+    // The answers to the following question can help to implement this:
+    // https://stackoverflow.com/questions/16791527/can-i-use-a-regular-expression-in-queryselectorall
+    // Hopefully the substring matching attribute selectors ([att^=val], [att$=val]) would suffice, and
+    // the more complex DOMRegex GitHub Gist referenced in a comment to the second answer won't be needed.
+    gdCurrentArticleHash = searchParams.get('gdanchor');
+
+    if (!gdCurrentArticleHash)
+        gdCurrentArticleHash = gdCurrentArticle; // Scroll to the target article if there is no fragment.
+
+    if (gdCurrentArticleHash) {
+        // Unless location.hash equals '#' and consequently location.href ends with '#', make gdCurrentArticleHash
+        // start with '#'. This ensures a single '#' character in (location.href + gdCurrentArticleHash).
+        if (!location.hash)
+            gdCurrentArticleHash = '#' + gdCurrentArticleHash;
+    }
+})();
+
+function gdCurrentArticleLoaded() {
+    document.getElementById(gdCurrentArticle).className += ' gdactivearticle';
+
+    // Unlike Element.scrollIntoView(), setting the URL fragment works correctly in background tabs.
+    // When location.hash is set after the HTML element with the corresponding id has been loaded, the
+    // scrolling is immediate.
+    if (gdCurrentArticleHash) {
+        location.replace(location.href + gdCurrentArticleHash);
+        gdCurrentArticleHash = null;
+    }
+}
+
+function gdArticleLoaded(articleId) {
+    if (!gdFirstArticle) {
+        gdFirstArticle = articleId;
+        if (!gdCurrentArticle)
+            gdCurrentArticle = gdFirstArticle;
+    }
+
+    const isCurrent = articleId === gdCurrentArticle;
+    // gdWasCurrentArticleSetExplicitly === true means that the user has activated this article while it was being
+    // loaded. Don't call gdCurrentArticleLoaded() in this case, because the article's className is already correct
+    // and the user's interaction with the page should cancel the automatic scrolling to the target article or fragment.
+    if (isCurrent && !gdWasCurrentArticleSetExplicitly)
+        gdCurrentArticleLoaded();
+
+    if (gdArticleView)
+        gdArticleView.onJsArticleLoaded(articleId, gdJustLoadedAudioLink, isCurrent);
+    else {
+        gdPendingArticles.push(articleId);
+        gdPendingAudioLinks.push(gdJustLoadedAudioLink);
+    }
+    gdJustLoadedAudioLink = null;
+}
+
+function gdMakeArticleActive(newId) {
+    gdCurrentArticleTimestamp = new Date();
+    gdSetActiveArticle('gdfrom-' + newId);
+    // Call gdArticleView.onJsActiveArticleChanged() even if gdSetActiveArticle returns false and gdCurrentArticle
+    // is unchanged. This is necessary to send the updated gdCurrentArticleTimestamp value and possibly overwrite
+    // an obsolete current article value on the C++ side, which hasn't been received by JavaScript yet.
+    if (gdArticleView)
+        gdArticleView.onJsActiveArticleChanged(gdCurrentArticle, gdCurrentArticleTimestamp);
+    // else: the updated gdCurrentArticle will be passed in gdArticleView.onJsPageInitStarted().
+}
+
+function gdOnCppActiveArticleChanged(articleId, moveToIt, pageTimestampString, currentArticleTimestampString) {
+    const pageTimestamp = new Date(pageTimestampString);
+    const currentArticleTimestamp = new Date(currentArticleTimestampString);
+    // operator=== compares objects and would always compare page timestamps as not equal. To offer protection
+    // against timing attacks and fingerprinting, the precision of new Date().getTime() might get rounded
+    // depending on browser settings, so it cannot be used to compare page timestamps either. operator< works
+    // here, because a next page's JavaScript code couldn't have sent its newer page timestamp to the C++ code.
+    // Compare the received and stored current article timestamps using operator<= here and using
+    // operator< in the C++ code to ensure that the current article values are always consistent, even
+    // if the user manages to activate different articles in JavaScript and C++ at the same time.
+    if (pageTimestamp < gdPageTimestamp || currentArticleTimestamp <= gdCurrentArticleTimestamp)
+        return; // This current article update is meant for a previous page or is stale => ignore it.
+    gdCurrentArticleTimestamp = currentArticleTimestamp;
+
+    gdOnCppActiveArticleChangedNoTimestamps(articleId, moveToIt);
+}
+
+function gdBodyMouseDown(event) {
+    if (gdSelectWordBySingleClick && gdArticleView && event.button === 0 && event.detail === 1)
+        gdArticleView.onJsFirstLeftButtonMouseDown();
+}
+
+function gdBodyMouseUp(event) {
+    // When "Select word by single click" option is off and the user double-clicks a word, it becomes selected some time
+    // after QWebEngineView::mouseDoubleClickEvent(), not during this event handler as in the Qt WebKit version. The
+    // implementation of "Double-click translates the word clicked" option translates a currently selected word and
+    // needs up-to-date selection. The selection is empty at the time of a second JavaScript mousedown event. Send the
+    // double-clicked message to ArticleView on a second mouseup JavaScript event, at which time the selection is
+    // up-to-date. This later translation is useful: the user can double-click a word, extend selection to one or more
+    // neighboring words, then release the left mouse button. Such a prolonged double-click translates the selected
+    // multi-word phrase, while only a single word can be translated by a double-click in the Qt WebKit version.
+
+    // Normally a second mouseup event (with event.detail === 2) signifies a double click. But when
+    // "Select word by single click" option is on, a second mouseup event occurs after a single click due to
+    // an artificial double click synthesized by ArticleView. Fortunately, when this option is on, ArticleView also
+    // filters out a second non-synthesized mousedown event (MouseButtonDblClick) in a user's double click before
+    // it reaches JavaScript, which makes event.detail of a second non-synthesized mouseup event unique - equal to 0.
+    const targetClickCount = gdSelectWordBySingleClick ? 0 : 2;
+    if (gdArticleView && event.button === 0 && event.detail === targetClickCount) {
+        let imageUrl = null;
+        if (event.target.tagName.toLowerCase() === 'img')
+            imageUrl = event.target.currentSrc;
+        gdArticleView.onJsDoubleClicked(imageUrl);
+    }
+}
diff --git a/scripts/webengine_deferred.js b/scripts/webengine_deferred.js
new file mode 100644
index 00000000..d5a15a12
--- /dev/null
+++ b/scripts/webengine_deferred.js
@@ -0,0 +1,36 @@
+// See the comment at the top of deferred.js.
+
+// If gdCurrentArticle is invalid, activate the first (topmost) article on the page:
+(function() {
+    if (!gdCurrentArticle) {
+        console.assert(!gdFirstArticle, "gdArticleLoaded() must have assigned gdFirstArticle to gdCurrentArticle");
+        return;
+    }
+
+    if (!gdFirstArticle) {
+        // Zero articles on the page => no current article.
+        gdCurrentArticle = null;
+        return;
+    }
+
+    if (document.getElementById(gdCurrentArticle))
+        return; // gdCurrentArticle is valid => nothing to do.
+
+    if (gdCurrentArticleHash === gdCurrentArticle || gdCurrentArticleHash === '#' + gdCurrentArticle) {
+        // Don't try to scroll to the absent HTML element with id=gdCurrentArticle.
+        gdCurrentArticleHash = null;
+    }
+    // else: if gdCurrentArticleHash is truthy, its target HTML element probably does not exist on this page since the
+    // target article is missing. Try to scroll to it anyway, in case it somehow refers to another article's element.
+    gdCurrentArticle = gdFirstArticle;
+    gdCurrentArticleLoaded();
+
+    // When gdCurrentArticle is invalid, ArticleView::currentArticle is empty, in which case
+    // ArticleView::onJsPageInitFinished() makes the first article current. So there is no need
+    // to notify gdArticleView about this function's deterministic assignment to gdCurrentArticle.
+})();
+
+if (gdArticleView)
+    gdArticleView.onJsPageInitFinished();
+else
+    gdHasPageInitFinished = true;
diff --git a/scripts/webengine_saved_article.js b/scripts/webengine_saved_article.js
new file mode 100644
index 00000000..7a072483
--- /dev/null
+++ b/scripts/webengine_saved_article.js
@@ -0,0 +1,11 @@
+// This file contains code to be evaluated only in a complete saved article, not
+// inside GoldenDict. The dummy object and function definitions prevent JavaScript
+// errors when a complete saved article is opened in an external browser.
+
+const qt = {
+    webChannelTransport: {
+        send(a) {}
+    }
+};
+const gdCurrentArticleBeforePageReloading = null;
+const gdSelectWordBySingleClick = null;
diff --git a/scripts/webkit_blocking.js b/scripts/webkit_blocking.js
new file mode 100644
index 00000000..e4f6cc12
--- /dev/null
+++ b/scripts/webkit_blocking.js
@@ -0,0 +1,23 @@
+// See the comment at the top of blocking.js.
+
+gdArticleView.onJsPageInitStarted();
+
+var gdCurrentArticle;
+
+function gdArticleLoaded(articleId) {
+    if (!gdCurrentArticle)
+        gdCurrentArticle = articleId; // This is the first article. It becomes current when loaded.
+
+    const isCurrent = articleId === gdCurrentArticle;
+    gdArticleView.onJsArticleLoaded(articleId, gdJustLoadedAudioLink, isCurrent);
+    gdJustLoadedAudioLink = null;
+}
+
+function gdMakeArticleActive(newId) {
+    if (gdSetActiveArticle('gdfrom-' + newId))
+        gdArticleView.onJsActiveArticleChanged(gdCurrentArticle);
+}
+
+function gdOnCppActiveArticleChanged(articleId, moveToIt) {
+    gdOnCppActiveArticleChangedNoTimestamps(articleId, moveToIt);
+}
diff --git a/scripts/webkit_saved_article.js b/scripts/webkit_saved_article.js
new file mode 100644
index 00000000..1c358dc0
--- /dev/null
+++ b/scripts/webkit_saved_article.js
@@ -0,0 +1,10 @@
+// This file contains code to be evaluated only in a complete saved article, not
+// inside GoldenDict. The dummy object and function definitions prevent JavaScript
+// errors when a complete saved article is opened in an external browser.
+
+const gdArticleView = {
+    onJsPageInitStarted() {},
+    onJsArticleLoaded(a, b, c) {},
+    onJsActiveArticleChanged(a) {},
+    onJsLocationHashChanged() {}
+};
diff --git a/sounddir.cc b/sounddir.cc
index 75581374..a3d410b0 100644
--- a/sounddir.cc
+++ b/sounddir.cc
@@ -226,9 +226,9 @@ sptr< Dictionary::DataRequest > SoundDirDictionary::getArticle( wstring const &
 
     string ref = string( "\"" ) + url.toEncoded().data() + "\"";
 
-    result += addAudioLink( ref, getId() );
+    result += addAudioLink( ref );
 
-    result += "<td><a href=" + ref + "><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
+    result += "<td><a href=" + ref + "><img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
     result += "<td><a href=" + ref + ">" + Html::escape( displayedName ) + "</a></td>";
     result += "</tr>";
   }
@@ -270,9 +270,9 @@ sptr< Dictionary::DataRequest > SoundDirDictionary::getArticle( wstring const &
 
     string ref = string( "\"" ) + url.toEncoded().data() + "\"";
 
-    result += addAudioLink( ref, getId() );
+    result += addAudioLink( ref );
 
-    result += "<td><a href=" + ref + "><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
+    result += "<td><a href=" + ref + "><img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
     result += "<td><a href=" + ref + ">" + Html::escape( displayedName ) + "</a></td>";
     result += "</tr>";
   }
diff --git a/square_label.hh b/square_label.hh
new file mode 100644
index 00000000..e9ea49f9
--- /dev/null
+++ b/square_label.hh
@@ -0,0 +1,37 @@
+/* This file is (c) 2022 Igor Kushnir <igorkuo@gmail.com>
+ * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */
+
+#ifndef SQUARE_LABEL_HH_INCLUDED
+#define SQUARE_LABEL_HH_INCLUDED
+
+#include <QLabel>
+
+class SquareLabel: public QLabel
+{
+  Q_OBJECT
+public:
+  explicit SquareLabel( QWidget * parent = 0 ): QLabel( parent ), sameHeightWidget( 0 )
+  {}
+
+  /// Binds this square label's side to @p widget's height.
+  /// @warning This label must be destroyed along with or after @p widget.
+  /// Make sure to call updateGeometry() on this label whenever @p widget's height may have changed.
+  void setSameHeightWidget( QWidget const * widget )
+  { sameHeightWidget = widget; }
+
+  virtual QSize sizeHint() const
+  {
+    if( !sameHeightWidget )
+      return QLabel::sizeHint();
+    int const height = sameHeightWidget->height();
+    return QSize( height, height );
+  }
+
+  virtual QSize minimumSizeHint() const
+  { return sizeHint(); }
+
+private:
+  QWidget const * sameHeightWidget;
+};
+
+#endif // SQUARE_LABEL_HH_INCLUDED
diff --git a/stardict.cc b/stardict.cc
index fce8e850..6340073f 100644
--- a/stardict.cc
+++ b/stardict.cc
@@ -607,7 +607,7 @@ string StardictDictionary::handleResource( char type, char const * resource, siz
         else
         {
           std::string href = "\"gdau://" + getId() + "/" + src.toUtf8().data() + "\"";
-          QString newTag = QString::fromUtf8( ( addAudioLink( href, getId() ) + "<span class=\"sdict_h_wav\"><a href=" + href + ">" ).c_str() );
+          QString newTag = QString::fromUtf8( ( addAudioLink( href ) + "<span class=\"sdict_h_wav\"><a href=" + href + ">" ).c_str() );
 #if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
           newTag += match.captured( 4 );
           if( match.captured( 4 ).indexOf( "<img " ) < 0 )
@@ -615,7 +615,7 @@ string StardictDictionary::handleResource( char type, char const * resource, siz
           newTag += audioRe.cap( 4 );
           if( audioRe.cap( 4 ).indexOf( "<img " ) < 0 )
 #endif
-            newTag += " <img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\">";
+            newTag += " <img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\">";
           newTag += "</a></span>";
 
 #if QT_VERSION >= QT_VERSION_CHECK( 5, 0, 0 )
diff --git a/translatebox.cc b/translatebox.cc
index 03da07bf..374fd0fb 100644
--- a/translatebox.cc
+++ b/translatebox.cc
@@ -117,8 +117,11 @@ TranslateBox::TranslateBox(QWidget *parent) : QWidget(parent),
   layout->setMargin(0);
   layout->addWidget(translate_line);
 
-  QPixmap image(":/icons/system-search.png");
-  translate_line->setButtonPixmap(ExtLineEdit::Left, image.scaled(18, 18, Qt::KeepAspectRatio, Qt::SmoothTransformation));
+  translate_line->setButtonPixmap( ExtLineEdit::Left,
+                                   ExtLineEdit::scaledForButtonPixmap( QPixmap( ":/icons/system-search.png" ) ) );
+  // Don't animate the "loading" icon in a QMovie, because that measurably wastes CPU time, which could be a problem,
+  // especially in case GoldenDict is stuck in the loading state due to a bug such as QTBUG-106580.
+  translate_line->setAlternativeLeftPixmap( ExtLineEdit::scaledForButtonPixmap( QPixmap( ":/icons/loading.gif" ) ) );
   // translate_line->setButtonToolTip(ExtLineEdit::Left, tr("Options"));
   translate_line->setButtonVisible(ExtLineEdit::Left, true);
   translate_line->setButtonFocusPolicy(ExtLineEdit::Left, Qt::ClickFocus);
@@ -242,6 +245,11 @@ void TranslateBox::setSizePolicy( QSizePolicy policy )
     translate_line->setSizePolicy( policy );
 }
 
+void TranslateBox::setIsPageLoading( bool isLoading )
+{
+  translate_line->setAlternativeLeftPixmapVisible( isLoading );
+}
+
 void TranslateBox::showPopup()
 {
   // completer->setCompletionPrefix( m_fileLineEdit->text() );
diff --git a/translatebox.hh b/translatebox.hh
index 6b823216..9cdbaed4 100644
--- a/translatebox.hh
+++ b/translatebox.hh
@@ -49,6 +49,9 @@ public:
   inline void setSizePolicy(QSizePolicy::Policy hor, QSizePolicy::Policy ver)
   { setSizePolicy(QSizePolicy(hor, ver)); }
 
+  /// @param isLoading whether the visible page bound to this translate box is currently loading.
+  void setIsPageLoading( bool isLoading );
+
 signals:
 
 public slots:
diff --git a/voiceengines.cc b/voiceengines.cc
index 877f3dbe..bd947c6e 100644
--- a/voiceengines.cc
+++ b/voiceengines.cc
@@ -98,9 +98,9 @@ sptr< Dictionary::DataRequest > VoiceEnginesDictionary::getArticle(
 
   string encodedUrl = url.toEncoded().data();
   string ref = string( "\"" ) + encodedUrl + "\"";
-  result += addAudioLink( ref, getId() );
+  result += addAudioLink( ref );
 
-  result += "<td><a href=" + ref + "><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
+  result += "<td><a href=" + ref + "><img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
   result += "<td><a href=" + ref + ">" + Html::escape( wordUtf8 ) + "</a></td>";
   result += "</tr></table>";
 
diff --git a/webkit_or_webengine.hh b/webkit_or_webengine.hh
new file mode 100644
index 00000000..df70dc26
--- /dev/null
+++ b/webkit_or_webengine.hh
@@ -0,0 +1,19 @@
+/* This file is (c) 2022 Igor Kushnir <igorkuo@gmail.com>
+ * Part of GoldenDict. Licensed under GPLv3 or later, see the LICENSE file */
+
+#ifndef WEBKIT_OR_WEBENGINE_HH_INCLUDED
+#define WEBKIT_OR_WEBENGINE_HH_INCLUDED
+
+#ifdef USE_QTWEBKIT
+#include <QWebPage>
+#include <QWebView>
+typedef QWebPage WebPage;
+typedef QWebView WebView;
+#else
+#include <QWebEnginePage>
+#include <QWebEngineView>
+typedef QWebEnginePage WebPage;
+typedef QWebEngineView WebView;
+#endif
+
+#endif // WEBKIT_OR_WEBENGINE_HH_INCLUDED
diff --git a/website.cc b/website.cc
index 0a41e6b9..805d478f 100644
--- a/website.cc
+++ b/website.cc
@@ -501,8 +501,8 @@ sptr< DataRequest > WebSiteDictionary::getArticle( wstring const & str,
 
     result += string( "<iframe id=\"gdexpandframe-" ) + getId() +
                       "\" src=\"" + urlString.data() +
-                      "\" onmouseover=\"processIframeMouseOver('gdexpandframe-" + getId() + "');\" "
-                      "onmouseout=\"processIframeMouseOut();\" "
+                      "\" onmouseover=\"gdProcessIframeMouseOver('gdexpandframe-" + getId() + "');\" "
+                      "onmouseout=\"gdProcessIframeMouseOut();\" "
                       "scrolling=\"no\" marginwidth=\"0\" marginheight=\"0\" "
                       "frameborder=\"0\" vspace=\"0\" hspace=\"0\" "
                       "style=\"overflow:visible; width:100%; display:none;\">"
diff --git a/xdxf2html.cc b/xdxf2html.cc
index b86bbffa..262054d5 100644
--- a/xdxf2html.cc
+++ b/xdxf2html.cc
@@ -679,11 +679,9 @@ string convert( string const & in, DICT_TYPE type, map < string, string > const
             url.setHost( QString::fromUtf8( search ? "search" : dictPtr->getId().c_str() ) );
             url.setPath( Qt4x5::Url::ensureLeadingSlash( QString::fromUtf8( filename.c_str() ) ) );
 
-            el_script.setAttribute( "type", "text/javascript" );
             parent.replaceChild( el_script, el );
 
-            QDomText el_txt = dd.createTextNode( makeAudioLinkScript( string( "\"" ) + url.toEncoded().data() + "\"",
-                                                                      dictPtr->getId() ).c_str() );
+            QDomText el_txt = dd.createTextNode( makeAudioLinkScript( string( "\"" ) + url.toEncoded().data() + "\"" ).c_str() );
             el_script.appendChild( el_txt );
 
             QDomElement el_span = dd.createElement( "span" );
@@ -695,7 +693,7 @@ string convert( string const & in, DICT_TYPE type, map < string, string > const
             el_span.appendChild( el_a );
 
             QDomElement el_img = dd.createElement( "img");
-            el_img.setAttribute( "src", "qrcx://localhost/icons/playsound.png" );
+            el_img.setAttribute( "src", "qrc:///icons/playsound.png" );
             el_img.setAttribute( "border", "0" );
             el_img.setAttribute( "align", "absmiddle" );
             el_img.setAttribute( "alt", "Play" );
diff --git a/zipsounds.cc b/zipsounds.cc
index f4b27351..9772f058 100644
--- a/zipsounds.cc
+++ b/zipsounds.cc
@@ -277,9 +277,9 @@ sptr< Dictionary::DataRequest > ZipSoundsDictionary::getArticle( wstring const &
 
     string ref = string( "\"" ) + url.toEncoded().data() + "\"";
 
-    result += addAudioLink( ref, getId() );
+    result += addAudioLink( ref );
 
-    result += "<td><a href=" + ref + "><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
+    result += "<td><a href=" + ref + "><img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
     result += "<td><a href=" + ref + ">" + Html::escape( displayedName ) + "</a></td>";
     result += "</tr>";
   }
@@ -323,9 +323,9 @@ sptr< Dictionary::DataRequest > ZipSoundsDictionary::getArticle( wstring const &
 
     string ref = string( "\"" ) + url.toEncoded().data() + "\"";
 
-    result += addAudioLink( ref, getId() );
+    result += addAudioLink( ref );
 
-    result += "<td><a href=" + ref + "><img src=\"qrcx://localhost/icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
+    result += "<td><a href=" + ref + "><img src=\"qrc:///icons/playsound.png\" border=\"0\" alt=\"Play\"/></a></td>";
     result += "<td><a href=" + ref + ">" + Html::escape( displayedName ) + "</a></td>";
     result += "</tr>";
   }
